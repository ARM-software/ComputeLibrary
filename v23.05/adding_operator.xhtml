<!-- HTML header for doxygen 1.8.15-->
<!-- Remember to use version doxygen 1.8.15 +-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="robots" content="NOINDEX, NOFOLLOW" /> <!-- Prevent indexing by search engines -->
<title>Compute Library: How to Add a New Operator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <img alt="Compute Library" src="https://raw.githubusercontent.com/ARM-software/ComputeLibrary/gh-pages/ACL_logo.png" style="max-width: 100%;margin-top: 15px;margin-left: 10px"/>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">23.05</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('adding_operator.xhtml','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How to Add a New Operator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#S4_0_introduction">Adding new operators</a></li>
<li class="level1"><a href="#S4_1_introduction">Introduction</a></li>
<li class="level1"><a href="#S4_1_supporting_new_operators">Supporting new operators</a><ul><li class="level2"><a href="#S4_1_1_add_datatypes">Adding new data types</a></li>
<li class="level2"><a href="#S4_1_2_add_kernel">Add a kernel</a></li>
<li class="level2"><a href="#S4_1_3_add_function">Add a function</a></li>
<li class="level2"><a href="#S4_1_4_add_validation">Add validation artifacts</a><ul><li class="level3"><a href="#S4_1_4_1_add_reference">Add the reference implementation and the tests</a></li>
<li class="level3"><a href="#S4_1_4_2_add_dataset">Add dataset</a></li>
<li class="level3"><a href="#S4_1_4_3_add_fixture">Add a fixture and a data test case</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="S4_0_introduction"></a>
Adding new operators</h1>
<h1><a class="anchor" id="S4_1_introduction"></a>
Introduction</h1>
<p>In Compute Library there are two main parts or modules:</p><ul>
<li>The core library consists of a low-level collection of algorithms implemented in C++ and optimized for Arm CPUs and GPUs. The core module is designed to be embedded in other projects and it doesn't perform any memory management or scheduling.</li>
<li>The runtime library is a wrapper of the core library and provides other additional features like memory management, multithreaded execution of workloads and allocation of the intermediate tensors.</li>
</ul>
<p>The library can be integrated in an existing external library or application that provides its own scheduler or a specific memory manager. In that case, the right solution is to use only the core library which means that the user must also manage all the memory allocation not only for the input/output tensor but also for the intermediate tensors/variables necessary. On the other hand, if the user doesn't want to care about allocation and multithreading then the right choice is to use the functions from the runtime library.</p>
<p>Apart from these components that get linked into the application, the sources also include the validation test suite and the C++ reference implementations against which all the operators are validated.</p>
<h1><a class="anchor" id="S4_1_supporting_new_operators"></a>
Supporting new operators</h1>
<p>Following are the steps involved in adding support for a new operator in Compute Library</p><ul>
<li>Add new data types (if required)</li>
<li>Add the kernel to the core library.</li>
<li>Add the function to the runtime library.</li>
<li>Add validation tests.<ul>
<li>Add the reference implementation.</li>
<li>Add the fixture</li>
<li>register the tests.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="S4_1_1_add_datatypes"></a>
Adding new data types</h2>
<p>Compute Library declares a few new datatypes related to its domain, kernels, and functions in the library process Tensors and Images (Computer Vision functions). Tensors are multi-dimensional arrays with a maximum of <a class="el" href="classarm__compute_1_1_dimensions.xhtml#a1b67d5b720119d50faa286c774579ecc" title="Number of dimensions the tensor has. ">Coordinates::num_max_dimensions</a> dimensions; depending on the number of dimensions tensors can be interpreted as various objects. A scalar can be represented as a zero-dimensional tensor and a vector of numbers can be represented as a one-dimensional tensor. Furthermore, an image is just a 2D tensor, a 3D tensor can be seen as an array of images and a 4D tensor as a 2D array of images, etc. All the datatype classes or structures are grouped in the core library folder arm_compute/core like the <a class="el" href="classarm__compute_1_1_i_tensor.xhtml">ITensor</a>, <a class="el" href="classarm__compute_1_1_i_tensor_info.xhtml">ITensorInfo</a> (all the information of a tensor), <a class="el" href="classarm__compute_1_1_tensor_shape.xhtml" title="Shape of a tensor. ">TensorShape</a> and simpler types are in <a class="el" href="arm__compute_2core_2_types_8h.xhtml">arm_compute/core/Types.h</a>.</p>
<p>If an operator handles a new datatype, it must be added to the library. While adding a new data type to the library, it's necessary to implement the function to enable printing, the <a class="el" href="namespacearm__compute.xhtml#a1d8c24abe3cf6edd704d126d1d2a5420" title="Fallback method: try to use std::to_string: ">to_string()</a> method and the output stream insertion (&lt;&lt;) operator. Every datatype implements these two functions in <a class="el" href="utils_2_type_printer_8h.xhtml">utils/TypePrinter.h</a></p>
<p>A quick example, in <a href="https://github.com/ARM-software/ComputeLibrary/blob/main/arm_compute/core/Types.h">Types.h</a> we add:</p>
<div class="fragment"><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/** Supported tensor data layouts */</span></div><div class="line"><span class="keyword">enum class</span> <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0">DataLayout</a></div><div class="line">{</div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#a735ac6c2a02e320969625308810444f3a696b031073e74bf2cb98e5ef201d4aa3">UNKNOWN</a>, <span class="comment">/**&lt; Unknown data layout */</span></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0a6b99f356fe3b30a2a850b5ea897c289f">NCHW</a>,    <span class="comment">/**&lt; Num samples, channels, height, width */</span></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0ad066db54b89b0912e7e7c6da51e2da51">NHWC</a>,    <span class="comment">/**&lt; Num samples, height, width, channels */</span></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0a884e0167ebf9bbe6cfd6ca5ab97ab015">NCDHW</a>,   <span class="comment">/**&lt; Num samples, channels, depth, height, width */</span></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0a4dd0194b114cbf51da5b3a72569863ef">NDHWC</a>    <span class="comment">/**&lt; Num samples, depth, height, width, channels */</span></div><div class="line">};</div></div><!-- fragment --><p> And for printing:</p>
<div class="fragment"><div class="line"><span class="comment">/** Formatted output of the DataLayout type.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param[out] os          Output stream.</span></div><div class="line"><span class="comment"> * @param[in]  data_layout Type to output.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @return Modified output stream.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">inline ::std::ostream &amp;<a class="code" href="namespacearm__compute.xhtml#a248960645748af1bfddffa5ed711530a">operator&lt;&lt;</a>(::std::ostream &amp;os, <span class="keyword">const</span> <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0">DataLayout</a> &amp;<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#acf5f12bbab64dd614bd8220c97fe484f">data_layout</a>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span>(data_layout)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#a735ac6c2a02e320969625308810444f3a696b031073e74bf2cb98e5ef201d4aa3">DataLayout::UNKNOWN</a>:</div><div class="line">            os &lt;&lt; <span class="stringliteral">&quot;UNKNOWN&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0ad066db54b89b0912e7e7c6da51e2da51">DataLayout::NHWC</a>:</div><div class="line">            os &lt;&lt; <span class="stringliteral">&quot;NHWC&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0a6b99f356fe3b30a2a850b5ea897c289f">DataLayout::NCHW</a>:</div><div class="line">            os &lt;&lt; <span class="stringliteral">&quot;NCHW&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0a4dd0194b114cbf51da5b3a72569863ef">DataLayout::NDHWC</a>:</div><div class="line">            os &lt;&lt; <span class="stringliteral">&quot;NDHWC&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0a884e0167ebf9bbe6cfd6ca5ab97ab015">DataLayout::NCDHW</a>:</div><div class="line">            os &lt;&lt; <span class="stringliteral">&quot;NCDHW&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="_error_8h.xhtml#a7cf8d8b669b8f7b05680230be30d60f4">ARM_COMPUTE_ERROR</a>(<span class="stringliteral">&quot;NOT_SUPPORTED!&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> os;</div><div class="line">}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/** Formatted output of the DataLayout type.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param[in] data_layout Type to output.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @return Formatted string.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">inline</span> std::string <a class="code" href="namespacearm__compute.xhtml#a1d8c24abe3cf6edd704d126d1d2a5420">to_string</a>(<span class="keyword">const</span> <a class="code" href="namespacearm__compute.xhtml#ad1d5cce2d9e9a5d61c243e5c989112e0">arm_compute::DataLayout</a> &amp;data_layout)</div><div class="line">{</div><div class="line">    std::stringstream <a class="code" href="namespacecaffe__mnist__image__extractor.xhtml#a4b99ff73a8a869319570237b5c57ab03">str</a>;</div><div class="line">    str &lt;&lt; <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#acf5f12bbab64dd614bd8220c97fe484f">data_layout</a>;</div><div class="line">    <span class="keywordflow">return</span> str.str();</div><div class="line">}</div></div><!-- fragment --><p> In Compute Library, we use namespaces to group all the operators, functions, classes and interfaces. The main namespace to use is <a class="el" href="namespacearm__compute.xhtml" title="Copyright (c) 2017-2023 Arm Limited. ">arm_compute</a>. In the test suite, the test framework and the individual tests use nested namespaces like <a class="el" href="namespacearm__compute_1_1test_1_1validation.xhtml">test::validation</a> or <a class="el" href="namespacearm__compute_1_1test_1_1benchmark.xhtml">test::benchmark</a> to group the different purposes of various parts of the suite. Utility functions like conversion or type cast operators, that are shared by multiple operators are in <a class="el" href="arm__compute_2core_2_utils_8h.xhtml">arm_compute/core/Utils.h</a>. Non-inlined function definitions go in the corresponding .cpp files in the src folder. Similarly, all common functions that process shapes, like calculating output shapes of an operator or shape conversions etc are in <a class="el" href="_shape_calculator_8h.xhtml">arm_compute/core/utils/misc/ShapeCalculator.h</a>.</p>
<h2><a class="anchor" id="S4_1_2_add_kernel"></a>
Add a kernel</h2>
<p>As we mentioned at the beginning, the kernel is the implementation of the operator or algorithm partially using a specific programming language related to the backend we want to use. Adding a kernel in the library means implementing the algorithm in a SIMD technology like Arm® Neon™ or OpenCL. All kernels in Compute Library must implement a common interface <a class="el" href="classarm__compute_1_1_i_kernel.xhtml" title="Common information for all the kernels. ">IKernel</a> or one of the specific subinterfaces. <a class="el" href="classarm__compute_1_1_i_kernel.xhtml" title="Common information for all the kernels. ">IKernel</a> is the common interface for all the kernels in the core library, it contains the main methods for configure and run the kernel itself, such as window() that return the maximum window the kernel can be executed on or is_parallelisable() for indicate whether or not the kernel is parallelizable. If the kernel is parallelizable then the window returned by the window() method can be split into sub-windows which can then be run in parallel, in the other case, only the window returned by window() can be passed to the run method. There are specific interfaces for OpenCL and Neon™: <a class="el" href="classarm__compute_1_1_i_c_l_kernel.xhtml">ICLKernel</a>, INEKernel (using INEKernel = <a class="el" href="classarm__compute_1_1_i_c_p_p_kernel.xhtml">ICPPKernel</a>).</p>
<ul>
<li><a class="el" href="classarm__compute_1_1_i_c_l_kernel.xhtml">ICLKernel</a> is the common interface for all the OpenCL kernels. It implements the inherited methods and adds all the methods necessary to configure the CL kernel, such as set/return the Local-Workgroup-Size hint, add single, array or tensor argument, set the targeted GPU architecture according to the CL device. All these methods are used during the configuration and the run of the operator.</li>
<li>INEKernel inherits from <a class="el" href="classarm__compute_1_1_i_kernel.xhtml">IKernel</a> as well and it's the common interface for all kernels implemented in Neon™, it adds just the run and the name methods.</li>
</ul>
<p>There are two others implementation of <a class="el" href="classarm__compute_1_1_i_kernel.xhtml">IKernel</a> called <a class="el" href="classarm__compute_1_1_i_c_l_simple_kernel.xhtml">ICLSimpleKernel</a> and INESimpleKernel, they are the interface for simple kernels that have just one input tensor and one output tensor. Creating a new kernel implies adding new files:</p><ul>
<li>src/core/CL/kernels/CLReshapeLayerKernel.h</li>
<li>src/core/CL/cl_kernels/reshape_layer.cl</li>
<li>src/core/CL/kernels/CLReshapeLayerKernel.cpp</li>
<li><a class="el" href="core_2_c_l_2_c_l_kernel_library_8cpp.xhtml">src/core/CL/CLKernelLibrary.cpp</a></li>
</ul>
<p>Neon™ kernel</p><ul>
<li>arm_compute/core/NEON/kernels/NEReshapeLayerKernel.h</li>
<li>src/core/NEON/kernels/NEReshapeLayerKernel.cpp</li>
</ul>
<p>We must register the new layer in the respective libraries:</p><ul>
<li><a class="el" href="_c_l_kernels_8h.xhtml">src/core/CL/CLKernels.h</a></li>
<li>arm_compute/core/NEON/NEKernels.h</li>
</ul>
<p>These files contain the list of all kernels available in the corresponding Compute Library's backend, for example CLKernels: </p><div class="fragment"><div class="line">...</div><div class="line">#include <span class="stringliteral">&quot;src/core/CL/kernels/CLMinMaxLayerKernel.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;src/core/CL/kernels/CLMinMaxLocationKernel.h&quot;</span></div><div class="line">...</div><div class="line">#include <span class="stringliteral">&quot;src/core/CL/kernels/CLReshapeLayerKernel.h&quot;</span></div><div class="line">...</div></div><!-- fragment --><p>For OpenCL we need to update the CLKernelLibrary.cpp, adding the appropriate code to embed the .cl kernel in the library. The OpenCL code can be compiled offline and embed in the library as binary. The essential operation we want to do with a kernel will be</p><ul>
<li>create the kernel object</li>
<li>initialize the kernel with the input/output and any other parameters that may be required</li>
<li>retrieve the execution window of the kernel and run the whole kernel window in the current thread or use the multithreading.</li>
</ul>
<p>Each kernel will have to implement the method:</p><ul>
<li>validate: is a static function that checks if the given info will lead to a valid configuration of the kernel.</li>
<li>configure: configure the kernel, its window, accessor, valid region, etc for the given set of tensors and other parameters.</li>
<li>run: execute the kernel in the window</li>
</ul>
<p>The structure of the kernel .cpp file should be similar to the next ones. For OpenCL: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacearm__compute.xhtml">arm_compute</a></div><div class="line">{</div><div class="line"><span class="keyword">namespace </span>opencl</div><div class="line">{</div><div class="line"><span class="keyword">namespace </span>kernels</div><div class="line">{</div><div class="line"><span class="keyword">namespace</span></div><div class="line">{</div><div class="line">Status <a class="code" href="namespacearm__compute_1_1cpu_1_1kernels.xhtml#acf9ea6633274730cd08b8b8fab3a6fe6">validate_arguments</a>(<span class="keyword">const</span> ITensorInfo *<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a70879f7be69f6738d9f76339725c9532">src</a>, <span class="keyword">const</span> ITensorInfo *<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#adbf67dcee294e673cf796f1ed8aeb6a4">dst</a>)</div><div class="line">{</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#aff911654521523937ff24372a870b89f">ARM_COMPUTE_RETURN_ERROR_ON_NULLPTR</a>(src, dst);</div><div class="line">    <a class="code" href="_c_l_validate_8h.xhtml#ab82bd5de18ef067ae5d9ba4af8065dd6">ARM_COMPUTE_RETURN_ERROR_ON_F16_UNSUPPORTED</a>(src);</div><div class="line">    <a class="code" href="_error_8h.xhtml#a206d6e247e0957ac3dee45d27756fc25">ARM_COMPUTE_RETURN_ERROR_ON</a>(src-&gt;data_type() == <a class="code" href="namespacearm__compute.xhtml#a735ac6c2a02e320969625308810444f3a696b031073e74bf2cb98e5ef201d4aa3">DataType::UNKNOWN</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(dst-&gt;tensor_shape().total_size() != 0)</div><div class="line">    {</div><div class="line">        <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#a8f3ff7da485ff7e75dab07baadf5b4bd">ARM_COMPUTE_RETURN_ERROR_ON_MISMATCHING_DATA_TYPES</a>(src, dst);</div><div class="line">        <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#aba910b683652be1f65437ef37a9da2a9">ARM_COMPUTE_RETURN_ERROR_ON_MISMATCHING_QUANTIZATION_INFO</a>(src, dst);</div><div class="line">        <a class="code" href="_error_8h.xhtml#a206d6e247e0957ac3dee45d27756fc25">ARM_COMPUTE_RETURN_ERROR_ON</a>(src-&gt;tensor_shape().total_size() != dst-&gt;tensor_shape().total_size());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> Status{};</div><div class="line">}</div><div class="line">} <span class="comment">// namespace</span></div><div class="line"></div><div class="line"><a class="code" href="classarm__compute_1_1opencl_1_1kernels_1_1_cl_reshape_kernel.xhtml#a258e23c398486bfc8026367f32659dd1">ClReshapeKernel::ClReshapeKernel</a>()</div><div class="line">{</div><div class="line">    _type = <a class="code" href="namespacearm__compute.xhtml#a6df16a1b3b5af590a14f55e983d3428ea92aed3228e2f4b29698517b9f0a3689e">CLKernelType::ELEMENTWISE</a>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classarm__compute_1_1opencl_1_1kernels_1_1_cl_reshape_kernel.xhtml#a91bac6753da05426ea42abb866cfe983">ClReshapeKernel::configure</a>(<span class="keyword">const</span> CLCompileContext &amp;compile_context, <span class="keyword">const</span> ITensorInfo *src, ITensorInfo *dst)</div><div class="line">{</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#a921b705e9e3e0fe928928447869e62a5">ARM_COMPUTE_ERROR_ON_NULLPTR</a>(src, dst);</div><div class="line">    <a class="code" href="_error_8h.xhtml#a938dcd406ce611ef5345ad2531cdb948">ARM_COMPUTE_ERROR_THROW_ON</a>(<a class="code" href="namespacearm__compute_1_1cpu_1_1kernels.xhtml#acf9ea6633274730cd08b8b8fab3a6fe6">validate_arguments</a>(src, dst));</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> padding_info = <a class="code" href="namespacearm__compute.xhtml#a7d96031a9664bcadc5d2804c2a0c8213">get_padding_info</a>({ <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a70879f7be69f6738d9f76339725c9532">src</a>, dst });</div><div class="line"></div><div class="line">    <span class="comment">// Create kernel</span></div><div class="line">    std::set&lt;std::string&gt; build_opts = { <span class="stringliteral">&quot;-DDATA_TYPE=&quot;</span> + <a class="code" href="namespacearm__compute.xhtml#a237044b76803b058edd1b23d599bcc6d">get_cl_unsigned_type_from_element_size</a>(src-&gt;element_size()) };</div><div class="line">    _kernel                          = <a class="code" href="namespacearm__compute.xhtml#adc51892eeef112d44a4f9bb0b988c9b9">create_kernel</a>(compile_context, <span class="stringliteral">&quot;reshape_layer&quot;</span>, build_opts);</div><div class="line"></div><div class="line">    <span class="comment">// Add static arguments</span></div><div class="line">    <span class="keyword">const</span> cl_int2 src_shape =</div><div class="line">    {</div><div class="line">        {</div><div class="line">            <span class="keyword">static_cast&lt;</span>cl_int<span class="keyword">&gt;</span>(src-&gt;tensor_shape()[0]),</div><div class="line">            static_cast&lt;cl_int&gt;(src-&gt;tensor_shape()[1])</div><div class="line">        }</div><div class="line">    };</div><div class="line">    <span class="keyword">const</span> cl_int2 <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#af22d91f65b56b795fd28f3b302cd3ad2">dst_shape</a> =</div><div class="line">    {</div><div class="line">        {</div><div class="line">            <span class="keyword">static_cast&lt;</span>cl_int<span class="keyword">&gt;</span>(dst-&gt;tensor_shape()[0]),</div><div class="line">            static_cast&lt;cl_int&gt;(dst-&gt;tensor_shape()[1])</div><div class="line">        }</div><div class="line">    };</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 2 * <a class="code" href="classarm__compute_1_1_i_c_l_kernel.xhtml#a6c9c1e7a7d96743375ca40847f0f12e2">num_arguments_per_3D_tensor</a>(); <span class="comment">// Skip the src and dst parameters</span></div><div class="line">    _kernel.setArg&lt;cl_int2&gt;(idx++, src_shape);</div><div class="line">    _kernel.setArg&lt;cl_int2&gt;(idx++, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#af22d91f65b56b795fd28f3b302cd3ad2">dst_shape</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Configure kernel window</span></div><div class="line">    Window win = <a class="code" href="namespacearm__compute.xhtml#aa84c2eae36ca4b68fa36c226df6f94e7">calculate_max_window</a>(*dst);</div><div class="line">    ICLKernel::configure_internal(win);</div><div class="line"></div><div class="line">    <a class="code" href="_error_8h.xhtml#a54a6080c9f4df1f908e57a9bbb46f5da">ARM_COMPUTE_ERROR_ON</a>(<a class="code" href="namespacearm__compute.xhtml#a7d5ebe14ba3526c8e2ed3c6949669f9c">has_padding_changed</a>(padding_info));</div><div class="line">}</div><div class="line"></div><div class="line">Status <a class="code" href="classarm__compute_1_1opencl_1_1kernels_1_1_cl_reshape_kernel.xhtml#a1f4089d0d7191158a65d297c6a130682">ClReshapeKernel::validate</a>(<span class="keyword">const</span> ITensorInfo *src, <span class="keyword">const</span> ITensorInfo *dst)</div><div class="line">{</div><div class="line">    <a class="code" href="_error_8h.xhtml#a8a1e1c105f0bdaf37db408c7cfcb77a4">ARM_COMPUTE_RETURN_ON_ERROR</a>(<a class="code" href="namespacearm__compute_1_1cpu_1_1kernels.xhtml#acf9ea6633274730cd08b8b8fab3a6fe6">validate_arguments</a>(src, dst));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> Status{};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classarm__compute_1_1opencl_1_1kernels_1_1_cl_reshape_kernel.xhtml#a2563bcc3dcf9406cbf572d206a99d801">ClReshapeKernel::run_op</a>(ITensorPack &amp;tensors, <span class="keyword">const</span> Window &amp;window, cl::CommandQueue &amp;queue)</div><div class="line">{</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#a1b35b0d258183cf9ef36adf684d0b88c">ARM_COMPUTE_ERROR_ON_UNCONFIGURED_KERNEL</a>(<span class="keyword">this</span>);</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#a6eb9ce82815fe429250189da7592ba75">ARM_COMPUTE_ERROR_ON_INVALID_SUBWINDOW</a>(<a class="code" href="classarm__compute_1_1_i_kernel.xhtml#ad34a46f53686c12a5c5e717cc9617fb6">IKernel::window</a>(), window);</div><div class="line"></div><div class="line">    Window window_collapsed = window.collapse_if_possible(<a class="code" href="classarm__compute_1_1_i_kernel.xhtml#ad34a46f53686c12a5c5e717cc9617fb6">ICLKernel::window</a>(), <a class="code" href="classarm__compute_1_1_window.xhtml#a893d17b56b9abc4423ce26e9a24ac5dc">Window::DimZ</a>);</div><div class="line">    Window <a class="code" href="namespacearm__compute_1_1test_1_1validation_1_1reference.xhtml#a548131b3d37da47a2e9d32111c88dfe1">slice</a>            = window_collapsed.first_slice_window_3D();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> src = utils::cast::polymorphic_downcast&lt;const ICLTensor *&gt;(tensors.get_const_tensor(<a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828ae1a1ae3e3415cb95b96aa11edbdbbb69">TensorType::ACL_SRC</a>));</div><div class="line">    <span class="keyword">auto</span>       dst = utils::cast::polymorphic_downcast&lt;ICLTensor *&gt;(tensors.get_tensor(<a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828a6f62ab7395c218e03e9d2942309c13a2">TensorType::ACL_DST</a>));</div><div class="line"></div><div class="line">    <span class="comment">// Set srcs</span></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0;</div><div class="line">    <a class="code" href="classarm__compute_1_1_i_c_l_kernel.xhtml#a28f5847162f352444c6ac1825d0e99c7">add_3D_tensor_argument</a>(idx, src, window_collapsed);</div><div class="line">    <a class="code" href="classarm__compute_1_1_i_c_l_kernel.xhtml#a28f5847162f352444c6ac1825d0e99c7">add_3D_tensor_argument</a>(idx, dst, window_collapsed);</div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#a6e51ab3789678d3e0b0b72178dd6c4c6">enqueue</a>(queue, *<span class="keyword">this</span>, slice, <a class="code" href="classarm__compute_1_1_i_c_l_kernel.xhtml#ab9f813c25ed75ea7b7ac2fa3926a8f55">lws_hint</a>());</div><div class="line">}</div><div class="line">} <span class="comment">// namespace kernels</span></div><div class="line">} <span class="comment">// namespace opencl</span></div><div class="line">} <span class="comment">// namespace arm_compute</span></div></div><!-- fragment --><p>The run will call the function defined in the .cl file.</p>
<p>For the Arm® Neon™ backend case: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacearm__compute.xhtml">arm_compute</a></div><div class="line">{</div><div class="line"><span class="keyword">namespace </span>cpu</div><div class="line">{</div><div class="line"><span class="keyword">namespace </span>kernels</div><div class="line">{</div><div class="line"><span class="keyword">namespace</span></div><div class="line">{</div><div class="line">Status <a class="code" href="namespacearm__compute_1_1cpu_1_1kernels.xhtml#acf9ea6633274730cd08b8b8fab3a6fe6">validate_arguments</a>(<span class="keyword">const</span> ITensorInfo *src, <span class="keyword">const</span> ITensorInfo *dst)</div><div class="line">{</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#aff911654521523937ff24372a870b89f">ARM_COMPUTE_RETURN_ERROR_ON_NULLPTR</a>(src, dst);</div><div class="line">    <span class="comment">// Note: ARM_COMPUTE_RETURN_ERROR_ON_CPU_F16_UNSUPPORTED(src) is not needed here as this kernel doesn&#39;t use CPU FP16 instructions.</span></div><div class="line">    <a class="code" href="_error_8h.xhtml#a206d6e247e0957ac3dee45d27756fc25">ARM_COMPUTE_RETURN_ERROR_ON</a>(src-&gt;data_type() == <a class="code" href="namespacearm__compute.xhtml#a735ac6c2a02e320969625308810444f3a696b031073e74bf2cb98e5ef201d4aa3">DataType::UNKNOWN</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(dst-&gt;tensor_shape().total_size() != 0)</div><div class="line">    {</div><div class="line">        <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#a8f3ff7da485ff7e75dab07baadf5b4bd">ARM_COMPUTE_RETURN_ERROR_ON_MISMATCHING_DATA_TYPES</a>(src, dst);</div><div class="line">        <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#aba910b683652be1f65437ef37a9da2a9">ARM_COMPUTE_RETURN_ERROR_ON_MISMATCHING_QUANTIZATION_INFO</a>(src, dst);</div><div class="line">        <a class="code" href="_error_8h.xhtml#a206d6e247e0957ac3dee45d27756fc25">ARM_COMPUTE_RETURN_ERROR_ON</a>(src-&gt;tensor_shape().total_size() != dst-&gt;tensor_shape().total_size());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> Status{};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> reshape_tensor(<span class="keyword">const</span> Window &amp;window, <span class="keyword">const</span> ITensor *src, ITensor *dst)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> TensorShape &amp;src_shape = src-&gt;info()-&gt;tensor_shape();</div><div class="line">    <span class="keyword">const</span> TensorShape &amp;dst_shape = dst-&gt;info()-&gt;tensor_shape();</div><div class="line">    Coordinates        dst_coord{};</div><div class="line"></div><div class="line">    Iterator src_it(src, window);</div><div class="line"></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#a5002bf7ec46d52971f9526e94172cfee">execute_window_loop</a>(window, [&amp;](<span class="keyword">const</span> Coordinates &amp; <span class="keywordtype">id</span>)</div><div class="line">    {</div><div class="line">        dst_coord                                              = <a class="code" href="namespacearm__compute.xhtml#ad34f2150f1c9f8a3ecb7298162124e5d">index2coords</a>(dst_shape, <a class="code" href="namespacearm__compute.xhtml#ad95e1c14c3007ca18950bf8f4c5a5c93">coords2index</a>(src_shape, <span class="keywordtype">id</span>));</div><div class="line">        *<span class="keyword">reinterpret_cast&lt;</span>T *<span class="keyword">&gt;</span>(dst-&gt;ptr_to_element(dst_coord)) = *reinterpret_cast&lt;T *&gt;(src_it.ptr());</div><div class="line">    },</div><div class="line">    src_it);</div><div class="line">}</div><div class="line">} <span class="comment">// namespace</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classarm__compute_1_1cpu_1_1kernels_1_1_cpu_reshape_kernel.xhtml#a7bd91d4a82cea79b87cd481e774614e1">CpuReshapeKernel::configure</a>(<span class="keyword">const</span> ITensorInfo *src, ITensorInfo *dst)</div><div class="line">{</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#a921b705e9e3e0fe928928447869e62a5">ARM_COMPUTE_ERROR_ON_NULLPTR</a>(src, dst);</div><div class="line">    <a class="code" href="_error_8h.xhtml#a938dcd406ce611ef5345ad2531cdb948">ARM_COMPUTE_ERROR_THROW_ON</a>(<a class="code" href="namespacearm__compute_1_1cpu_1_1kernels.xhtml#acf9ea6633274730cd08b8b8fab3a6fe6">validate_arguments</a>(src, dst));</div><div class="line">    <a class="code" href="_error_8h.xhtml#a6dc630a6ae9cc063b3924bcea8dee9d6">ARM_COMPUTE_UNUSED</a>(dst);</div><div class="line"></div><div class="line">    <span class="comment">// Configure kernel window</span></div><div class="line">    Window win = <a class="code" href="namespacearm__compute.xhtml#aa84c2eae36ca4b68fa36c226df6f94e7">calculate_max_window</a>(*src);</div><div class="line"></div><div class="line">    ICpuKernel::configure(win);</div><div class="line">}</div><div class="line"></div><div class="line">Status <a class="code" href="classarm__compute_1_1cpu_1_1kernels_1_1_cpu_reshape_kernel.xhtml#a1f4089d0d7191158a65d297c6a130682">CpuReshapeKernel::validate</a>(<span class="keyword">const</span> ITensorInfo *src, <span class="keyword">const</span> ITensorInfo *dst)</div><div class="line">{</div><div class="line">    <a class="code" href="_error_8h.xhtml#a8a1e1c105f0bdaf37db408c7cfcb77a4">ARM_COMPUTE_RETURN_ON_ERROR</a>(<a class="code" href="namespacearm__compute_1_1cpu_1_1kernels.xhtml#acf9ea6633274730cd08b8b8fab3a6fe6">validate_arguments</a>(src, dst));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> Status{};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classarm__compute_1_1cpu_1_1kernels_1_1_cpu_reshape_kernel.xhtml#a883429dd6cf828bfdd64b255afc458da">CpuReshapeKernel::run_op</a>(ITensorPack &amp;tensors, <span class="keyword">const</span> Window &amp;window, <span class="keyword">const</span> ThreadInfo &amp;<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#ac57b92957968088a392021cac1d2076b">info</a>)</div><div class="line">{</div><div class="line">    <a class="code" href="_error_8h.xhtml#a6dc630a6ae9cc063b3924bcea8dee9d6">ARM_COMPUTE_UNUSED</a>(info);</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#a1b35b0d258183cf9ef36adf684d0b88c">ARM_COMPUTE_ERROR_ON_UNCONFIGURED_KERNEL</a>(<span class="keyword">this</span>);</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#a6eb9ce82815fe429250189da7592ba75">ARM_COMPUTE_ERROR_ON_INVALID_SUBWINDOW</a>(<a class="code" href="classarm__compute_1_1_i_kernel.xhtml#ad34a46f53686c12a5c5e717cc9617fb6">ICpuKernel::window</a>(), window);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> src = tensors.get_const_tensor(<a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828ae1a1ae3e3415cb95b96aa11edbdbbb69">TensorType::ACL_SRC</a>);</div><div class="line">    <span class="keyword">auto</span>       dst = tensors.get_tensor(<a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828a6f62ab7395c218e03e9d2942309c13a2">TensorType::ACL_DST</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span>(src-&gt;info()-&gt;data_type())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">DataType::U8</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6aafb0fced528eaac5fe170b763cda5975">DataType::S8</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6af14462d71aa842202c3e4b272c7ec924">DataType::QASYMM8</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6a329f5d0c4b0c80e3474951d2c4435dd9">DataType::QASYMM8_SIGNED</a>:</div><div class="line">            reshape_tensor&lt;uint8_t&gt;(<a class="code" href="classarm__compute_1_1_i_kernel.xhtml#ad34a46f53686c12a5c5e717cc9617fb6">window</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a70879f7be69f6738d9f76339725c9532">src</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#adbf67dcee294e673cf796f1ed8aeb6a4">dst</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58aef9ef3ebca4d2b64b6ec83808bafa5f2">DataType::U16</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6e0b0886efb94aec797f6b830329b72c">DataType::S16</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a56d8353718e6fdc78b8d69078a2cdb94">DataType::F16</a>:</div><div class="line">            reshape_tensor&lt;uint16_t&gt;(<a class="code" href="classarm__compute_1_1_i_kernel.xhtml#ad34a46f53686c12a5c5e717cc9617fb6">window</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a70879f7be69f6738d9f76339725c9532">src</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#adbf67dcee294e673cf796f1ed8aeb6a4">dst</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58ac8bd5bedff8ef192d39a962afc0e19ee">DataType::U32</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58aa1e28eee0339658d39a8b4d325b56e9c">DataType::S32</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>:</div><div class="line">            reshape_tensor&lt;uint32_t&gt;(<a class="code" href="classarm__compute_1_1_i_kernel.xhtml#ad34a46f53686c12a5c5e717cc9617fb6">window</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a70879f7be69f6738d9f76339725c9532">src</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#adbf67dcee294e673cf796f1ed8aeb6a4">dst</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="_error_8h.xhtml#a7cf8d8b669b8f7b05680230be30d60f4">ARM_COMPUTE_ERROR</a>(<span class="stringliteral">&quot;Unsupported data type!&quot;</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classarm__compute_1_1cpu_1_1kernels_1_1_cpu_reshape_kernel.xhtml#aef1a10d4d6422ca58d53d8414d5954bd">CpuReshapeKernel::name</a>()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;CpuReshapeKernel&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="classarm__compute_1_1cpu_1_1kernels_1_1_cpu_reshape_kernel.xhtml#ae84c81edc1474e79618df29c6a621797">CpuReshapeKernel::get_mws</a>(<span class="keyword">const</span> <a class="code" href="classarm__compute_1_1_c_p_u_info.xhtml">CPUInfo</a> &amp;platform, <span class="keywordtype">size_t</span> thread_count)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <a class="code" href="_error_8h.xhtml#a6dc630a6ae9cc063b3924bcea8dee9d6">ARM_COMPUTE_UNUSED</a>(thread_count);</div><div class="line">    <a class="code" href="_error_8h.xhtml#a6dc630a6ae9cc063b3924bcea8dee9d6">ARM_COMPUTE_UNUSED</a>(platform);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classarm__compute_1_1_i_c_p_p_kernel.xhtml#ad6dda2ca87714e265e1521607c2fa7d0">ICPPKernel::default_mws</a>;</div><div class="line">}</div><div class="line"></div><div class="line">} <span class="comment">// namespace kernels</span></div><div class="line">} <span class="comment">// namespace cpu</span></div><div class="line">} <span class="comment">// namespace arm_compute</span></div></div><!-- fragment --><p> In the Arm® Neon™ case, there is no need to add an extra file and we implement the kernel in the same NEReshapeLayerKernel.cpp file. If the tests are already in place, the new kernel can be tested using the existing tests by adding the configure and run of the kernel to the compute_target() in the fixture.</p>
<h2><a class="anchor" id="S4_1_3_add_function"></a>
Add a function</h2>
<p>Memory management and scheduling the underlying kernel(s) must be handled by the function implementation. A kernel class must support window() API which return the execute window for the configuration that the kernel is configured for. A window specifies the dimensions of a workload. It has a start and end on each of the dimension. A maximum of <a class="el" href="classarm__compute_1_1_dimensions.xhtml#a1b67d5b720119d50faa286c774579ecc" title="Number of dimensions the tensor has. ">Coordinates::num_max_dimensions</a> is supported. The run time layer is expected to query the kernel for the window size and schedule the window as it sees fit. It could choose to split the window into sub windows so that it could be run in parallel. The split must adhere to the following rules</p>
<ul>
<li>max[n].start() &lt;= sub[n].start() &lt; max[n].<a class="el" href="namespacearm__compute_1_1mlgo_1_1parser.xhtml#a9fe67a1da3e2628bade473115ecbb5be">end()</a></li>
<li>sub[n].start() &lt; sub[n].<a class="el" href="namespacearm__compute_1_1mlgo_1_1parser.xhtml#a9fe67a1da3e2628bade473115ecbb5be">end()</a> &lt;= max[n].<a class="el" href="namespacearm__compute_1_1mlgo_1_1parser.xhtml#a9fe67a1da3e2628bade473115ecbb5be">end()</a></li>
<li>max[n].<a class="el" href="namespacearm__compute_1_1cpu.xhtml#a05c10bc9018179245c50d45b330a1c6a">step()</a> == sub[n].<a class="el" href="namespacearm__compute_1_1cpu.xhtml#a05c10bc9018179245c50d45b330a1c6a">step()</a></li>
<li>(sub[n].start() - max[n].start()) % max[n].<a class="el" href="namespacearm__compute_1_1cpu.xhtml#a05c10bc9018179245c50d45b330a1c6a">step()</a> == 0</li>
<li>(sub[n].<a class="el" href="namespacearm__compute_1_1mlgo_1_1parser.xhtml#a9fe67a1da3e2628bade473115ecbb5be">end()</a> - sub[n].start()) % max[n].<a class="el" href="namespacearm__compute_1_1cpu.xhtml#a05c10bc9018179245c50d45b330a1c6a">step()</a> == 0</li>
</ul>
<p><a class="el" href="classarm__compute_1_1_c_p_p_scheduler.xhtml#a8d6828523921b7f9313f64c48550617f">CPPScheduler::schedule</a> provides a sample implementation that is used for Arm® Neon™ kernels. Memory management is the other aspect that the runtime layer is supposed to handle. Memory management of the tensors is abstracted using <a class="el" href="classarm__compute_1_1_tensor_allocator.xhtml" title="Basic implementation of a CPU memory tensor allocator. ">TensorAllocator</a>. Each tensor holds a pointer to a <a class="el" href="classarm__compute_1_1_tensor_allocator.xhtml" title="Basic implementation of a CPU memory tensor allocator. ">TensorAllocator</a> object, which is used to allocate and free the memory at runtime. The implementation that is currently supported in Compute Library allows memory blocks, required to be fulfilled for a given operator, to be grouped together under a <a class="el" href="classarm__compute_1_1_memory_group.xhtml">MemoryGroup</a>. Each group can be acquired and released. The underlying implementation of memory groups vary depending on whether Arm® Neon™ or CL is used. The memory group class uses memory pool to provide the required memory. It also uses the memory manager to manage the lifetime and a <a class="el" href="classarm__compute_1_1_i_pool_manager.xhtml" title="Memory pool manager interface. ">IPoolManager</a> to manage the memory pools registered with the memory manager.</p>
<p>We have seen the various interfaces for a kernel in the core library, the same structure the same file structure design exists in the runtime module. <a class="el" href="classarm__compute_1_1_i_function.xhtml" title="Base class for all functions. ">IFunction</a> is the base class for all the functions, it has two child interfaces: <a class="el" href="classarm__compute_1_1_i_c_l_simple_function.xhtml" title="Basic interface for functions which have a single OpenCL kernel. ">ICLSimpleFunction</a> and <a class="el" href="classarm__compute_1_1_i_n_e_simple_function.xhtml" title="Basic interface for functions which have a single CPU kernel. ">INESimpleFunction</a> that are used as base class for functions which call a single kernel.</p>
<p>The new operator has to implement validate(), <a class="el" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5357bacf3b395353bef0acf15487b92b">configure()</a> and <a class="el" href="namespacearm__compute_1_1test_1_1validation.xhtml#a06403ad5596b5405787cfca12e5b815e">run()</a>, these methods will call the respective function in the kernel considering that the multi-threading is used for the kernels which are parallelizable, by default std::thread::hardware_concurrency() threads are used. For Arm® Neon™ function can be used <a class="el" href="classarm__compute_1_1_c_p_p_scheduler.xhtml#ae64eebaa07f4d2da6cc2ba538c3cb095" title="Sets the number of threads the scheduler will use to run the kernels. ">CPPScheduler::set_num_threads()</a> to manually set the number of threads, whereas for OpenCL kernels all the kernels are enqueued on the queue associated with <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml" title="Provides global access to a CL context and command queue. ">CLScheduler</a> and the queue is then flushed. For the runtime functions, there is an extra method implemented: prepare(), this method prepares the function for the run, it does all the heavy operations that are done only once (reshape the weight, release the memory not necessary after the reshape, etc). The prepare method can be called standalone or in the first run, if not called before, after then the function will be marked as prepared. The files we add are:</p>
<p>OpenCL function</p><ul>
<li><a class="el" href="_c_l_reshape_layer_8h.xhtml">arm_compute/runtime/CL/functions/CLReshapeLayer.h</a></li>
<li><a class="el" href="_c_l_reshape_layer_8cpp.xhtml">src/runtime/CL/functions/CLReshapeLayer.cpp</a></li>
</ul>
<p>Neon™ function</p><ul>
<li><a class="el" href="_n_e_reshape_layer_8h.xhtml">arm_compute/runtime/NEON/functions/NEReshapeLayer.h</a></li>
<li><a class="el" href="_n_e_reshape_layer_8cpp.xhtml">src/runtime/NEON/functions/NEReshapeLayer.cpp</a></li>
</ul>
<p>As we did in the kernel we have to edit the runtime libraries to register the new operator modifying the relative library file:</p><ul>
<li><a class="el" href="_c_l_functions_8h.xhtml" title="Includes all the OpenCL functions at once. ">arm_compute/runtime/CL/CLFunctions.h</a></li>
<li><a class="el" href="_n_e_functions_8h.xhtml" title="Includes all the Arm® Neon™ functions at once. ">arm_compute/runtime/NEON/NEFunctions.h</a></li>
</ul>
<p>For the special case where the new function calls only one kernel, we could use as base class <a class="el" href="classarm__compute_1_1_i_c_l_simple_function.xhtml" title="Basic interface for functions which have a single OpenCL kernel. ">ICLSimpleFunction</a> or <a class="el" href="classarm__compute_1_1_i_n_e_simple_function.xhtml" title="Basic interface for functions which have a single CPU kernel. ">INESimpleFunction</a>. The configure and the validate methods will simply call the corresponding functions. The structure will be: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacearm__compute.xhtml">arm_compute</a></div><div class="line">{</div><div class="line"><span class="keyword">struct </span>CLReshapeLayer::Impl</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> ICLTensor                   *src{ <span class="keyword">nullptr</span> };</div><div class="line">    ICLTensor                         *dst{ <span class="keyword">nullptr</span> };</div><div class="line">    std::unique_ptr&lt;opencl::ClReshape&gt; op{ <span class="keyword">nullptr</span> };</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classarm__compute_1_1_c_l_reshape_layer.xhtml#ac7d776a643c4f66e97415de1c00669f0">CLReshapeLayer::CLReshapeLayer</a>()</div><div class="line">    : _impl(<a class="code" href="namespacestd.xhtml">std</a>::make_unique&lt;Impl&gt;())</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classarm__compute_1_1_c_l_reshape_layer.xhtml#ac7d776a643c4f66e97415de1c00669f0">CLReshapeLayer::CLReshapeLayer</a>(CLReshapeLayer &amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">CLReshapeLayer &amp;<a class="code" href="classarm__compute_1_1_c_l_reshape_layer.xhtml#a2cc8cc649ebd26ef0e89b97e68a30725">CLReshapeLayer::operator=</a>(CLReshapeLayer &amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"><a class="code" href="classarm__compute_1_1_c_l_reshape_layer.xhtml#ae91b1281ab0d4ca0b52ba82209efec92">CLReshapeLayer::~CLReshapeLayer</a>()                            = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classarm__compute_1_1_c_l_reshape_layer.xhtml#a074e10cfb217e657b9e81adeca2abc68">CLReshapeLayer::configure</a>(<span class="keyword">const</span> ICLTensor *<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a8fcf2ddd9a1d58b1b280f5c0aed71845">input</a>, ICLTensor *output)</div><div class="line">{</div><div class="line">    <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5357bacf3b395353bef0acf15487b92b">configure</a>(<a class="code" href="classarm__compute_1_1_c_l_kernel_library.xhtml#acba005f5ce2c62cbf3f94d074d9007aa">CLKernelLibrary::get</a>().get_compile_context(), input, output);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classarm__compute_1_1_c_l_reshape_layer.xhtml#a074e10cfb217e657b9e81adeca2abc68">CLReshapeLayer::configure</a>(<span class="keyword">const</span> CLCompileContext &amp;compile_context, <span class="keyword">const</span> ICLTensor *input, ICLTensor *output)</div><div class="line">{</div><div class="line">    _impl-&gt;src = <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a8fcf2ddd9a1d58b1b280f5c0aed71845">input</a>;</div><div class="line">    _impl-&gt;dst = output;</div><div class="line">    _impl-&gt;op  = std::make_unique&lt;opencl::ClReshape&gt;();</div><div class="line">    _impl-&gt;op-&gt;configure(compile_context, input-&gt;info(), output-&gt;info());</div><div class="line">}</div><div class="line"></div><div class="line">Status <a class="code" href="classarm__compute_1_1_c_l_reshape_layer.xhtml#a968b23a6ef327fcfb5b99d58e3fbe883">CLReshapeLayer::validate</a>(<span class="keyword">const</span> ITensorInfo *input, <span class="keyword">const</span> ITensorInfo *output)</div><div class="line">{</div><div class="line">    <a class="code" href="arm__compute_2core_2_validate_8h.xhtml#aff911654521523937ff24372a870b89f">ARM_COMPUTE_RETURN_ERROR_ON_NULLPTR</a>(input, output);</div><div class="line">    <a class="code" href="_error_8h.xhtml#a8a1e1c105f0bdaf37db408c7cfcb77a4">ARM_COMPUTE_RETURN_ON_ERROR</a>(<a class="code" href="classarm__compute_1_1opencl_1_1_cl_reshape.xhtml#a968b23a6ef327fcfb5b99d58e3fbe883">opencl::ClReshape::validate</a>(input, output));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> Status{};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classarm__compute_1_1_c_l_reshape_layer.xhtml#ad1717410afd0be936c6213a63c8005fb">CLReshapeLayer::run</a>()</div><div class="line">{</div><div class="line">    ITensorPack <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a1e041dc03ff256dfc8b0bf5c5fe099e0">pack</a>;</div><div class="line">    pack.<a class="code" href="classarm__compute_1_1_i_tensor_pack.xhtml#a6d8078b635739e84400cf8240a2993e7">add_tensor</a>(<a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828ae1a1ae3e3415cb95b96aa11edbdbbb69">TensorType::ACL_SRC</a>, _impl-&gt;src);</div><div class="line">    pack.add_tensor(<a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828a6f62ab7395c218e03e9d2942309c13a2">TensorType::ACL_DST</a>, _impl-&gt;dst);</div><div class="line">    _impl-&gt;op-&gt;run(pack);</div><div class="line">}</div><div class="line">} <span class="comment">// namespace arm_compute</span></div></div><!-- fragment --><p>If the function is more complicated and calls more than one kernel we have to use the memory manager to manage the intermediate tensors; in the <a class="el" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5357bacf3b395353bef0acf15487b92b">configure()</a> method we call the manage() function passing the tensor to keep track, in the run method we will have to acquire all the buffer managed and released at the end. For OpenCL if we want to add two tensor input and reshape the result:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacearm__compute.xhtml">arm_compute</a>;</div><div class="line"></div><div class="line">CLAddReshapeLayer:: CLAddReshapeLayer(std::shared_ptr&lt;IMemoryManager&gt; memory_manager)</div><div class="line">    : _memory_group(<a class="code" href="namespacestd.xhtml">std</a>::move(memory_manager))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5357bacf3b395353bef0acf15487b92b">CLAddReshapeLayer::configure</a>(<span class="keyword">const</span> <a class="code" href="classarm__compute_1_1_i_c_l_tensor.xhtml">ICLTensor</a> *input1, <span class="keyword">const</span> <a class="code" href="classarm__compute_1_1_i_c_l_tensor.xhtml">ICLTensor</a> *input2, <a class="code" href="classarm__compute_1_1_i_c_l_tensor.xhtml">ICLTensor</a> *output)</div><div class="line">{</div><div class="line">    <span class="comment">// Allocate memory</span></div><div class="line">    <a class="code" href="classarm__compute_1_1_tensor_info.xhtml">TensorInfo</a> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#ac57b92957968088a392021cac1d2076b">info</a>();</div><div class="line">    add_output.allocator()-&gt;init(info);</div><div class="line"></div><div class="line">    <span class="comment">// Manage intermediate buffers</span></div><div class="line">    memory_group.manage(&amp;_addOutput);</div><div class="line"></div><div class="line">    <span class="comment">// Initialise kernel</span></div><div class="line">    _add_kernel.configure(input1, input2, &amp;add_output);</div><div class="line">    _reshape_kernel.configure(&amp;add_output, output);</div><div class="line"></div><div class="line">    <span class="comment">// Allocate intermediate tensors</span></div><div class="line">    add_output.allocator()-&gt;allocate();</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classarm__compute_1_1_status.xhtml">Status</a> <a class="code" href="namespacearm__compute.xhtml#a4feaaa70771629f4b5dcf3b219c8b647">CLAddReshapeLayer::validate</a>(<span class="keyword">const</span> <a class="code" href="classarm__compute_1_1_i_tensor_info.xhtml">ITensorInfo</a> *input1, <span class="keyword">const</span> <a class="code" href="classarm__compute_1_1_i_tensor_info.xhtml">ITensorInfo</a> *input2, <span class="keyword">const</span> <a class="code" href="classarm__compute_1_1_i_tensor_info.xhtml">ITensorInfo</a> *output)</div><div class="line">{</div><div class="line">    <a class="code" href="classarm__compute_1_1_tensor_info.xhtml">TensorInfo</a> add_output();</div><div class="line">    <a class="code" href="_error_8h.xhtml#a206d6e247e0957ac3dee45d27756fc25">ARM_COMPUTE_RETURN_ERROR_ON</a>(<a class="code" href="namespacearm__compute.xhtml#a4feaaa70771629f4b5dcf3b219c8b647">CLAddLayerKernel::validate</a>(input1, input2, add_output));</div><div class="line">    <a class="code" href="_error_8h.xhtml#a206d6e247e0957ac3dee45d27756fc25">ARM_COMPUTE_RETURN_ERROR_ON</a>(<a class="code" href="namespacearm__compute.xhtml#a4feaaa70771629f4b5dcf3b219c8b647">CLReshapeLayerKernel::validate</a>(add_output, output));</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classarm__compute_1_1_status.xhtml">Status</a>{};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a06403ad5596b5405787cfca12e5b815e">CLAddReshapeLayer::run</a>()</div><div class="line">{</div><div class="line">    memory_group.acquire();</div><div class="line"></div><div class="line">    <span class="comment">// Run Add</span></div><div class="line">    add_kernel.run();</div><div class="line"></div><div class="line">    <span class="comment">// Run Reshape</span></div><div class="line">    <a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a9b58d0eb9a2af8e6d7908695e1557d6c">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#ae1a643e517f50bf0392fb6516dd7cf67">enqueue</a>(reshape_kernel);</div><div class="line"></div><div class="line">    memory_group.release();</div><div class="line">}</div></div><!-- fragment --><p>For Neon™:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacearm__compute.xhtml">arm_compute</a>;</div><div class="line"></div><div class="line">NEAddReshapeLayer:: NEAddReshapeLayer (std::shared_ptr&lt;IMemoryManager&gt; memory_manager)</div><div class="line">    : _memory_group(<a class="code" href="namespacestd.xhtml">std</a>::move(memory_manager))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5357bacf3b395353bef0acf15487b92b">NEAddReshapeLayer::configure</a>(<span class="keyword">const</span> <a class="code" href="classarm__compute_1_1_i_tensor.xhtml">ITensor</a> *input1, <span class="keyword">const</span> <a class="code" href="classarm__compute_1_1_i_tensor.xhtml">ITensor</a> *input2, <a class="code" href="classarm__compute_1_1_i_tensor.xhtml">ITensor</a> *output)</div><div class="line">{</div><div class="line">    <span class="comment">// Allocate memory</span></div><div class="line">    <a class="code" href="classarm__compute_1_1_tensor_info.xhtml">TensorInfo</a> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#ac57b92957968088a392021cac1d2076b">info</a>();</div><div class="line">    add_output.allocator()-&gt;init(info);</div><div class="line"></div><div class="line">    <span class="comment">// Manage intermediate buffers</span></div><div class="line">    memory_group.manage(&amp;_addOutput);</div><div class="line"></div><div class="line">    <span class="comment">// Initialise kernel</span></div><div class="line">    add_kernel.configure(input1, input2, &amp;addOutput);</div><div class="line">    reshape_kernel.configure(&amp;addOutput, output);</div><div class="line"></div><div class="line">    <span class="comment">// Allocate intermediate tensors</span></div><div class="line">    add_output.allocator()-&gt;allocate();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a06403ad5596b5405787cfca12e5b815e">NEAddReshapeLayer::run</a>()</div><div class="line">{</div><div class="line">    memory_group.acquire();</div><div class="line"></div><div class="line">    <span class="comment">// Run Add</span></div><div class="line">    add_kernel.run();</div><div class="line"></div><div class="line">    <span class="comment">// Run Reshape</span></div><div class="line">    <a class="code" href="classarm__compute_1_1_scheduler.xhtml#a0d63ca713bab377aabcfb63c192b8429">NEScheduler::get</a>().<a class="code" href="classarm__compute_1_1_i_scheduler.xhtml#a4e58f95544bd5ac6559a421671bd9842">schedule</a>(_reshape_kernel.get(), <a class="code" href="classarm__compute_1_1_window.xhtml#ad2d402364fa822b0b7775081291eeca9">Window::DimY</a>);</div><div class="line"></div><div class="line">    memory_group.release();</div><div class="line">}</div></div><!-- fragment --><p>At this point, everything is in place at the library level. If you are following an tests driven implementation and all the tests are already in place, we can call the function configuration in the fixture and remove any redundant code like the allocation of the intermediate tensors since it's done in the function. Run the final tests to check the results match with the expected results from the reference implementation.</p>
<h2><a class="anchor" id="S4_1_4_add_validation"></a>
Add validation artifacts</h2>
<h3><a class="anchor" id="S4_1_4_1_add_reference"></a>
Add the reference implementation and the tests</h3>
<p>As mentioned in the introduction, the reference implementation is a pure C++ implementation without any optimization or backend specific instruction. The reference implementation consist of two files into the folder tests/validation/reference:</p><ul>
<li><a class="el" href="_reshape_layer_8h.xhtml">tests/validation/reference/ReshapeLayer.h</a></li>
<li><a class="el" href="tests_2validation_2reference_2_reshape_layer_8cpp.xhtml">tests/validation/reference/ReshapeLayer.cpp</a></li>
</ul>
<p>where we will put respectively the declaration and definition of the new operator. All the utility functions that are used ONLY in the tests are in test/validation/helpers.h, for all the others, as mentioned before, there are helpers in the library. Compute Library and the tests do use templates, the reference implementation is a generic implementation independent from the datatype and we use the templates to generalize the datatype concept. Following the example, let's have a look at the ReshapeLayer operator:</p>
<ul>
<li><a class="el" href="_reshape_layer_8h.xhtml">tests/validation/reference/ReshapeLayer.h</a></li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">SimpleTensor&lt;T&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;T&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#aaae4098f0f54b97f23d99be335c459ad">output_shape</a>);</div></div><!-- fragment --><ul>
<li><a class="el" href="tests_2validation_2reference_2_reshape_layer_8cpp.xhtml">tests/validation/reference/ReshapeLayer.cpp</a></li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">SimpleTensor&lt;T&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;T&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#aaae4098f0f54b97f23d99be335c459ad">output_shape</a>)</div><div class="line">{</div><div class="line">    <a class="code" href="_error_8h.xhtml#a54a6080c9f4df1f908e57a9bbb46f5da">ARM_COMPUTE_ERROR_ON</a>(src.shape().total_size() != output_shape.total_size());</div><div class="line"></div><div class="line">    SimpleTensor&lt;T&gt; <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#adbf67dcee294e673cf796f1ed8aeb6a4">dst</a>(output_shape, src.data_type());</div><div class="line">    std::copy_n(src.data(), src.num_elements(), dst.data());</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#adbf67dcee294e673cf796f1ed8aeb6a4">dst</a>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> SimpleTensor&lt;uint8_t&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;uint8_t&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;output_shape);</div><div class="line"><span class="keyword">template</span> SimpleTensor&lt;int8_t&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;int8_t&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;output_shape);</div><div class="line"><span class="keyword">template</span> SimpleTensor&lt;uint16_t&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;uint16_t&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;output_shape);</div><div class="line"><span class="keyword">template</span> SimpleTensor&lt;int16_t&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;int16_t&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;output_shape);</div><div class="line"><span class="keyword">template</span> SimpleTensor&lt;uint32_t&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;uint32_t&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;output_shape);</div><div class="line"><span class="keyword">template</span> SimpleTensor&lt;int32_t&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;int32_t&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;output_shape);</div><div class="line"><span class="keyword">template</span> SimpleTensor&lt;half&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;half&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;output_shape);</div><div class="line"><span class="keyword">template</span> SimpleTensor&lt;float&gt; <a class="code" href="reshape__layer_8cl.xhtml#acdcb27be2437616997a28a2d8ba45315">reshape_layer</a>(<span class="keyword">const</span> SimpleTensor&lt;float&gt; &amp;src, <span class="keyword">const</span> TensorShape &amp;output_shape);</div></div><!-- fragment --><p> An explicit instantiation of the template for the required datatypes must be added in the .cpp file.</p>
<h3><a class="anchor" id="S4_1_4_2_add_dataset"></a>
Add dataset</h3>
<p>One of the parameters of the tests is the dataset, it will be used to generate versions of the test case with different inputs. To pass the dataset at the fixture data test case we have three cases</p><ul>
<li>the operator dataset is simple so it can be added directly in the test case data declaration</li>
<li>we can create a class that return tuples at the test framework</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>PoolingTypes final : <span class="keyword">public</span> framework::dataset::ContainerDataset&lt;std::vector&lt;PoolingType&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PoolingTypes()</div><div class="line">        : ContainerDataset(<span class="stringliteral">&quot;PoolType&quot;</span>,</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacearm__compute.xhtml#a9172da722f0a434e5cc07c0a3c115d93a26a4b44a837bf97b972628509912b4a5">PoolingType::MAX</a>, <a class="code" href="namespacearm__compute.xhtml#a9172da722f0a434e5cc07c0a3c115d93afcefd647d6a866603c627b11347c707a">PoolingType::AVG</a>, <a class="code" href="namespacearm__compute.xhtml#a9172da722f0a434e5cc07c0a3c115d93a7e6aa2d53f6ee2b1a34b017fa403cb76">PoolingType::L2</a></div><div class="line">    })</div><div class="line">    {</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><ul>
<li>if we want to create dynamically the dataset combining different parameter, we can create the dataset using iterators. For example, dataset for ReshapeLayer:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>ReshapeLayerDataset</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> <a class="code" href="gemm__interleaved_8hpp.xhtml#a6fbca3dca9ecb372332fc525529cc086">type</a> = std::tuple&lt;TensorShape, TensorShape&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>iterator</div><div class="line">    {</div><div class="line">        iterator(std::vector&lt;TensorShape&gt;::const_iterator in_it, std::vector&lt;TensorShape&gt;::const_iterator out_it)</div><div class="line">            : _in_it{ std::move(in_it) }, _out_it{ std::move(out_it) }</div><div class="line">        {</div><div class="line">        }</div><div class="line"></div><div class="line">        std::string description()<span class="keyword"> const</span></div><div class="line"><span class="keyword">        </span>{</div><div class="line">            std::stringstream description;</div><div class="line">            description &lt;&lt; <span class="stringliteral">&quot;In=&quot;</span> &lt;&lt; *_in_it &lt;&lt; <span class="stringliteral">&quot;:&quot;</span>;</div><div class="line">            description &lt;&lt; <span class="stringliteral">&quot;Out=&quot;</span> &lt;&lt; *_out_it;</div><div class="line">            <span class="keywordflow">return</span> description.str();</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="gemm__interleaved_8hpp.xhtml#a6fbca3dca9ecb372332fc525529cc086">ReshapeLayerDataset::type</a> <a class="code" href="namespacearm__compute_1_1test_1_1framework_1_1dataset.xhtml#ac0d0ba443ee1c293361eea3c06c98847">operator*</a>()<span class="keyword"> const</span></div><div class="line"><span class="keyword">        </span>{</div><div class="line">            <span class="keywordflow">return</span> std::make_tuple(*_in_it, *_out_it);</div><div class="line">        }</div><div class="line"></div><div class="line">        iterator &amp;operator++()</div><div class="line">        {</div><div class="line">            ++_in_it;</div><div class="line">            ++_out_it;</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        std::vector&lt;TensorShape&gt;::const_iterator _in_it;</div><div class="line">        std::vector&lt;TensorShape&gt;::const_iterator _out_it;</div><div class="line">    };</div><div class="line"></div><div class="line">    iterator begin()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> iterator(_in_shapes.begin(), _out_shapes.begin());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> std::min(_in_shapes.size(), _out_shapes.size());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> add_config(TensorShape in, TensorShape out)</div><div class="line">    {</div><div class="line">        _in_shapes.emplace_back(std::move(in));</div><div class="line">        _out_shapes.emplace_back(std::move(out));</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    ReshapeLayerDataset()                       = <span class="keywordflow">default</span>;</div><div class="line">    ReshapeLayerDataset(ReshapeLayerDataset &amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::vector&lt;TensorShape&gt; _in_shapes{};</div><div class="line">    std::vector&lt;TensorShape&gt; _out_shapes{};</div><div class="line">};</div></div><!-- fragment --> <h3><a class="anchor" id="S4_1_4_3_add_fixture"></a>
Add a fixture and a data test case</h3>
<p>Benchmark and validation tests are based on the same framework to setup and run the tests. In addition to running simple, self-contained test functions the framework supports fixtures and data test cases. Fixtures can be used to share common setup, teardown or even run tasks among multiple test cases, for that purpose a fixture can define a "setup", "teardown" and "run" method. Adding tests for the new operator in the runtime library we need to implement at least the setup method, that is used to call two methods for configure, run and return the output respectively of the target (CL or Neon™) and the reference (C++ implementation).</p>
<p>For example let's have a look at Reshape Layer Fixture :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TensorType, <span class="keyword">typename</span> AccessorType, <span class="keyword">typename</span> FunctionType, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class </span>ReshapeLayerValidationFixture : <span class="keyword">public</span> framework::Fixture</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt;</div><div class="line">    <span class="keywordtype">void</span> setup(TensorShape <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#af78b3c8c9ad65dcb4bfa1d2fee424308">input_shape</a>, TensorShape output_shape, <a class="code" href="namespacearm__compute.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5f5b6c4337eac9e2e0046ca2304d80dc">data_type</a>)</div><div class="line">    {</div><div class="line">        _target    = compute_target(input_shape, output_shape, data_type);</div><div class="line">        _reference = compute_reference(input_shape, output_shape, data_type);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a1643f4cb252152ed8ffc0df84744ad5d">fill</a>(<a class="code" href="namespacearm__compute.xhtml#a1ce9b523fd4f3b5bbcadcd796183455aa4c614360da93c0a041b22e537de151eb">U</a> &amp;&amp;tensor, <span class="keywordtype">int</span> i)</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacearm__compute_1_1test.xhtml#a71326f0909d77386e29b511e1990a11f">library</a>-&gt;fill_tensor_uniform(tensor, i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828">TensorType</a> compute_target(<span class="keyword">const</span> TensorShape &amp;<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#af78b3c8c9ad65dcb4bfa1d2fee424308">input_shape</a>, <span class="keyword">const</span> TensorShape &amp;output_shape, <a class="code" href="namespacearm__compute.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5f5b6c4337eac9e2e0046ca2304d80dc">data_type</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">// Check if indeed the input shape can be reshape to the output one</span></div><div class="line">        <a class="code" href="src_2common_2utils_2_validate_8h.xhtml#a6d40659f94b26d9ac5ae03538252dcd4">ARM_COMPUTE_ASSERT</a>(input_shape.total_size() == output_shape.total_size());</div><div class="line"></div><div class="line">        <span class="comment">// Create tensors</span></div><div class="line">        <a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828">TensorType</a> src = create_tensor&lt;TensorType&gt;(<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#af78b3c8c9ad65dcb4bfa1d2fee424308">input_shape</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5f5b6c4337eac9e2e0046ca2304d80dc">data_type</a>);</div><div class="line">        <a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828">TensorType</a> dst = create_tensor&lt;TensorType&gt;(<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#aaae4098f0f54b97f23d99be335c459ad">output_shape</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a5f5b6c4337eac9e2e0046ca2304d80dc">data_type</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Create and configure function</span></div><div class="line">        FunctionType reshape;</div><div class="line"></div><div class="line">        reshape.configure(&amp;src, &amp;dst);</div><div class="line"></div><div class="line">        <a class="code" href="src_2common_2utils_2_validate_8h.xhtml#a6d40659f94b26d9ac5ae03538252dcd4">ARM_COMPUTE_ASSERT</a>(src.info()-&gt;is_resizable());</div><div class="line">        <a class="code" href="src_2common_2utils_2_validate_8h.xhtml#a6d40659f94b26d9ac5ae03538252dcd4">ARM_COMPUTE_ASSERT</a>(dst.info()-&gt;is_resizable());</div><div class="line"></div><div class="line">        <span class="comment">// Allocate tensors</span></div><div class="line">        src.allocator()-&gt;allocate();</div><div class="line">        dst.allocator()-&gt;allocate();</div><div class="line"></div><div class="line">        <a class="code" href="src_2common_2utils_2_validate_8h.xhtml#a6d40659f94b26d9ac5ae03538252dcd4">ARM_COMPUTE_ASSERT</a>(!src.info()-&gt;is_resizable());</div><div class="line">        <a class="code" href="src_2common_2utils_2_validate_8h.xhtml#a6d40659f94b26d9ac5ae03538252dcd4">ARM_COMPUTE_ASSERT</a>(!dst.info()-&gt;is_resizable());</div><div class="line"></div><div class="line">        <span class="comment">// Fill tensors</span></div><div class="line">        <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a1643f4cb252152ed8ffc0df84744ad5d">fill</a>(AccessorType(src), 0);</div><div class="line"></div><div class="line">        <span class="comment">// Compute function</span></div><div class="line">        reshape.run();</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#adbf67dcee294e673cf796f1ed8aeb6a4">dst</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    SimpleTensor&lt;T&gt; compute_reference(<span class="keyword">const</span> TensorShape &amp;input_shape, <span class="keyword">const</span> TensorShape &amp;output_shape, <a class="code" href="namespacearm__compute.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> data_type)</div><div class="line">    {</div><div class="line">        <span class="comment">// Create reference</span></div><div class="line">        SimpleTensor&lt;T&gt; src{ <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#af78b3c8c9ad65dcb4bfa1d2fee424308">input_shape</a>, data_type };</div><div class="line"></div><div class="line">        <span class="comment">// Fill reference</span></div><div class="line">        <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a1643f4cb252152ed8ffc0df84744ad5d">fill</a>(src, 0);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> reference::reshape_layer&lt;T&gt;(<a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#a70879f7be69f6738d9f76339725c9532">src</a>, <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#aaae4098f0f54b97f23d99be335c459ad">output_shape</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#a08e287b5f0197ce8c7c84dde6db24828">TensorType</a>      _target{};</div><div class="line">    SimpleTensor&lt;T&gt; _reference{};</div><div class="line">};</div></div><!-- fragment --><p> In the fixture class above we can see that the setup method computes the target and reference and store them in the two members _target and _reference which will be used later to check for correctness. The compute_target method reflects the exact behavior expected when we call a function. The input and output tensor must be declared, function configured, tensors allocated, the input tensor filled with required data, and finally, the function must be run and the results returned. This fixture is used in the test case, that is a parameterized test case that inherits from a fixture. The test case will have access to all public and protected members of the fixture. Only the setup and teardown methods of the fixture will be used. The setup method of the fixture needs to be a template and must accept inputs from the dataset as arguments. The body of this function will be used as a test function. For the fixture test case the first argument is the name of the test case (has to be unique within the enclosing test suite), the second argument is the class name of the fixture, the third argument is the dataset mode in which the test will be active (PRECOMMIT or NIGHTLY) and the fourth argument is the dataset. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> <a class="code" href="namespacearm__compute_1_1test_1_1validation.xhtml#ad5b12b22c816f5f7724d386528bd3292">CLActivationLayerFixture</a> = ActivationValidationFixture&lt;CLTensor, CLAccessor, CLActivationLayer, T&gt;;</div></div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#acd09bed517e43d28823e69494f259835">TEST_SUITE</a>(CL)</div><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#acd09bed517e43d28823e69494f259835">TEST_SUITE</a>(ActivationLayer)</div><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#acd09bed517e43d28823e69494f259835">TEST_SUITE</a>(Float)</div><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#acd09bed517e43d28823e69494f259835">TEST_SUITE</a>(FP16)</div></div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#a42699a26fbdddf91da4aa58a610bb8a8">FIXTURE_DATA_TEST_CASE</a>(RunSmall, CLActivationLayerFixture&lt;half&gt;, framework::DatasetMode::ALL, <a class="code" href="namespacearm__compute_1_1test_1_1framework_1_1dataset.xhtml#a6f4fa4bb0583f29e77138fb1e7d77411">combine</a>(<a class="code" href="namespacearm__compute_1_1test_1_1framework_1_1dataset.xhtml#a6f4fa4bb0583f29e77138fb1e7d77411">combine</a>(datasets::SmallShapes(), ActivationDataset),</div><div class="line">                                                                                                      <a class="code" href="namespacearm__compute_1_1test_1_1framework_1_1dataset.xhtml#a352791fb808d42a82ad70df5efa3508b">framework::dataset::make</a>(<span class="stringliteral">&quot;DataType&quot;</span>,</div><div class="line">                                                                                                              <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a56d8353718e6fdc78b8d69078a2cdb94">DataType::F16</a>)))</div><div class="line">{</div><div class="line">    <span class="comment">// Validate output</span></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#a4feaaa70771629f4b5dcf3b219c8b647">validate</a>(CLAccessor(_target), _reference, tolerance(_function, _data_type));</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#a603cb7f45efd81606e51686da9aeebd9">TEST_SUITE_END</a>()</div><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#a603cb7f45efd81606e51686da9aeebd9">TEST_SUITE_END</a>()</div><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#a603cb7f45efd81606e51686da9aeebd9">TEST_SUITE_END</a>()</div><div class="line"><a class="code" href="tests_2framework_2_macros_8h.xhtml#a603cb7f45efd81606e51686da9aeebd9">TEST_SUITE_END</a>()</div></div><!-- fragment --><p>This will produce a set of tests that can be filtered with "CL/ReshapeLayer/Float/FP16/RunSmall". Each test produced from the cartesian product of the dataset is associated to a number and can be filtered specifying all the parameters. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu May 18 2023 14:52:35 for Compute Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
