<!-- HTML header for doxygen 1.8.15-->
<!-- Remember to use version doxygen 1.8.15 +-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="robots" content="NOINDEX, NOFOLLOW" /> <!-- Prevent indexing by search engines -->
<title>Compute Library: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <img alt="Compute Library" src="https://raw.githubusercontent.com/ARM-software/ComputeLibrary/gh-pages/ACL_logo.png" style="max-width: 100%;margin-top: 15px;margin-left: 10px"/>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">20.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.xhtml','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#S0_1_contact">Contact / Support</a></li>
<li class="level1"><a href="#S0_2_prebuilt_binaries">Pre-built binaries</a></li>
<li class="level1"><a href="#S1_file_organisation">File organisation</a></li>
<li class="level1"><a href="#S2_versions_changelog">Release versions and changelog</a><ul><li class="level2"><a href="#S2_1_versions">Release versions</a></li>
<li class="level2"><a href="#S2_2_changelog">Changelog</a></li>
</ul>
</li>
<li class="level1"><a href="#S3_how_to_build">How to build the library and the examples</a><ul><li class="level2"><a href="#S3_1_build_options">Build options</a></li>
<li class="level2"><a href="#S3_2_linux">Building for Linux</a><ul><li class="level3"><a href="#S3_2_1_library">How to build the library ?</a></li>
<li class="level3"><a href="#S3_2_2_examples">How to manually build the examples ?</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_3_android">Building for Android</a><ul><li class="level3"><a href="#S3_3_1_library">How to build the library ?</a></li>
<li class="level3"><a href="#S3_3_2_examples">How to manually build the examples ?</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_4_bare_metal">Building for bare metal</a><ul><li class="level3"><a href="#S3_4_1_library">How to build the library ?</a></li>
<li class="level3"><a href="#S3_4_2_examples">How to manually build the examples ?</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_5_windows_host">Building on a Windows host system</a><ul><li class="level3"><a href="#S3_5_1_ubuntu_on_windows">Bash on Ubuntu on Windows</a></li>
<li class="level3"><a href="#S3_5_2_cygwin">Cygwin</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_6_cl_requirements">OpenCL DDK Requirements</a><ul><li class="level3"><a href="#S3_6_1_cl_hard_requirements">Hard Requirements</a></li>
<li class="level3"><a href="#S3_6_2_cl_performance_requirements">Performance improvements</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_7_cl_tuner">OpenCL Tuner</a><ul><li class="level3"><a href="#S3_7_1_cl_tuner_how_to">How to use it</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The Computer Vision and Machine Learning library is a set of functions optimised for both ARM CPUs and GPUs using SIMD technologies.Several builds of the library are available using various configurations:</p><ul>
<li>OS: Linux, Android or bare metal.</li>
<li>Architecture: armv7a (32bit) or arm64-v8a (64bit)</li>
<li>Technology: NEON / OpenCL / GLES_COMPUTE / NEON and OpenCL and GLES_COMPUTE</li>
<li>Debug / Asserts / Release: Use a build with asserts enabled to debug your application and enable extra validation. Once you are sure your application works as expected you can switch to a release build of the library for maximum performance.</li>
</ul>
<h1><a class="anchor" id="S0_1_contact"></a>
Contact / Support</h1>
<p>Please email <a href="#" onclick="location.href='mai'+'lto:'+'dev'+'el'+'ope'+'r@'+'arm'+'.c'+'om'; return false;">devel<span style="display: none;">.nosp@m.</span>oper<span style="display: none;">.nosp@m.</span>@arm.<span style="display: none;">.nosp@m.</span>com</a></p>
<p>In order to facilitate the work of the support team please provide the build information of the library you are using. To get the version of the library you are using simply run: </p><pre class="fragment">$ strings android-armv7a-cl-asserts/libarm_compute.so | grep arm_compute_version
arm_compute_version=v16.12 Build options: {'embed_kernels': '1', 'opencl': '1', 'arch': 'armv7a', 'neon': '0', 'asserts': '1', 'debug': '0', 'os': 'android', 'Werror': '1'} Git hash=f51a545d4ea12a9059fe4e598a092f1fd06dc858
</pre><h1><a class="anchor" id="S0_2_prebuilt_binaries"></a>
Pre-built binaries</h1>
<p>For each release we provide some pre-built binaries of the library <a href="https://github.com/ARM-software/ComputeLibrary/releases">here</a></p>
<p>These binaries have been built using the following toolchains:</p><ul>
<li>Linux armv7a: gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf</li>
<li>Linux arm64-v8a: gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu</li>
<li>Android armv7a: clang++ / libc++ NDK r18b</li>
<li>Android am64-v8a: clang++ / libc++ NDK r18b</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Make sure to use a compatible toolchain to build your application or you will get some std::bad_alloc errors at runtime.</dd></dl>
<h1><a class="anchor" id="S1_file_organisation"></a>
File organisation</h1>
<p>This archive contains:</p><ul>
<li>The <a class="el" href="namespacearm__compute.xhtml" title="Copyright (c) 2017-2020 Arm Limited.">arm_compute</a> header and source files</li>
<li>The latest Khronos OpenCL 1.2 C headers from the <a href="https://www.khronos.org/registry/cl/">Khronos OpenCL registry</a></li>
<li>The latest Khronos cl2.hpp from the <a href="https://www.khronos.org/registry/cl/">Khronos OpenCL registry</a> (API version 2.1 when this document was written)</li>
<li>The latest Khronos OpenGL ES 3.1 C headers from the <a href="https://www.khronos.org/registry/gles/">Khronos OpenGL ES registry</a></li>
<li>The latest Khronos EGL 1.5 C headers from the <a href="https://www.khronos.org/registry/gles/">Khronos EGL registry</a></li>
<li>The sources for a stub version of libOpenCL.so, libGLESv1_CM.so, libGLESv2.so and libEGL.so to help you build your application.</li>
<li>An examples folder containing a few examples to compile and link against the library.</li>
<li>A <a class="el" href="dir_cbdb8362360e11eafe2fa3bc74cf0ffd.xhtml">utils</a> folder containing headers with some boiler plate code used by the examples.</li>
<li>This documentation.</li>
</ul>
<p>For detailed information about file organization, please refer to Files -&gt; File List section of this documentation.</p>
<h1><a class="anchor" id="S2_versions_changelog"></a>
Release versions and changelog</h1>
<h2><a class="anchor" id="S2_1_versions"></a>
Release versions</h2>
<p>All releases are numbered vYY.MM Where YY are the last two digits of the year, and MM the month number. If there is more than one release in a month then an extra sequential number is appended at the end: </p><pre class="fragment">v17.03 (First release of March 2017)
v17.03.1 (Second release of March 2017)
v17.04 (First release of April 2017)
</pre><dl class="section note"><dt>Note</dt><dd>We're aiming at releasing one major public release with new features per quarter. All releases in between will only contain bug fixes.</dd></dl>
<h2><a class="anchor" id="S2_2_changelog"></a>
Changelog</h2>
<p>v20.11 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>Performance regressions can be noted when executing Depthwise Convolution on Neon with a depth multiplier &gt; 1 for quantized data type. This is planned to be resolved in 21.02 release.</li>
<li>Added new data type QASYMM8_SIGNED support for <a class="el" href="classarm__compute_1_1_n_e_r_o_i_align_layer.xhtml">NEROIAlignLayer</a>.</li>
<li>Added new data type S32 support for:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_arithmetic_subtraction.xhtml">NEArithmeticSubtraction</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_arithmetic_subtraction_kernel.xhtml">NEArithmeticSubtractionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pixel_wise_multiplication.xhtml">NEPixelWiseMultiplication</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pixel_wise_multiplication_kernel.xhtml">NEPixelWiseMultiplicationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_division.xhtml">NEElementwiseDivision</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_division_operation_kernel.xhtml">NEDivisionOperationKernel</a></li>
</ul>
</li>
<li>Interface change<ul>
<li>Properly support softmax axis to have the same meaning as other major frameworks. That is, axis now defines the dimension on which Softmax/Logsoftmax is performed. E.g. for input of shape 4x5x6 and axis=1, softmax will be applied to 4x6=24 vectors of size 5. The supported value range of axis is [-rank, rank). This change applies to the following functions:<ul>
<li><a class="el" href="namespacearm__compute.xhtml#a4df2143ca0a3bdbbbc54b440a52541cd">NESoftmaxLayer</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a4478c830368ed024dc47a2bf48978616">NELogSoftmaxLayer</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a30ce3b40394b4f2d1e4cc31db7183425">CLSoftmaxLayer</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#aa02883dd85b75a6eb0d4878f266908dd">CLLogSoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_softmax_layer.xhtml">GCSoftmaxLayer</a></li>
</ul>
</li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_scale_by_fixed_point_kernel.xhtml">CLGEMMLowpQuantizeDownInt32ScaleByFixedPointKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_logical_not.xhtml">CLLogicalNot</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_logical_and.xhtml">CLLogicalAnd</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_logical_or.xhtml">CLLogicalOr</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_logical_not.xhtml">NELogicalNot</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logical_and.xhtml">NELogicalAnd</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logical_or.xhtml">NELogicalOr</a></li>
</ul>
</li>
<li>Removed padding from NEON kernels:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_complex_pixel_wise_multiplication_kernel.xhtml">NEComplexPixelWiseMultiplicationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_maxima_suppression3x3_kernel.xhtml">NENonMaximaSuppression3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_remap_kernel.xhtml">NERemapKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_interleave4x4_kernel.xhtml">NEGEMMInterleave4x4Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer_kernel.xhtml">NEDirectConvolutionLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_scale_kernel.xhtml">NEScaleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_locally_connected_matrix_multiply_kernel.xhtml">NELocallyConnectedMatrixMultiplyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_offset_contribution_kernel.xhtml">NEGEMMLowpOffsetContributionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_transpose1x_w_kernel.xhtml">NEGEMMTranspose1xWKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pooling_layer_kernel.xhtml">NEPoolingLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution_kernel.xhtml">NEConvolutionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer_native_kernel.xhtml">NEDepthwiseConvolutionLayerNativeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_multiply_kernel.xhtml">NEGEMMLowpMatrixMultiplyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_multiply_kernel.xhtml">NEGEMMMatrixMultiplyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer_output_stage_kernel.xhtml">NEDirectConvolutionLayerOutputStageKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reduction_operation_kernel.xhtml">NEReductionOperationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_a_reduction_kernel.xhtml">NEGEMMLowpMatrixAReductionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_b_reduction_kernel.xhtml">NEGEMMLowpMatrixBReductionKernel</a></li>
</ul>
</li>
<li>Removed padding from OpenCL kernels:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_batch_concatenate_layer_kernel.xhtml">CLBatchConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_elementwise_operation_kernel.xhtml">CLElementwiseOperationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer_kernel.xhtml">CLBatchNormalizationLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_pooling_layer_kernel.xhtml">CLPoolingLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_winograd_input_transform_kernel.xhtml">CLWinogradInputTransformKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_native_kernel.xhtml">CLGEMMLowpMatrixMultiplyNativeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_a_reduction_kernel.xhtml">CLGEMMLowpMatrixAReductionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_b_reduction_kernel.xhtml">CLGEMMLowpMatrixBReductionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_offset_contribution_output_stage_kernel.xhtml">CLGEMMLowpOffsetContributionOutputStageKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_offset_contribution_kernel.xhtml">CLGEMMLowpOffsetContributionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_winograd_output_transform_kernel.xhtml">CLWinogradOutputTransformKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_reshaped_kernel.xhtml">CLGEMMLowpMatrixMultiplyReshapedKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_fuse_batch_normalization_kernel.xhtml">CLFuseBatchNormalizationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer_native_kernel.xhtml">CLDepthwiseConvolutionLayerNativeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depth_convert_layer_kernel.xhtml">CLDepthConvertLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_copy_kernel.xhtml">CLCopyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3_n_h_w_c_kernel.xhtml">CLDepthwiseConvolutionLayer3x3NHWCKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_activation_layer_kernel.xhtml">CLActivationLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_winograd_filter_transform_kernel.xhtml">CLWinogradFilterTransformKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_width_concatenate_layer_kernel.xhtml">CLWidthConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_width_concatenate4_tensors_kernel.xhtml">CLWidthConcatenate4TensorsKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_width_concatenate2_tensors_kernel.xhtml">CLWidthConcatenate2TensorsKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_logits1_d_max_shift_exp_sum_kernel.xhtml">CLLogits1DMaxShiftExpSumKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_logits1_d_norm_kernel.xhtml">CLLogits1DNormKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_height_concatenate_layer_kernel.xhtml">CLHeightConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_kernel.xhtml">CLGEMMMatrixMultiplyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_scale_kernel.xhtml">CLGEMMLowpQuantizeDownInt32ScaleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_scale_by_float_kernel.xhtml">CLGEMMLowpQuantizeDownInt32ScaleByFloatKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_reshaped_only_r_h_s_kernel.xhtml">CLGEMMLowpMatrixMultiplyReshapedOnlyRHSKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depth_concatenate_layer_kernel.xhtml">CLDepthConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_scale_by_fixed_point_kernel.xhtml">CLGEMMLowpQuantizeDownInt32ScaleByFixedPointKernel</a></li>
</ul>
</li>
<li>Removed OpenCL kernels / functions:<ul>
<li>CLGEMMLowpQuantizeDownInt32ToInt16ScaleByFixedPointKernel</li>
<li>CLGEMMLowpQuantizeDownInt32ToInt8ScaleByFixedPointKernel</li>
<li>CLGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPointKernel</li>
</ul>
</li>
<li>Deprecated OpenCL kernels / functions (If a kernel is used only by the function that is being deprecated, the kernel is deprecated together):<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_locally_connected_layer.xhtml" title="Basic function to compute the locally connected layer.">CLLocallyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_locally_connected_matrix_multiply_kernel.xhtml" title="OpenCL kernel to multiply each row of first tensor with low 2 dimensions of second tensor.">CLLocallyConnectedMatrixMultiplyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_absolute_difference.xhtml" title="Basic function to run CLAbsoluteDifferenceKernel.">CLAbsoluteDifference</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_absolute_difference_kernel.xhtml" title="Interface for the absolute difference kernel.">CLAbsoluteDifferenceKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_accumulate.xhtml" title="Basic function to run CLAccumulateKernel.">CLAccumulate</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_accumulate_kernel.xhtml" title="Interface for the accumulate kernel.">CLAccumulateKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_accumulate_squared.xhtml" title="Basic function to run CLAccumulateSquaredKernel.">CLAccumulateSquared</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_accumulate_squared_kernel.xhtml" title="Interface for the accumulate squared kernel.">CLAccumulateSquaredKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_accumulate_weighted.xhtml" title="Basic function to run CLAccumulateWeightedKernel.">CLAccumulateWeighted</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_accumulate_weighted_kernel.xhtml" title="Interface for the accumulate weighted kernel.">CLAccumulateWeightedKernel</a></li>
<li>CLAccumulateWeightedFP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_box3x3.xhtml" title="Basic function to execute box filter 3x3.">CLBox3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_box3x3_kernel.xhtml" title="Interface for the box 3x3 filter kernel.">CLBox3x3Kernel</a></li>
<li>CLBox3x3FP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_canny_edge.xhtml" title="Basic function to execute canny edge on OpenCL.">CLCannyEdge</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_combine.xhtml" title="Basic function to run CLChannelCombineKernel to perform channel combination.">CLChannelCombine</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_combine_kernel.xhtml" title="Interface for the channel combine kernel.">CLChannelCombineKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_extract.xhtml" title="Basic function to run CLChannelExtractKernel to perform channel extraction.">CLChannelExtract</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_extract_kernel.xhtml" title="Interface for the channel extract kernel.">CLChannelExtractKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_color_convert.xhtml" title="Basic function to run CLColorConvertKernel.">CLColorConvert</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_color_convert_kernel.xhtml" title="Interface for the color convert kernel.">CLColorConvertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_convolution3x3.xhtml" title="Basic function to execute convolution of size 3x3.">CLConvolution3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_convolution_rectangle.xhtml" title="Basic function to execute non-square convolution.">CLConvolutionRectangle</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_convolution_rectangle_kernel.xhtml" title="Kernel for the running convolution on a rectangle matrix.">CLConvolutionRectangleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_convolution_square.xhtml" title="Basic function to execute square convolution.Currently it supports 5x5, 7x7, 9x9.">CLConvolutionSquare</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_convolution_kernel.xhtml" title="Interface for the kernel to run an arbitrary size convolution on a tensor.">CLConvolutionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_derivative.xhtml" title="Basic function to execute first order derivative operator.">CLDerivative</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_derivative_kernel.xhtml" title="Interface for the derivative kernel.">CLDerivativeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_dilate.xhtml" title="Basic function to execute dilate.">CLDilate</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_dilate_kernel.xhtml" title="Interface for the dilate kernel.">CLDilateKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_equalize_histogram.xhtml" title="Basic function to execute histogram equalization.">CLEqualizeHistogram</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_erode.xhtml" title="Basic function to execute erode.">CLErode</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_erode_kernel.xhtml" title="Interface for the erode kernel.">CLErodeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_fast_corners.xhtml" title="Basic function to execute fast corners.">CLFastCorners</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_fast_corners_kernel.xhtml" title="CL kernel to perform fast corners.">CLFastCornersKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian3x3.xhtml" title="Basic function to execute gaussian filter 3x3.">CLGaussian3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian3x3_kernel.xhtml" title="Interface for the Gaussian 3x3 filter kernel.">CLGaussian3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian5x5.xhtml" title="Basic function to execute gaussian filter 5x5.">CLGaussian5x5</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian5x5_hor_kernel.xhtml" title="Interface for the kernel to run the horizontal pass of 5x5 Gaussian filter on a tensor.">CLGaussian5x5HorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian5x5_vert_kernel.xhtml" title="Interface for the kernel to run the vertical pass of 5x5 Gaussian filter on a tensor.">CLGaussian5x5VertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid.xhtml" title="Common interface for all Gaussian pyramid functions.">CLGaussianPyramid</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_half.xhtml" title="Basic function to execute gaussian pyramid with HALF scale factor.">CLGaussianPyramidHalf</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_orb.xhtml" title="Basic function to execute gaussian pyramid with ORB scale factor.">CLGaussianPyramidOrb</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_harris_corners.xhtml" title="Basic function to execute harris corners detection.">CLHarrisCorners</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_harris_score_kernel.xhtml" title="Interface for the harris score kernel.">CLHarrisScoreKernel</a></li>
<li>CLHarrisScoreFP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_histogram.xhtml" title="Basic function to execute histogram.">CLHistogram</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_histogram_kernel.xhtml" title="Interface to run the histogram kernel.">CLHistogramKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_orientation_binning_kernel.xhtml" title="OpenCL kernel to perform HOG Orientation Binning.">CLHOGOrientationBinningKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_block_normalization_kernel.xhtml" title="OpenCL kernel to perform HOG block normalization.">CLHOGBlockNormalizationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_detector_kernel.xhtml" title="OpenCL kernel to perform HOG detector kernel using linear SVM.">CLHOGDetectorKernel</a></li>
<li>CLHOGNonMaximaSuppressionKernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_descriptor.xhtml" title="Basic function to calculate HOG descriptor.">CLHOGDescriptor</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_detector.xhtml" title="Basic function to execute HOG detector based on linear SVM.">CLHOGDetector</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_gradient.xhtml" title="Basic function to calculate the gradient for HOG.">CLHOGGradient</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_multi_detection.xhtml" title="Basic function to detect multiple objects (or the same object at different scales) on the same input ...">CLHOGMultiDetection</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_orientation_binning_kernel.xhtml" title="OpenCL kernel to perform HOG Orientation Binning.">CLHOGOrientationBinningKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_block_normalization_kernel.xhtml" title="OpenCL kernel to perform HOG block normalization.">CLHOGBlockNormalizationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_detector_kernel.xhtml" title="OpenCL kernel to perform HOG detector kernel using linear SVM.">CLHOGDetectorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_integral_image.xhtml" title="Basic function to execute integral image.">CLIntegralImage</a></li>
<li>CLIntegralImageKernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_laplacian_reconstruct.xhtml" title="Basic function to execute laplacian reconstruction.">CLLaplacianReconstruct</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_laplacian_pyramid.xhtml" title="Basic function to execute laplacian pyramid.">CLLaplacianPyramid</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_magnitude.xhtml" title="Basic function to run CLMagnitudePhaseKernel.">CLMagnitude</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_magnitude_phase_kernel.xhtml" title="Template interface for the kernel to compute magnitude and phase.">CLMagnitudePhaseKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_median3x3.xhtml" title="Basic function to execute median filter.">CLMedian3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_median3x3_kernel.xhtml" title="Interface for the median 3x3 filter kernel.">CLMedian3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_min_max_location.xhtml" title="Basic function to execute min and max location.">CLMinMaxLocation</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_min_max_location_kernel.xhtml" title="Interface for the kernel to find min max locations of an image.">CLMinMaxLocationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_non_linear_filter.xhtml" title="Basic function to execute non linear filter.">CLNonLinearFilter</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_non_linear_filter_kernel.xhtml" title="Interface for the kernel to apply a non-linear filter.">CLNonLinearFilterKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_non_maxima_suppression3x3.xhtml" title="Basic function to execute non-maxima suppression over a 3x3 window.">CLNonMaximaSuppression3x3</a></li>
<li>CLNonMaximaSuppression3x3FP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_non_maxima_suppression3x3_kernel.xhtml" title="Interface to perform Non-Maxima suppression over a 3x3 window using OpenCL.">CLNonMaximaSuppression3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_optical_flow.xhtml" title="Basic function to execute optical flow.">CLOpticalFlow</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_phase.xhtml" title="Basic function to execute an CLMagnitudePhaseKernel.">CLPhase</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_remap.xhtml" title="Basic function to execute remap.">CLRemap</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_remap_kernel.xhtml" title="OpenCL kernel to perform a remap on a tensor.">CLRemapKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_scharr3x3.xhtml" title="Basic function to execute scharr 3x3 filter.">CLScharr3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_scharr3x3_kernel.xhtml" title="Interface for the kernel to run a 3x3 Scharr filter on a tensor.">CLScharr3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sobel3x3.xhtml" title="Basic function to execute sobel 3x3 filter.">CLSobel3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sobel3x3_kernel.xhtml" title="Interface for the kernel to run a 3x3 Sobel filter on a tensor.">CLSobel3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sobel5x5.xhtml" title="Basic function to execute sobel 5x5 filter.">CLSobel5x5</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sobel5x5_hor_kernel.xhtml" title="Interface for the kernel to run the horizontal pass of 5x5 Sobel filter on a tensor.">CLSobel5x5HorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sobel5x5_vert_kernel.xhtml" title="Interface for the kernel to run the vertical pass of 5x5 Sobel filter on a tensor.">CLSobel5x5VertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sobel7x7.xhtml" title="Basic function to execute sobel 7x7 filter.">CLSobel7x7</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sobel7x7_hor_kernel.xhtml" title="Interface for the kernel to run the horizontal pass of 7x7 Sobel filter on a tensor.">CLSobel7x7HorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sobel7x7_vert_kernel.xhtml" title="Interface for the kernel to run the vertical pass of 7x7 Sobel filter on a tensor.">CLSobel7x7VertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_threshold.xhtml" title="Basic function to run CLThresholdKernel.">CLThreshold</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_threshold_kernel.xhtml" title="Interface for the thresholding kernel.">CLThresholdKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_warp_affine.xhtml" title="Basic function to run CLWarpAffineKernel for AFFINE transformation.">CLWarpAffine</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_warp_affine_kernel.xhtml" title="Interface for the warp affine kernel.">CLWarpAffineKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_warp_perspective.xhtml" title="Basic function to run CLWarpPerspectiveKernel for PERSPECTIVE transformation.">CLWarpPerspective</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_warp_perspective_kernel.xhtml" title="Interface for the warp perspective kernel.">CLWarpPerspectiveKernel</a></li>
</ul>
</li>
<li>Deprecated NEON kernels / functions (If a kernel is used only by the function that is being deprecated, the kernel is deprecated together):<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_locally_connected_layer.xhtml" title="Basic function to compute the locally connected layer.">NELocallyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_locally_connected_matrix_multiply_kernel.xhtml" title="NEON kernel to multiply each row of first tensor with low 2 dimensions of second tensor.">NELocallyConnectedMatrixMultiplyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_absolute_difference.xhtml" title="Basic function to run NEAbsoluteDifferenceKernel.">NEAbsoluteDifference</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_absolute_difference_kernel.xhtml" title="Interface for the absolute difference kernel.">NEAbsoluteDifferenceKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_accumulate.xhtml" title="Basic function to run NEAccumulateKernel.">NEAccumulate</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_accumulate_kernel.xhtml" title="Interface for the accumulate kernel.">NEAccumulateKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_accumulate_squared.xhtml" title="Basic function to run NEAccumulateSquaredKernel.">NEAccumulateSquared</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_accumulate_squared_kernel.xhtml" title="Interface for the accumulate squared kernel.">NEAccumulateSquaredKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_accumulate_weighted.xhtml" title="Basic function to run NEAccumulateWeightedKernel.">NEAccumulateWeighted</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_accumulate_weighted_kernel.xhtml" title="Interface for the accumulate weighted kernel.">NEAccumulateWeightedKernel</a></li>
<li>NEAccumulateWeightedFP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_box3x3.xhtml" title="Basic function to execute box filter 3x3.">NEBox3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_box3x3_kernel.xhtml" title="NEON kernel to perform a Box 3x3 filter.">NEBox3x3Kernel</a></li>
<li>NEBox3x3FP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_canny_edge.xhtml" title="Basic function to execute canny edge on NEON.">NECannyEdge</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_channel_combine.xhtml" title="Basic function to run NEChannelCombineKernel to perform channel combination.">NEChannelCombine</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_channel_combine_kernel.xhtml" title="Interface for the channel combine kernel.">NEChannelCombineKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_channel_extract.xhtml" title="Basic function to run NEChannelExtractKernel to perform channel extraction.">NEChannelExtract</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_channel_extract_kernel.xhtml" title="Interface for the channel extract kernel.">NEChannelExtractKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_color_convert.xhtml" title="Basic function to run NEColorConvertKernel to perform color conversion.">NEColorConvert</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_color_convert_kernel.xhtml" title="Interface for the color convert kernel.">NEColorConvertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution3x3.xhtml" title="Basic function to execute convolution of size 3x3.">NEConvolution3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution_rectangle.xhtml" title="Basic function to execute non-square convolution.">NEConvolutionRectangle</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution_rectangle_kernel.xhtml" title="Kernel for the running convolution on a rectangle matrix.">NEConvolutionRectangleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution_square.xhtml" title="Basic function to execute convolution of size 5x5, 7x7, 9x9.">NEConvolutionSquare</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution_kernel.xhtml" title="Interface for the kernel to run an arbitrary size convolution on a tensor.">NEConvolutionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_derivative.xhtml" title="Basic function to execute first order derivative operator.">NEDerivative</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_derivative_kernel.xhtml" title="Interface for the kernel to run the derivative along the X/Y directions on a tensor.">NEDerivativeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_dilate.xhtml" title="Basic function to execute dilate.">NEDilate</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_dilate_kernel.xhtml" title="Interface for the kernel to perform boolean image dilatation.">NEDilateKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_equalize_histogram.xhtml" title="Basic function to execute histogram equalization.">NEEqualizeHistogram</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_erode.xhtml" title="Basic function to execute erode.">NEErode</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_erode_kernel.xhtml" title="Interface for the kernel to perform boolean image erosion.">NEErodeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_fast_corners.xhtml" title="Basic function to execute fast corners.">NEFastCorners</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_fast_corners_kernel.xhtml" title="NEON kernel to perform fast corners.">NEFastCornersKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian3x3.xhtml" title="Basic function to execute gaussian filter 3x3.">NEGaussian3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian3x3_kernel.xhtml" title="NEON kernel to perform a Gaussian 3x3 filter.">NEGaussian3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian5x5.xhtml" title="Basic function to execute gaussian filter 5x5.">NEGaussian5x5</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian5x5_hor_kernel.xhtml" title="NEON kernel to perform a Gaussian 5x5 filter (horizontal pass)">NEGaussian5x5HorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian5x5_vert_kernel.xhtml" title="NEON kernel to perform a Gaussian 5x5 filter (vertical pass)">NEGaussian5x5VertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid.xhtml" title="Common interface for all Gaussian pyramid functions.">NEGaussianPyramid</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid_half.xhtml" title="Basic function to execute gaussian pyramid with HALF scale factor.">NEGaussianPyramidHalf</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid_orb.xhtml" title="Basic function to execute gaussian pyramid with ORB scale factor.">NEGaussianPyramidOrb</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_harris_corners.xhtml" title="Basic function to execute harris corners detection.">NEHarrisCorners</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_harris_score_kernel.xhtml" title="Template NEON kernel to perform Harris Score.">NEHarrisScoreKernel</a></li>
<li>NEHarrisScoreFP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_histogram.xhtml" title="Basic function to run NEHistogramKernel.">NEHistogram</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_histogram_kernel.xhtml" title="Interface for the histogram kernel.">NEHistogramKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_orientation_binning_kernel.xhtml" title="NEON kernel to perform HOG Orientation Binning.">NEHOGOrientationBinningKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_block_normalization_kernel.xhtml" title="NEON kernel to perform HOG block normalization.">NEHOGBlockNormalizationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector_kernel.xhtml" title="NEON kernel to perform HOG detector kernel using linear SVM.">NEHOGDetectorKernel</a></li>
<li>NEHOGNonMaximaSuppressionKernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_descriptor.xhtml" title="Basic function to calculate HOG descriptor.">NEHOGDescriptor</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector.xhtml" title="Basic function to execute HOG detector based on linear SVM.">NEHOGDetector</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_gradient.xhtml" title="Basic function to calculate the gradient for HOG.">NEHOGGradient</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_multi_detection.xhtml" title="Basic function to detect multiple objects (or the same object at different scales) on the same input ...">NEHOGMultiDetection</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_orientation_binning_kernel.xhtml" title="NEON kernel to perform HOG Orientation Binning.">NEHOGOrientationBinningKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_block_normalization_kernel.xhtml" title="NEON kernel to perform HOG block normalization.">NEHOGBlockNormalizationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector_kernel.xhtml" title="NEON kernel to perform HOG detector kernel using linear SVM.">NEHOGDetectorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_integral_image.xhtml" title="Basic function to run a NEIntegralImageKernel.">NEIntegralImage</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_integral_image_kernel.xhtml" title="Kernel to perform an image integral on an image.">NEIntegralImageKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_laplacian_reconstruct.xhtml" title="Basic function to execute laplacian reconstruction.">NELaplacianReconstruct</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_laplacian_pyramid.xhtml" title="Basic function to execute laplacian pyramid.">NELaplacianPyramid</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_magnitude.xhtml" title="Basic function to run NEMagnitudePhaseKernel.">NEMagnitude</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_magnitude_phase_kernel.xhtml" title="Template interface for the kernel to compute magnitude and phase.">NEMagnitudePhaseKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_median3x3.xhtml" title="Basic function to execute median filter.">NEMedian3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_median3x3_kernel.xhtml" title="Kernel to perform a median filter on a tensor.">NEMedian3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_min_max_location.xhtml" title="Basic function to execute min and max location.">NEMinMaxLocation</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_min_max_location_kernel.xhtml" title="Interface for the kernel to find min max locations of an image.">NEMinMaxLocationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_linear_filter.xhtml" title="Basic function to execute non linear filter.">NENonLinearFilter</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_linear_filter_kernel.xhtml" title="Interface for the kernel to apply a non-linear filter.">NENonLinearFilterKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_maxima_suppression3x3.xhtml" title="Basic function to execute non-maxima suppression over a 3x3 window.">NENonMaximaSuppression3x3</a></li>
<li>NENonMaximaSuppression3x3FP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_maxima_suppression3x3_kernel.xhtml" title="Interface to perform Non-Maxima suppression over a 3x3 window using NEON.">NENonMaximaSuppression3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_optical_flow.xhtml" title="Basic function to execute optical flow.">NEOpticalFlow</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_phase.xhtml" title="Basic function to run NEMagnitudePhaseKernel.">NEPhase</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_remap.xhtml" title="Basic function to execute remap.">NERemap</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_remap_kernel.xhtml" title="NEON kernel to perform a remap on a tensor.">NERemapKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_scharr3x3.xhtml" title="Basic function to execute scharr 3x3 filter.">NEScharr3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_scharr3x3_kernel.xhtml" title="Interface for the kernel to run a 3x3 Scharr filter on a tensor.">NEScharr3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sobel3x3.xhtml" title="Basic function to execute sobel 3x3 filter.">NESobel3x3</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sobel3x3_kernel.xhtml" title="Interface for the kernel to run a 3x3 Sobel X filter on a tensor.">NESobel3x3Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sobel5x5.xhtml" title="Basic function to execute sobel 5x5 filter.">NESobel5x5</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sobel5x5_hor_kernel.xhtml" title="Interface for the kernel to run the horizontal pass of 5x5 Sobel filter on a tensor.">NESobel5x5HorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sobel5x5_vert_kernel.xhtml" title="Interface for the kernel to run the vertical pass of 5x5 Sobel Y filter on a tensor.">NESobel5x5VertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sobel7x7.xhtml" title="Basic function to execute sobel 7x7 filter.">NESobel7x7</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sobel7x7_hor_kernel.xhtml" title="Interface for the kernel to run the horizontal pass of 7x7 Sobel filter on a tensor.">NESobel7x7HorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sobel7x7_vert_kernel.xhtml" title="Interface for the kernel to run the vertical pass of 7x7 Sobel Y filter on a tensor.">NESobel7x7VertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_threshold.xhtml" title="Basic function to run NEThresholdKernel.">NEThreshold</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_threshold_kernel.xhtml" title="Interface for the thresholding kernel.">NEThresholdKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_warp_affine.xhtml" title="Basic function to run NEWarpAffineKernel.">NEWarpAffine</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_warp_affine_kernel.xhtml" title="Template interface for the kernel to compute warp affine.">NEWarpAffineKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_warp_perspective.xhtml" title="Basic function to run NEWarpPerspectiveKernel.">NEWarpPerspective</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_warp_perspective_kernel.xhtml" title="Template interface for the kernel to compute warp perspective.">NEWarpPerspectiveKernel</a></li>
</ul>
</li>
<li>Deprecated GLES kernels / functions (If a kernel is used only by the function that is being deprecated, the kernel is deprecated together):<ul>
<li><a class="el" href="classarm__compute_1_1_g_c_absolute_difference.xhtml" title="Basic function to run GCAbsoluteDifferenceKernel.">GCAbsoluteDifference</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_activation_layer.xhtml" title="Basic function to run GCActivationLayerKernel.">GCActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_arithmetic_addition.xhtml" title="Basic function to run GCArithmeticAdditionKernel.">GCArithmeticAddition</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_batch_normalization_layer.xhtml" title="Basic function to run GCBatchNormalizationLayerKernel and simulate a batch normalization layer.">GCBatchNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_concatenate_layer.xhtml" title="Basic function to execute concatenate tensors along a given axis.">GCConcatenateLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_convolution_layer.xhtml" title="Basic function to compute the convolution layer.">GCConvolutionLayer</a></li>
<li>GCDepthwiseConvolutionLayer</li>
<li><a class="el" href="classarm__compute_1_1_g_c_direct_convolution_layer.xhtml" title="Basic function to execute direct convolution function.">GCDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_dropout_layer.xhtml" title="Basic function to do dropout op.">GCDropoutLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_fill_border.xhtml" title="Basic function to run GCFillBorderKernel.">GCFillBorder</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_fully_connected_layer.xhtml" title="Basic function to compute a Fully Connected layer on OpenGL ES.">GCFullyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m.xhtml" title="Basic function to execute GEMM on OpenGLES Compute.">GCGEMM</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_interleave4x4.xhtml" title="Basic function to execute GCGEMMInterleave4x4Kernel.">GCGEMMInterleave4x4</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_transpose1x_w.xhtml" title="Basic function to execute GCGEMMTranspose1xWKernel.">GCGEMMTranspose1xW</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_normalization_layer.xhtml" title="Basic function to compute a normalization layer.">GCNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_normalize_planar_y_u_v_layer.xhtml" title="Basic function to run GCNormalizePlanarYUVLayerKernel.">GCNormalizePlanarYUVLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_pixel_wise_multiplication.xhtml" title="Basic function to run GCPixelWiseMultiplicationKernel.">GCPixelWiseMultiplication</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_pooling_layer.xhtml" title="Basic function to simulate a pooling layer with the specified pooling operation.">GCPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_scale.xhtml" title="Basic function to run GCScaleKernel.">GCScale</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_softmax_layer.xhtml" title="Basic function to compute a SoftmaxLayer.">GCSoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_tensor_shift.xhtml" title="Basic function to execute shift function for tensor.">GCTensorShift</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_transpose.xhtml" title="Basic function to transpose a matrix on OpenGL ES.">GCTranspose</a></li>
</ul>
</li>
</ul>
<p>v20.08 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>Added new data type QASYMM8_SIGNED support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_arg_min_max_layer.xhtml">CLArgMinMaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_arg_min_max_layer_kernel.xhtml">CLArgMinMaxLayerKernel</a></li>
</ul>
</li>
<li>Added new data type U8 support for:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_crop_kernel.xhtml">NECropKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_crop_kernel.xhtml">CLCropKernel</a></li>
</ul>
</li>
<li>Added aligh_corner support for nearest neighbor interpolation in:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_scale_kernel.xhtml">NEScaleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_scale_kernel.xhtml">CLScaleKernel</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_max_unpooling_layer_kernel.xhtml">CLMaxUnpoolingLayerKernel</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_max_unpooling_layer_kernel.xhtml">NEMaxUnpoolingLayerKernel</a></li>
</ul>
</li>
<li>New graph example:<ul>
<li>graph_yolov3_output_detector</li>
</ul>
</li>
<li>GEMMTuner improvements:<ul>
<li>Added fp16 support</li>
<li>Output json files for easier integration</li>
<li>Enabled tuning for export_to_cl_image_rhs option for RHS tensors</li>
<li>More robust script for running benchmarks</li>
</ul>
</li>
<li>Removed padding from:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_pixel_wise_multiplication_kernel.xhtml">NEPixelWiseMultiplicationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_height_concatenate_layer_kernel.xhtml">NEHeightConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_threshold_kernel.xhtml">NEThresholdKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_batch_concatenate_layer_kernel.xhtml">NEBatchConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_transpose_kernel.xhtml">NETransposeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_batch_normalization_layer_kernel.xhtml">NEBatchNormalizationLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_arithmetic_subtraction_kernel.xhtml">NEArithmeticSubtractionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_bounding_box_transform_kernel.xhtml">NEBoundingBoxTransformKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_max_kernel.xhtml">NELogits1DMaxKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_softmax_kernel.xhtml">NELogits1DSoftmaxKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_r_o_i_pooling_layer_kernel.xhtml">NEROIPoolingLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_r_o_i_align_layer_kernel.xhtml">NEROIAlignLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_y_o_l_o_layer_kernel.xhtml">NEYOLOLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_upsample_layer_kernel.xhtml">NEUpsampleLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_floor_kernel.xhtml">NEFloorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_width_concatenate_layer_kernel.xhtml">NEWidthConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depth_concatenate_layer_kernel.xhtml">NEDepthConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_normalization_layer_kernel.xhtml">NENormalizationLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_l2_normalize_layer_kernel.xhtml">NEL2NormalizeLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_fill_array_kernel.xhtml">NEFillArrayKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depth_convert_layer_kernel.xhtml">NEDepthConvertLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_range_kernel.xhtml">NERangeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_prior_box_layer.xhtml">NEPriorBoxLayer</a></li>
</ul>
</li>
<li>Removed OpenCL kernels / functions:<ul>
<li>CLGEMMLowpQuantizeDownInt32ToUint8Scale</li>
<li>CLGEMMLowpQuantizeDownInt32ToUint8ScaleByFloat</li>
</ul>
</li>
<li>Removed NEON kernels / functions:<ul>
<li>NEGEMMLowpQuantizeDownInt32ToUint8Scale</li>
<li>NEGEMMMatrixAccumulateBiasesKernel</li>
</ul>
</li>
<li>Deprecated functions / interfaces:<ul>
<li>Non-descriptor based interfaces for <a class="el" href="classarm__compute_1_1_n_e_threshold.xhtml">NEThreshold</a>, <a class="el" href="classarm__compute_1_1_c_l_threshold.xhtml">CLThreshold</a></li>
<li>Non-descriptor based interfaces for <a class="el" href="classarm__compute_1_1_n_e_scale.xhtml">NEScale</a>, <a class="el" href="classarm__compute_1_1_c_l_scale.xhtml">CLScale</a> and <a class="el" href="classarm__compute_1_1_g_c_scale.xhtml">GCScale</a></li>
<li>In <a class="el" href="namespacearm__compute.xhtml#a4df2143ca0a3bdbbbc54b440a52541cd">NESoftmaxLayer</a>, <a class="el" href="namespacearm__compute.xhtml#a4478c830368ed024dc47a2bf48978616">NELogSoftmaxLayer</a>, <a class="el" href="namespacearm__compute.xhtml#a30ce3b40394b4f2d1e4cc31db7183425">CLSoftmaxLayer</a>, <a class="el" href="namespacearm__compute.xhtml#aa02883dd85b75a6eb0d4878f266908dd">CLLogSoftmaxLayer</a> and <a class="el" href="classarm__compute_1_1_g_c_softmax_layer.xhtml">GCSoftmaxLayer</a> : The default "axis" value for <a class="el" href="namespacearm__compute.xhtml#a30ce3b40394b4f2d1e4cc31db7183425">CLSoftmaxLayer</a>, <a class="el" href="namespacearm__compute.xhtml#aa02883dd85b75a6eb0d4878f266908dd">CLLogSoftmaxLayer</a> and <a class="el" href="classarm__compute_1_1_g_c_softmax_layer.xhtml">GCSoftmaxLayer</a> is changed from 1 to 0. Only axis 0 is supported. The default "axis" value for <a class="el" href="namespacearm__compute.xhtml#a4df2143ca0a3bdbbbc54b440a52541cd">NESoftmaxLayer</a>, <a class="el" href="namespacearm__compute.xhtml#a4478c830368ed024dc47a2bf48978616">NELogSoftmaxLayer</a> is changed from 1 to 0. Only axis 0 is supported.</li>
</ul>
</li>
<li>The support for quantized data types has been removed from <a class="el" href="namespacearm__compute.xhtml#aa02883dd85b75a6eb0d4878f266908dd">CLLogSoftmaxLayer</a> due to implementation complexity.</li>
<li>Removed padding requirement for the input (e.g. LHS of GEMM) and output in <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_native_kernel.xhtml">CLGEMMMatrixMultiplyNativeKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_reshaped_kernel.xhtml">CLGEMMMatrixMultiplyReshapedKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_reshaped_only_r_h_s_kernel.xhtml">CLGEMMMatrixMultiplyReshapedOnlyRHSKernel</a> and <a class="el" href="classarm__compute_1_1_c_l_im2_col_kernel.xhtml">CLIm2ColKernel</a> (NHWC only)<ul>
<li>This change allows to use <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_convolution_layer.xhtml">CLGEMMConvolutionLayer</a> without extra padding for the input and output.</li>
<li>Only the weights/bias of <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_convolution_layer.xhtml">CLGEMMConvolutionLayer</a> could require padding for the computation.</li>
<li>Only on Arm Mali Midgard GPUs, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_convolution_layer.xhtml">CLGEMMConvolutionLayer</a> could require padding since <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_kernel.xhtml">CLGEMMMatrixMultiplyKernel</a> is called and currently requires padding.</li>
</ul>
</li>
<li>Added support for exporting the OpenCL buffer object to the OpenCL image object in <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_reshaped_kernel.xhtml">CLGEMMMatrixMultiplyReshapedKernel</a> and <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_reshaped_only_r_h_s_kernel.xhtml">CLGEMMMatrixMultiplyReshapedOnlyRHSKernel</a>.<ul>
<li>This support allows to export the OpenCL buffer used for the reshaped RHS matrix to the OpenCL image object.</li>
<li>The padding requirement for the OpenCL image object is considered into the <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_reshape_r_h_s_matrix_kernel.xhtml">CLGEMMReshapeRHSMatrixKernel</a>.</li>
<li>The reshaped RHS matrix stores the weights when GEMM is used to accelerate <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_convolution_layer.xhtml">CLGEMMConvolutionLayer</a>.</li>
</ul>
</li>
</ul>
<p>v20.05 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>Updated recommended NDK version to r18b.</li>
<li>Updated recommended gcc version to Linaro 6.3.1.</li>
<li>Added Bfloat16 type support</li>
<li>Added Bfloat16 support in:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_weights_reshape_kernel.xhtml">NEWeightsReshapeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution_layer_reshape_weights.xhtml">NEConvolutionLayerReshapeWeights</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_im2_col_kernel.xhtml">NEIm2ColKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_im2_col.xhtml">NEIm2Col</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depth_convert_layer_kernel.xhtml">NEDepthConvertLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depth_convert_layer.xhtml">NEDepthConvertLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_convolution_layer.xhtml">NEGEMMConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_assembly_dispatch.xhtml">NEGEMMAssemblyDispatch</a></li>
</ul>
</li>
<li>Added new data type QASYMM8_SIGNED support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_direct_convolution_layer.xhtml">CLDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_deconvolution_layer.xhtml">CLDeconvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_direct_deconvolution_layer.xhtml">CLDirectDeconvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_deconvolution_layer.xhtml">CLGEMMDeconvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_reshaped_kernel.xhtml">CLGEMMLowpMatrixMultiplyReshapedKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_scale_kernel.xhtml">CLGEMMLowpQuantizeDownInt32ScaleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_scale_by_float_kernel.xhtml">CLGEMMLowpQuantizeDownInt32ScaleByFloatKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reduction_operation.xhtml">CLReductionOperation</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reduce_mean.xhtml">CLReduceMean</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_scale.xhtml">NEScale</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_scale_kernel.xhtml">NEScaleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_upsample_layer.xhtml">NEUpsampleLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_cast.xhtml">NECast</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reduction_operation.xhtml">NEReductionOperation</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reduce_mean.xhtml">NEReduceMean</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_arg_min_max_layer.xhtml">NEArgMinMaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_deconvolution_layer.xhtml">NEDeconvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_scale_kernel.xhtml">NEGEMMLowpQuantizeDownInt32ScaleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_box_with_non_maxima_suppression_limit.xhtml">CPPBoxWithNonMaximaSuppressionLimit</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_detection_post_process_layer.xhtml">CPPDetectionPostProcessLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_permute_kernel.xhtml">CPPPermuteKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_permute.xhtml">CPPPermute</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_top_k_v_kernel.xhtml">CPPTopKVKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_top_k_v.xhtml">CPPTopKV</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_upsample.xhtml">CPPUpsample</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_upsample_kernel.xhtml">CPPUpsampleKernel</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_q_l_s_t_m_layer.xhtml">CLQLSTMLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_q_l_s_t_m_layer_normalization_kernel.xhtml">CLQLSTMLayerNormalizationKernel</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_q_l_s_t_m_layer.xhtml">NEQLSTMLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_q_l_s_t_m_layer_normalization_kernel.xhtml">NEQLSTMLayerNormalizationKernel</a></li>
</ul>
</li>
<li>Added HARD_SWISH support in:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_activation_layer_kernel.xhtml">CLActivationLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_activation_layer_kernel.xhtml">NEActivationLayerKernel</a></li>
</ul>
</li>
<li>Deprecated OpenCL kernels / functions:<ul>
<li>CLGEMMLowpQuantizeDownInt32ToUint8Scale</li>
<li>CLGEMMLowpQuantizeDownInt32ToUint8ScaleByFloat</li>
</ul>
</li>
<li>Deprecated NEON kernels / functions:<ul>
<li>NEGEMMLowpQuantizeDownInt32ToUint8Scale</li>
</ul>
</li>
<li>Removed CPP kernels / functions:<ul>
<li>CPPFlipWeightsKernel</li>
</ul>
</li>
<li>Removed <a class="el" href="structarm__compute_1_1_pooling_layer_info.xhtml" title="Pooling Layer Information struct.">PoolingLayerInfo</a> constructors without Data Layout.</li>
<li>Removed CLDepthwiseConvolutionLayer3x3</li>
<li>Removed NEDepthwiseConvolutionLayerOptimized</li>
<li>Added support for Winograd 3x3,4x4 on NEON FP16:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_convolution_layer.xhtml">NEWinogradConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_layer_transform_input_kernel.xhtml">NEWinogradLayerTransformInputKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_layer_transform_output_kernel.xhtml">NEWinogradLayerTransformOutputKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_layer_transform_weights_kernel.xhtml">NEWinogradLayerTransformWeightsKernel</a></li>
</ul>
</li>
<li>Added <a class="el" href="classarm__compute_1_1_c_l_compile_context.xhtml" title="CLCompileContext class.">CLCompileContext</a></li>
<li>Added NEON GEMM kernel with 2D window support</li>
</ul>
<p>v20.02.1 Maintenance release</p><ul>
<li>Added Android-NN build script.</li>
</ul>
<p>v20.02 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>Added new data type QASYMM8_SIGNED support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a></li>
<li>CLDepthwiseConvolutionLayer3x3</li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_convolution_layer.xhtml">CLGEMMConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_core.xhtml">CLGEMMLowpMatrixMultiplyCore</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_reshaped_only_r_h_s_kernel.xhtml">CLGEMMLowpMatrixMultiplyReshapedOnlyRHSKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_native_kernel.xhtml">CLGEMMLowpMatrixMultiplyNativeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_activation_layer.xhtml">NEActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_comparison_operation_kernel.xhtml">NEComparisonOperationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution_layer.xhtml">NEConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer.xhtml">NEDepthwiseConvolutionLayer</a></li>
<li>NEDepthwiseConvolutionLayer3x3Kernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer_output_stage_kernel.xhtml">NEDirectConvolutionLayerOutputStageKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_comparison.xhtml">NEElementwiseComparison</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_max.xhtml">NEElementwiseMax</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_min.xhtml">NEElementwiseMin</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_squared_diff.xhtml">NEElementwiseSquaredDiff</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_fully_connected_layer.xhtml">NEFullyConnectedLayer</a></li>
<li>NEGEMMMatrixVectorMultiplyKernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_pixel_wise_multiplication.xhtml">NEPixelWiseMultiplication</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pooling_layer.xhtml">NEPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_p_relu_layer.xhtml">NEPReluLayer</a></li>
</ul>
</li>
<li>Added support for QSYMM8_PER_CHANNEL in:<ul>
<li>NEDepthwiseConvolutionLayer3x3Kernel</li>
</ul>
</li>
<li>Added support for split sizes in:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_split.xhtml">CLSplit</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_split.xhtml">NESplit</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_fill.xhtml">CLFill</a></li>
<li>CLGEMMLowpQuantizeDownInt32ToInt8ScaleByFixedPointKernel / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_to_int8_scale_by_fixed_point.xhtml">CLGEMMLowpQuantizeDownInt32ToInt8ScaleByFixedPoint</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_fill.xhtml">NEFill</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_int8_scale_by_fixed_point_kernel.xhtml">NEGEMMLowpQuantizeDownInt32ToInt8ScaleByFixedPointKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_int8_scale_by_fixed_point.xhtml">NEGEMMLowpQuantizeDownInt32ToInt8ScaleByFixedPoint</a></li>
</ul>
</li>
<li>Deprecated NEON functions / interfaces:<ul>
<li>CLDepthwiseConvolutionLayer3x3</li>
<li>NEDepthwiseConvolutionLayerOptimized</li>
<li><a class="el" href="structarm__compute_1_1_pooling_layer_info.xhtml" title="Pooling Layer Information struct.">PoolingLayerInfo</a> constructors without Data Layout.</li>
</ul>
</li>
<li>Added support for quantization with multiplier greater than 1 on NEON and CL.</li>
<li>Added support for quantized inputs of type QASYMM8_SIGNED and QASYMM8 to <a class="el" href="classarm__compute_1_1_c_l_quantization_layer.xhtml">CLQuantizationLayer</a>.</li>
<li>Added the ability to build bootcode for bare metal.</li>
<li>Added support for generating synthetic QASYMM8 graphs.</li>
<li>Added support for F16 datatype in VGG16.</li>
<li>Removed pre-built binaries for GLES.</li>
</ul>
<p>v19.11.1 Public maintenance release</p><ul>
<li>Fix offset calculation in <a class="el" href="classarm__compute_1_1_n_e_reduction_operation_kernel.xhtml" title="NEON kernel to perform a reduction operation.">NEReductionOperationKernel</a>.</li>
<li>Fix data layout in <a class="el" href="classarm__compute_1_1_n_e_scale_kernel.xhtml" title="NEON kernel to perform scaling on a tensor.">NEScaleKernel</a> for nhwc.</li>
<li>Retain configuration step data layout to avoid side-effects.</li>
<li>Perform sqrt in double domain for L2 pooling.</li>
<li>Fix output shape calculation for Reduce Mean</li>
<li>Restrict cases where optimized <a class="el" href="classarm__compute_1_1_n_e_pad_layer.xhtml" title="Basic function to pad a tensor.">NEPadLayer</a> runs.</li>
</ul>
<p>v19.11 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>Updated recommended NDK version to r17c.</li>
<li>Deprecated OpenCL kernels / functions:<ul>
<li>CLDepthwiseConvolutionLayerReshapeWeightsGenericKernel</li>
<li>CLDepthwiseIm2ColKernel</li>
<li>CLDepthwiseSeparableConvolutionLayer</li>
<li>CLDepthwiseVectorToTensorKernel</li>
<li>CLDirectConvolutionLayerOutputStageKernel</li>
</ul>
</li>
<li>Deprecated NEON kernels / functions:<ul>
<li>NEDepthwiseWeightsReshapeKernel</li>
<li>NEDepthwiseIm2ColKernel</li>
<li>NEDepthwiseSeparableConvolutionLayer</li>
<li>NEDepthwiseVectorToTensorKernel</li>
<li>NEDepthwiseConvolutionLayer3x3</li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_instance_normalization_layer_kernel.xhtml">CLInstanceNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_instance_normalization_layer.xhtml">CLInstanceNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer_native_kernel.xhtml">CLDepthwiseConvolutionLayerNativeKernel</a> to replace the old generic depthwise convolution (see Deprecated OpenCL kernels / functions)</li>
<li><a class="el" href="namespacearm__compute.xhtml#aa02883dd85b75a6eb0d4878f266908dd">CLLogSoftmaxLayer</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_bounding_box_transform_kernel.xhtml">NEBoundingBoxTransformKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_bounding_box_transform.xhtml">NEBoundingBoxTransform</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_compute_all_anchors_kernel.xhtml">NEComputeAllAnchorsKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_compute_all_anchors.xhtml">NEComputeAllAnchors</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_detection_post_process_layer.xhtml">NEDetectionPostProcessLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_generate_proposals_layer.xhtml">NEGenerateProposalsLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_instance_normalization_layer_kernel.xhtml">NEInstanceNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_instance_normalization_layer.xhtml">NEInstanceNormalizationLayer</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a4478c830368ed024dc47a2bf48978616">NELogSoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_r_o_i_align_layer_kernel.xhtml">NEROIAlignLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_r_o_i_align_layer.xhtml">NEROIAlignLayer</a></li>
</ul>
</li>
<li>Added QASYMM8 support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_generate_proposals_layer.xhtml">CLGenerateProposalsLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_r_o_i_align_layer.xhtml">CLROIAlignLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_box_with_non_maxima_suppression_limit.xhtml">CPPBoxWithNonMaximaSuppressionLimit</a></li>
</ul>
</li>
<li>Added QASYMM16 support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_bounding_box_transform.xhtml">CLBoundingBoxTransform</a></li>
</ul>
</li>
<li>Added FP16 support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_reshaped_kernel.xhtml">CLGEMMMatrixMultiplyReshapedKernel</a></li>
</ul>
</li>
<li>Added new data type QASYMM8_PER_CHANNEL support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_dequantization_layer.xhtml">CLDequantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_dequantization_layer.xhtml">NEDequantizationLayer</a></li>
</ul>
</li>
<li>Added new data type QSYMM8_PER_CHANNEL support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_convolution_layer.xhtml">NEConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer.xhtml">NEDepthwiseConvolutionLayer</a></li>
</ul>
</li>
<li>Added FP16 mixed-precision support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_reshaped_kernel.xhtml">CLGEMMMatrixMultiplyReshapedKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_pooling_layer_kernel.xhtml">CLPoolingLayerKernel</a></li>
</ul>
</li>
<li>Added FP32 and FP16 ELU activation for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_activation_layer.xhtml">CLActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_activation_layer.xhtml">NEActivationLayer</a></li>
</ul>
</li>
<li>Added asymmetric padding support for:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_direct_deconvolution_layer.xhtml">CLDirectDeconvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_deconvolution_layer.xhtml">CLGEMMDeconvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_deconvolution_layer.xhtml">NEDeconvolutionLayer</a></li>
</ul>
</li>
<li>Added SYMMETRIC and REFLECT modes for <a class="el" href="classarm__compute_1_1_c_l_pad_layer_kernel.xhtml">CLPadLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_pad_layer.xhtml">CLPadLayer</a>.</li>
<li>Replaced the calls to <a class="el" href="classarm__compute_1_1_n_e_copy_kernel.xhtml">NECopyKernel</a> and <a class="el" href="classarm__compute_1_1_n_e_memset_kernel.xhtml">NEMemsetKernel</a> with <a class="el" href="classarm__compute_1_1_n_e_pad_layer.xhtml">NEPadLayer</a> in <a class="el" href="classarm__compute_1_1_n_e_generate_proposals_layer.xhtml">NEGenerateProposalsLayer</a>.</li>
<li>Replaced the calls to <a class="el" href="classarm__compute_1_1_c_l_copy_kernel.xhtml">CLCopyKernel</a> and <a class="el" href="classarm__compute_1_1_c_l_memset_kernel.xhtml">CLMemsetKernel</a> with <a class="el" href="classarm__compute_1_1_c_l_pad_layer.xhtml">CLPadLayer</a> in <a class="el" href="classarm__compute_1_1_c_l_generate_proposals_layer.xhtml">CLGenerateProposalsLayer</a>.</li>
<li>Improved performance for CL Inception V3 - FP16.</li>
<li>Improved accuracy for CL Inception V3 - FP16 by enabling FP32 accumulator (mixed-precision).</li>
<li>Improved NEON performance by enabling fusing batch normalization with convolution and depth-wise convolution layer.</li>
<li>Improved NEON performance for MobileNet-SSD by improving the output detection performance.</li>
<li>Optimized <a class="el" href="classarm__compute_1_1_c_l_pad_layer.xhtml">CLPadLayer</a>.</li>
<li>Optimized CL generic depthwise convolution layer by introducing <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer_native_kernel.xhtml">CLDepthwiseConvolutionLayerNativeKernel</a>.</li>
<li>Reduced memory consumption by implementing weights sharing.</li>
</ul>
<p>v19.08.1 Public maintenance release</p><ul>
<li>Fix offset calculation in <a class="el" href="classarm__compute_1_1_n_e_reduction_operation_kernel.xhtml" title="NEON kernel to perform a reduction operation.">NEReductionOperationKernel</a>.</li>
<li>Fix data layout in <a class="el" href="classarm__compute_1_1_n_e_scale_kernel.xhtml" title="NEON kernel to perform scaling on a tensor.">NEScaleKernel</a> for nhwc.</li>
<li>Retain configuration step data layout to avoid side-effects.</li>
<li>Perform sqrt in double domain for L2 pooling.</li>
<li>Fix output shape calculation for Reduce Mean</li>
<li>Fix broadcast CLPixelwiseMultiplication with 5D tensors</li>
</ul>
<p>v19.08 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>Deprecated NEON functions<ul>
<li>NEDepthConcatenateLayer</li>
<li>NEWidthConcatenateLayer</li>
</ul>
</li>
<li>Deprecated OpenCL kernels / functions<ul>
<li>CLDepthConcatenateLayer</li>
<li>CLGEMMInterleave4x4Kernel / CLGEMMInterleave4x4</li>
<li>CLGEMMTranspose1xWKernel / CLGEMMTranspose1xW</li>
<li>CLWidthConcatenateLayer</li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_abs_layer.xhtml">NEAbsLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_cast.xhtml">NECast</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_power.xhtml">NEElementwisePower</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_log_layer.xhtml">NELogLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_l_s_t_m_layer_quantized.xhtml">NELSTMLayerQuantized</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_neg_layer.xhtml">NENegLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_p_relu_layer.xhtml">NEPReluLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_sin_layer.xhtml">NESinLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_batch_concatenate_layer_kernel.xhtml">NEBatchConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depth_to_space_layer_kernel.xhtml">NEDepthToSpaceLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_depth_to_space_layer.xhtml">NEDepthToSpaceLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer_native_kernel.xhtml">NEDepthwiseConvolutionLayerNativeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_int16_scale_by_fixed_point_kernel.xhtml">NEGEMMLowpQuantizeDownInt32ToInt16ScaleByFixedPointKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_mean_std_dev_normalization_kernel.xhtml">NEMeanStdDevNormalizationKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_mean_std_dev_normalization_layer.xhtml">NEMeanStdDevNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_space_to_depth_layer_kernel.xhtml">NESpaceToDepthLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_space_to_depth_layer.xhtml">NESpaceToDepthLayer</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_abs_layer.xhtml">CLAbsLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_elementwise_power.xhtml">CLElementwisePower</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_log_layer.xhtml">CLLogLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_l_s_t_m_layer_quantized.xhtml">CLLSTMLayerQuantized</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_neg_layer.xhtml">CLNegLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_p_relu_layer.xhtml">CLPReluLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_sin_layer.xhtml">CLSinLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_batch_concatenate_layer_kernel.xhtml">CLBatchConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depth_to_space_layer_kernel.xhtml">CLDepthToSpaceLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_depth_to_space_layer.xhtml">CLDepthToSpaceLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_native_kernel.xhtml">CLGEMMLowpMatrixMultiplyNativeKernel</a></li>
<li>CLGEMMLowpQuantizeDownInt32ToInt16ScaleByFixedPointKernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_native_kernel.xhtml">CLGEMMMatrixMultiplyNativeKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_mean_std_dev_normalization_kernel.xhtml">CLMeanStdDevNormalizationKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_mean_std_dev_normalization_layer.xhtml">CLMeanStdDevNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_space_to_depth_layer_kernel.xhtml">CLSpaceToDepthLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_space_to_depth_layer.xhtml">CLSpaceToDepthLayer</a></li>
</ul>
</li>
<li>New examples:<ul>
<li>neon_opticalflow</li>
<li>cl_cache</li>
<li>neon_permute</li>
</ul>
</li>
<li>Added support for FP16 in <a class="el" href="classarm__compute_1_1_n_e_deconvolution_layer.xhtml">NEDeconvolutionLayer</a></li>
<li>Added support for FP16 in <a class="el" href="classarm__compute_1_1_c_l_deconvolution_layer.xhtml">CLDeconvolutionLayer</a></li>
<li>Added support for REDUCE_MIN and REDUCE_MAX in <a class="el" href="namespacearm__compute.xhtml#a5827eb9cb394e74af87f74bd354fb45b">ReductionOperation</a></li>
<li>Enable the fusion of batch normalization with convolution and depthwise convolution layer for FP32 in the graph API (OpenCL only)</li>
<li>Added support for fusing activation function and broadcast addition with the matrix multiplication for FP32 (OpenCL only)</li>
<li>Re-factored the depthwise convolution layer kernel on NEON for generic cases</li>
<li>Added an optimized depthwise convolution layer kernel for 5x5 filters (NEON only)</li>
<li>Added support to enable OpenCL kernel cache. Added example showing how to load the prebuilt OpenCL kernels from a binary cache file</li>
<li>Altered <a class="el" href="classarm__compute_1_1_quantization_info.xhtml">QuantizationInfo</a> interface to support per-channel quantization.</li>
<li>The CLDepthwiseConvolutionLayer3x3 will be included by <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a> to accommodate for future optimizations.</li>
<li>The NEDepthwiseConvolutionLayerOptimized will be included by <a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer.xhtml">NEDepthwiseConvolutionLayer</a> to accommodate for future optimizations.</li>
<li>Removed inner_border_right and inner_border_top parameters from <a class="el" href="classarm__compute_1_1_c_l_deconvolution_layer.xhtml">CLDeconvolutionLayer</a> interface</li>
<li>Removed inner_border_right and inner_border_top parameters from <a class="el" href="classarm__compute_1_1_n_e_deconvolution_layer.xhtml">NEDeconvolutionLayer</a> interface</li>
<li>Optimized the NEON assembly kernel for GEMMLowp. The new implementation fuses the output stage and quantization with the matrix multiplication kernel</li>
</ul>
<p>v19.05 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>New Neon kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_batch_to_space_layer_kernel.xhtml">NEBatchToSpaceLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_batch_to_space_layer.xhtml">NEBatchToSpaceLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_complex_pixel_wise_multiplication_kernel.xhtml">NEComplexPixelWiseMultiplicationKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_complex_pixel_wise_multiplication.xhtml">NEComplexPixelWiseMultiplication</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_crop_kernel.xhtml">NECropKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_crop_resize.xhtml">NECropResize</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_assembly_dispatch.xhtml">NEDepthwiseConvolutionAssemblyDispatch</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_f_f_t_digit_reverse_kernel.xhtml">NEFFTDigitReverseKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_f_f_t_radix_stage_kernel.xhtml">NEFFTRadixStageKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_f_f_t_scale_kernel.xhtml">NEFFTScaleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_offset_contribution_output_stage_kernel.xhtml">NEGEMMLowpOffsetContributionOutputStageKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_height_concatenate_layer_kernel.xhtml">NEHeightConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_space_to_batch_layer_kernel.xhtml">NESpaceToBatchLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_space_to_batch_layer.xhtml">NESpaceToBatchLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_f_f_t1_d.xhtml">NEFFT1D</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_f_f_t2_d.xhtml">NEFFT2D</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_f_f_t_convolution_layer.xhtml">NEFFTConvolutionLayer</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_complex_pixel_wise_multiplication_kernel.xhtml">CLComplexPixelWiseMultiplicationKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_complex_pixel_wise_multiplication.xhtml">CLComplexPixelWiseMultiplication</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_crop_kernel.xhtml">CLCropKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_crop_resize.xhtml">CLCropResize</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_deconvolution_reshape_output_kernel.xhtml">CLDeconvolutionReshapeOutputKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_f_f_t_digit_reverse_kernel.xhtml">CLFFTDigitReverseKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_f_f_t_radix_stage_kernel.xhtml">CLFFTRadixStageKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_f_f_t_scale_kernel.xhtml">CLFFTScaleKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_reshaped_only_r_h_s_kernel.xhtml">CLGEMMLowpMatrixMultiplyReshapedOnlyRHSKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_reshaped_only_r_h_s_kernel.xhtml">CLGEMMMatrixMultiplyReshapedOnlyRHSKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_height_concatenate_layer_kernel.xhtml">CLHeightConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_direct_deconvolution_layer.xhtml">CLDirectDeconvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_f_f_t1_d.xhtml">CLFFT1D</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_f_f_t2_d.xhtml">CLFFT2D</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_f_f_t_convolution_layer.xhtml">CLFFTConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_deconvolution_layer.xhtml">CLGEMMDeconvolutionLayer</a></li>
</ul>
</li>
<li>New OpenGLES kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_g_c_concatenate_layer.xhtml">GCConcatenateLayer</a></li>
</ul>
</li>
<li>Deprecated functions/interfaces<ul>
<li>GCDepthConcatenateLayer</li>
<li>NEWidthConcatenateLayer</li>
<li>NEDepthConcatenateLayer</li>
<li>CLWidthConcatenateLayer</li>
<li>CLDepthConcatenateLayer</li>
<li>CLGEMMInterleave4x4</li>
<li>CLGEMMTranspose1xW</li>
</ul>
</li>
<li>Support different quantization info in CLConcatLayer.</li>
<li>Add checks on different input/output quantization info were not supported.</li>
<li>Tensors have different quantization information.</li>
<li>Add FP16 support checks.</li>
<li>Fix output quantization CLDeptwiseConv3x3 when activation is fused.</li>
<li>New graph examples:<ul>
<li>graph_convolution</li>
<li>graph_fully_connected</li>
<li>graph_depthwise_convolution</li>
<li>Deepspeech v0.4.1</li>
</ul>
</li>
<li>Add support for QASYMM8 in <a class="el" href="classarm__compute_1_1_n_e_arithmetic_subtraction_kernel.xhtml" title="Interface for the kernel to perform subtraction between two tensors.">NEArithmeticSubtractionKernel</a>.</li>
<li>Add support for QASYMM8 in <a class="el" href="classarm__compute_1_1_n_e_pixel_wise_multiplication_kernel.xhtml" title="Interface for the kernel to perform addition between two tensors.">NEPixelWiseMultiplicationKernel</a>.</li>
<li>Add support for QASYMM8 NEDeconvolution.</li>
<li>Add support for DequantizationLayer for NEON/CL.</li>
<li>Add support for dilation in CLDepthwiseConvolution.</li>
<li>Fuse offset contribution with the output stage when we use <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_multiply_core.xhtml" title="Basic function to execute GEMMLowpMatrixMultiplyCore on NEON.">NEGEMMLowpMatrixMultiplyCore</a>.</li>
<li>Optimize CLDeconvolution.</li>
<li>Add StackLayer to the graph API.</li>
<li>Add support for "reflect" padding mode in NEPad.</li>
<li>Winograd 7x7 NHWC on OpenCL.</li>
<li>Rework CL ML layers to run exclusively on CL.</li>
<li>Support different quantization info in PoolingLayer.</li>
<li>Implement and test import memory interfaces.</li>
<li>Added new tests and removed old ones.</li>
<li>Various clang-tidy fixes.</li>
</ul>
<p>v19.02 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>New Neon kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_tile_kernel.xhtml">NETileKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_tile.xhtml">NETile</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_fuse_batch_normalization_kernel.xhtml">NEFuseBatchNormalizationKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_fuse_batch_normalization.xhtml">NEFuseBatchNormalization</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_operation_kernel.xhtml">NEElementwiseOperationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_max.xhtml">NEElementwiseMax</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_min.xhtml">NEElementwiseMin</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_squared_diff.xhtml">NEElementwiseSquaredDiff</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_select_kernel.xhtml">NESelectKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_select.xhtml">NESelect</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_split.xhtml">NESplit</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_slice.xhtml">NESlice</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_unstack.xhtml">NEUnstack</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_strided_slice_kernel.xhtml">NEStridedSliceKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_strided_slice.xhtml">NEStridedSlice</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_unary_kernel.xhtml">NEElementwiseUnaryKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_rsqrt_layer.xhtml">NERsqrtLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_exp_layer.xhtml">NEExpLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reverse_kernel.xhtml">NEReverseKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_reverse.xhtml">NEReverse</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_arg_min_max_layer.xhtml">NEArgMinMaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_stack_layer_kernel.xhtml">NEStackLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_stack_layer.xhtml">NEStackLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_range_kernel.xhtml">NERangeKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_range.xhtml">NERange</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pad_layer.xhtml">NEPadLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_memset_kernel.xhtml">NEMemsetKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gather_kernel.xhtml">NEGatherKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_gather.xhtml">NEGather</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_comparison.xhtml">NEElementwiseComparison</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_comparison_static.xhtml">NEElementwiseComparisonStatic</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_comparison_operation_kernel.xhtml">NEComparisonOperationKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_elementwise_division.xhtml">NEElementwiseDivision</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_select_kernel.xhtml">CLSelectKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_select.xhtml">CLSelect</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_tile_kernel.xhtml">CLTileKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_tile.xhtml">CLTile</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_comparison_kernel.xhtml">CLComparisonKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_comparison.xhtml">CLComparison</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_arg_min_max_layer.xhtml">CLArgMinMaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_elementwise_max.xhtml">CLElementwiseMax</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_elementwise_min.xhtml">CLElementwiseMin</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_elementwise_squared_diff.xhtml">CLElementwiseSquaredDiff</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_stack_layer_kernel.xhtml">CLStackLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_stack_layer.xhtml">CLStackLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reverse.xhtml">CLReverse</a> / <a class="el" href="classarm__compute_1_1_c_l_reverse_kernel.xhtml">CLReverseKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_rsqrt_layer.xhtml">CLRsqrtLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_exp_layer.xhtml">CLExpLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_element_wise_unary_layer_kernel.xhtml">CLElementWiseUnaryLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_reshape_l_h_s_matrix_kernel.xhtml">CLGEMMReshapeLHSMatrixKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_reshape_r_h_s_matrix_kernel.xhtml">CLGEMMReshapeRHSMatrixKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_reshaped_kernel.xhtml">CLGEMMMatrixMultiplyReshapedKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_range_kernel.xhtml">CLRangeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_range.xhtml">CLRange</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_unstack.xhtml">CLUnstack</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gather_kernel.xhtml">CLGatherKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_gather.xhtml">CLGather</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_reshaped_kernel.xhtml">CLGEMMLowpMatrixMultiplyReshapedKernel</a></li>
</ul>
</li>
<li>New CPP kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_p_p_detection_output_layer.xhtml">CPPDetectionOutputLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_p_p_top_k_v.xhtml">CPPTopKV</a> / <a class="el" href="classarm__compute_1_1_c_p_p_top_k_v_kernel.xhtml">CPPTopKVKernel</a></li>
</ul>
</li>
<li>Added new examples:<ul>
<li><a class="el" href="graph__ssd__mobilenet_8cpp.xhtml">graph_ssd_mobilenet.cpp</a></li>
<li><a class="el" href="graph__mobilenet__v2_8cpp.xhtml">graph_mobilenet_v2.cpp</a></li>
<li><a class="el" href="graph__resnet12_8cpp.xhtml">graph_resnet12.cpp</a></li>
<li><a class="el" href="graph__srcnn955_8cpp.xhtml">graph_srcnn955.cpp</a></li>
<li><a class="el" href="graph__vgg__vdsr_8cpp.xhtml">graph_vgg_vdsr.cpp</a></li>
<li><a class="el" href="graph__inception__resnet__v1_8cpp.xhtml">graph_inception_resnet_v1.cpp</a></li>
</ul>
</li>
<li>Add 4D tensors support to<ul>
<li><a class="el" href="namespacearm__compute.xhtml#a4df2143ca0a3bdbbbc54b440a52541cd">NESoftmaxLayer</a></li>
</ul>
</li>
<li>Fused activation in <a class="el" href="classarm__compute_1_1_c_l_winograd_convolution_layer.xhtml">CLWinogradConvolutionLayer</a></li>
<li>Extented <a class="el" href="classarm__compute_1_1_n_e_permute.xhtml">NEPermute</a> to support more cases</li>
<li>Added NEON/SVE GEMM Hybrid kernels</li>
<li>Added u8 and s8 hybrid assembly kernels</li>
<li>Introduced GEMM strategy name in NEGEMMAssemblyWrapper</li>
<li>Improved <a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml">CLTuner</a></li>
<li>Fused the bias addition within <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m.xhtml">CLGEMM</a></li>
<li>Added support for QASYMM8 LOGISTIC activation in <a class="el" href="classarm__compute_1_1_n_e_activation_layer.xhtml">NEActivationLayer</a></li>
<li>Added NHWC data layout support to:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_scale.xhtml">NEScale</a> for F16</li>
<li><a class="el" href="classarm__compute_1_1_c_l_normalization_layer.xhtml">CLNormalizationLayer</a> IN_MAP_2D for FP32/FP16</li>
<li><a class="el" href="classarm__compute_1_1_n_e_l2_normalize_layer.xhtml">NEL2NormalizeLayer</a> for FP32/FP16</li>
<li><a class="el" href="classarm__compute_1_1_n_e_normalization_layer.xhtml">NENormalizationLayer</a> IN_MAP_2D for FP32/FP16</li>
<li><a class="el" href="classarm__compute_1_1_c_l_r_o_i_align_layer.xhtml">CLROIAlignLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_generate_proposals_layer.xhtml">CLGenerateProposalsLayer</a></li>
</ul>
</li>
<li>Added QASYMM8 support to the following kernels:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_arithmetic_addition_kernel.xhtml">NEArithmeticAdditionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_scale.xhtml">NEScale</a></li>
</ul>
</li>
<li>Added new tests and improved validation and benchmarking suites.</li>
<li>Deprecated functions/interfaces<ul>
<li>Usage of inner_border_right and inner_border_top has been deprecated in <a class="el" href="classarm__compute_1_1_c_l_deconvolution_layer.xhtml">CLDeconvolutionLayer</a> and <a class="el" href="classarm__compute_1_1_n_e_deconvolution_layer.xhtml">NEDeconvolutionLayer</a></li>
</ul>
</li>
</ul>
<p>v18.11 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>New Neon kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_channel_shuffle_layer.xhtml">NEChannelShuffleLayer</a> / <a class="el" href="classarm__compute_1_1_n_e_channel_shuffle_layer_kernel.xhtml">NEChannelShuffleLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reduce_mean.xhtml">NEReduceMean</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reorg_layer.xhtml">NEReorgLayer</a> / <a class="el" href="classarm__compute_1_1_n_e_reorg_layer_kernel.xhtml">NEReorgLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_prior_box_layer.xhtml">NEPriorBoxLayer</a> / <a class="el" href="classarm__compute_1_1_n_e_prior_box_layer_kernel.xhtml">NEPriorBoxLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_upsample_layer.xhtml">NEUpsampleLayer</a> / <a class="el" href="classarm__compute_1_1_n_e_upsample_layer_kernel.xhtml">NEUpsampleLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_y_o_l_o_layer.xhtml">NEYOLOLayer</a> / <a class="el" href="classarm__compute_1_1_n_e_y_o_l_o_layer_kernel.xhtml">NEYOLOLayerKernel</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_batch_to_space_layer.xhtml">CLBatchToSpaceLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_batch_to_space_layer_kernel.xhtml">CLBatchToSpaceLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_bounding_box_transform.xhtml">CLBoundingBoxTransform</a> / <a class="el" href="classarm__compute_1_1_c_l_bounding_box_transform_kernel.xhtml">CLBoundingBoxTransformKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_compute_all_anchors_kernel.xhtml">CLComputeAllAnchorsKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_generate_proposals_layer.xhtml">CLGenerateProposalsLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_normalize_planar_y_u_v_layer.xhtml">CLNormalizePlanarYUVLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_normalize_planar_y_u_v_layer_kernel.xhtml">CLNormalizePlanarYUVLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reorg_layer.xhtml">CLReorgLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_reorg_layer_kernel.xhtml">CLReorgLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_space_to_batch_layer.xhtml">CLSpaceToBatchLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_space_to_batch_layer_kernel.xhtml">CLSpaceToBatchLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_pad_layer.xhtml">CLPadLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reduce_mean.xhtml">CLReduceMean</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_prior_box_layer.xhtml">CLPriorBoxLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_prior_box_layer_kernel.xhtml">CLPriorBoxLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_r_o_i_align_layer.xhtml">CLROIAlignLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_r_o_i_align_layer_kernel.xhtml">CLROIAlignLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_slice.xhtml">CLSlice</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_split.xhtml">CLSplit</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_strided_slice.xhtml">CLStridedSlice</a> / <a class="el" href="classarm__compute_1_1_c_l_strided_slice_kernel.xhtml">CLStridedSliceKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_upsample_layer.xhtml">CLUpsampleLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_upsample_layer_kernel.xhtml">CLUpsampleLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_y_o_l_o_layer.xhtml">CLYOLOLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_y_o_l_o_layer_kernel.xhtml">CLYOLOLayerKernel</a></li>
</ul>
</li>
<li>New CPP kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_p_p_box_with_non_maxima_suppression_limit.xhtml">CPPBoxWithNonMaximaSuppressionLimit</a> / <a class="el" href="classarm__compute_1_1_c_p_p_box_with_non_maxima_suppression_limit_kernel.xhtml">CPPBoxWithNonMaximaSuppressionLimitKernel</a></li>
</ul>
</li>
<li>Added the validate method in:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_depth_convert_layer.xhtml">NEDepthConvertLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_floor.xhtml">NEFloor</a> / <a class="el" href="classarm__compute_1_1_c_l_floor.xhtml">CLFloor</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_addition_kernel.xhtml">NEGEMMMatrixAdditionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reshape_layer.xhtml">NEReshapeLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_reshape_layer.xhtml">CLReshapeLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_scale.xhtml">CLScale</a></li>
</ul>
</li>
<li>Added new examples:<ul>
<li><a class="el" href="graph__shufflenet_8cpp.xhtml">graph_shufflenet.cpp</a></li>
<li><a class="el" href="graph__yolov3_8cpp.xhtml">graph_yolov3.cpp</a></li>
</ul>
</li>
<li>Added documentation for add a new function or kernel.</li>
<li>Improved doxygen documentation adding a list of the existing functions.</li>
<li>Add 4D tensors support to<ul>
<li>CLWidthConcatenateLayer</li>
<li><a class="el" href="classarm__compute_1_1_c_l_flatten_layer.xhtml">CLFlattenLayer</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a30ce3b40394b4f2d1e4cc31db7183425">CLSoftmaxLayer</a></li>
</ul>
</li>
<li>Add dot product support for <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3_n_h_w_c_kernel.xhtml">CLDepthwiseConvolutionLayer3x3NHWCKernel</a> non-unit stride</li>
<li>Add SVE support</li>
<li>Fused batch normalization into convolution layer weights in <a class="el" href="classarm__compute_1_1_c_l_fuse_batch_normalization.xhtml">CLFuseBatchNormalization</a></li>
<li>Fuses activation in <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3_n_c_h_w_kernel.xhtml">CLDepthwiseConvolutionLayer3x3NCHWKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3_n_h_w_c_kernel.xhtml">CLDepthwiseConvolutionLayer3x3NHWCKernel</a> and <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_convolution_layer.xhtml">NEGEMMConvolutionLayer</a></li>
<li>Added NHWC data layout support to:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_shuffle_layer.xhtml">CLChannelShuffleLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_deconvolution_layer.xhtml">CLDeconvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_l2_normalize_layer.xhtml">CLL2NormalizeLayer</a></li>
</ul>
</li>
<li>Added QASYMM8 support to the following kernels:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_scale_kernel.xhtml">CLScaleKernel</a></li>
<li>NEDepthwiseConvolutionLayer3x3Kernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_pixel_wise_multiplication_kernel.xhtml">CLPixelWiseMultiplicationKernel</a></li>
</ul>
</li>
<li>Added FP16 support to the following kernels:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3_n_h_w_c_kernel.xhtml">CLDepthwiseConvolutionLayer3x3NHWCKernel</a></li>
<li>NEDepthwiseConvolutionLayer3x3Kernel</li>
<li><a class="el" href="classarm__compute_1_1_c_l_normalize_planar_y_u_v_layer_kernel.xhtml">CLNormalizePlanarYUVLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_winograd_convolution_layer.xhtml">CLWinogradConvolutionLayer</a> (5x5 kernel)</li>
</ul>
</li>
<li>More tests added to both validation and benchmarking suites.</li>
</ul>
<p>v18.08 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>Updated recommended NDK version to r17b.</li>
<li>Removed support for QS8/QS16 data types.</li>
<li>Added support for grouped convolution in <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a>.</li>
<li>Added NHWC data layout support to:<ul>
<li>NEDepthConcatenateLayer / CLDepthConcatenateLayer</li>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_convolution_layer.xhtml">NEWinogradConvolutionLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_winograd_convolution_layer.xhtml">CLWinogradConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_direct_convolution_layer.xhtml">CLDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_scale.xhtml">CLScale</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_im2_col_kernel.xhtml">CLIm2ColKernel</a></li>
</ul>
</li>
<li>New Neon kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_r_n_n_layer.xhtml">NERNNLayer</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_arithmetic_division.xhtml">CLArithmeticDivision</a></li>
</ul>
</li>
<li>Introduced prepare() stage support in the graph API for GLES.</li>
<li>Added support for memory reusage when trying to allocate smaller CLTensors.</li>
<li>Enabled NHWC execution on graph examples.</li>
<li>Added JPEG accessor for validation purposes.</li>
<li>Added validate methods to some kernels / functions.</li>
</ul>
<p>v18.05 Public major release</p><ul>
<li>Various bug fixes.</li>
<li>Various optimisations.</li>
<li>Major redesign in the interface for the neon kernels implemented in assembly.</li>
<li>Removed arm_compute::NEGEMMLowpAArch64A53Kernel / arm_compute::NEGEMMLowpAArch64Kernel / arm_compute::NEGEMMLowpAArch64V8P4Kernel / arm_compute::NEGEMMInterleavedBlockedKernel / arm_compute::NEGEMMLowpAssemblyMatrixMultiplyCore / arm_compute::NEHGEMMAArch64FP16Kernel</li>
<li>Added NEGEMMAssemblyWrapper and AssemblyKernelGlue which are used to execute assembly kernels in neon functions.</li>
<li>Minor changes to the <a class="el" href="classarm__compute_1_1_c_p_u_info.xhtml">CPUInfo</a> type to make it compatible with the new assembly gemm interface.</li>
<li>Moved neon assembly kernels to the folder src/core/NEON/kernels/arm_gemm.</li>
<li>Improved doxygen documentation.</li>
<li>Improved memory management for layer's transitions.</li>
<li>Added support for NHWC data layout in tensors.</li>
<li>Added NHWC data layout support to:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_convolution_layer.xhtml">NEGEMMConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer.xhtml">NEDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pooling_layer.xhtml">NEPoolingLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_pooling_layer.xhtml">CLPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_batch_normalization_layer.xhtml">NEBatchNormalizationLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer.xhtml">CLBatchNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer.xhtml">NEDepthwiseConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_scale.xhtml">NEScale</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_im2_col.xhtml">NEIm2Col</a></li>
</ul>
</li>
<li>Added support for dilated convolutions in <a class="el" href="classarm__compute_1_1_n_e_convolution_layer.xhtml">NEConvolutionLayer</a> and <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a>.</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_shuffle_layer.xhtml">CLChannelShuffleLayer</a> / <a class="el" href="classarm__compute_1_1_c_l_channel_shuffle_layer_kernel.xhtml">CLChannelShuffleLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_convert_fully_connected_weights_kernel.xhtml">CLConvertFullyConnectedWeightsKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_convert_fully_connected_weights.xhtml">CLConvertFullyConnectedWeights</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_copy.xhtml">CLCopy</a> / <a class="el" href="classarm__compute_1_1_c_l_copy_kernel.xhtml">CLCopyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_l_s_t_m_layer.xhtml">CLLSTMLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_r_n_n_layer.xhtml">CLRNNLayer</a></li>
<li>CLWidthConcatenateLayer / <a class="el" href="classarm__compute_1_1_c_l_width_concatenate_layer_kernel.xhtml">CLWidthConcatenateLayerKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_winograd_filter_transform_kernel.xhtml">CLWinogradFilterTransformKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_winograd_input_transform_kernel.xhtml">CLWinogradInputTransformKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_winograd_convolution_layer.xhtml">CLWinogradConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_winograd_input_transform_kernel.xhtml">CLWinogradInputTransformKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_winograd_input_transform.xhtml">CLWinogradInputTransform</a></li>
</ul>
</li>
<li>New Neon kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_convert_fully_connected_weights_kernel.xhtml">NEConvertFullyConnectedWeightsKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_convert_fully_connected_weights.xhtml">NEConvertFullyConnectedWeights</a>.</li>
</ul>
</li>
<li>Created the validate method in <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a>.</li>
<li>Beta and gamma are no longer mandatory arguments in <a class="el" href="classarm__compute_1_1_n_e_batch_normalization_layer.xhtml">NEBatchNormalizationLayer</a> and <a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer.xhtml">CLBatchNormalizationLayer</a>.</li>
<li>Added depth multiplier support in <a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer.xhtml">NEDepthwiseConvolutionLayer</a> and <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a>.</li>
<li>Added broadcast multiply support in <a class="el" href="classarm__compute_1_1_n_e_pixel_wise_multiplication.xhtml">NEPixelWiseMultiplication</a> / <a class="el" href="classarm__compute_1_1_n_e_pixel_wise_multiplication_kernel.xhtml">NEPixelWiseMultiplicationKernel</a>.</li>
<li>Port mobilenet example to NHWC data layout.</li>
<li>Enabled Winograd method in <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a>.</li>
<li>Renamed NEWinogradLayer to <a class="el" href="classarm__compute_1_1_n_e_winograd_convolution_layer.xhtml">NEWinogradConvolutionLayer</a>.</li>
<li>Updated <a class="el" href="classarm__compute_1_1_n_e_winograd_convolution_layer.xhtml">NEWinogradConvolutionLayer</a> to use highly optimised assembly kernels in src/core/NEON/kernels/arm_gemm.</li>
<li>Added memory manager support in GLES functions.</li>
<li>Major refactoring of the graph API.</li>
<li>Added GLES backend in the graph API.</li>
<li>Added support for the memory manager in the graph API.</li>
<li>Enabled Winograd Convolution method in the graph API.</li>
<li>Added support for grouped convolutions in the graph API.</li>
<li>Replaced NEDeconvolutionLayerUpsampleKernel with <a class="el" href="classarm__compute_1_1_n_e_scale_kernel.xhtml">NEScaleKernel</a> in <a class="el" href="classarm__compute_1_1_n_e_deconvolution_layer.xhtml">NEDeconvolutionLayer</a>.</li>
<li>Added fast maths flag in <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a>.</li>
<li>Added new tests and benchmarks in validation and benchmark frameworks</li>
<li>Merge Activation layer with Convolution Layer (NEON. CL, GLES)</li>
<li>Added support to OpenCL 2.0 SVM</li>
<li>Added support to import memory in OpenCL tensors.</li>
<li>Added the prepare() method to perform any one off pre-processing before running the function.</li>
<li>Added new examples:<ul>
<li><a class="el" href="graph__inception__v4_8cpp.xhtml">graph_inception_v4.cpp</a></li>
<li><a class="el" href="graph__resnext50_8cpp.xhtml">graph_resnext50.cpp</a></li>
</ul>
</li>
<li>Added memory measurement instrument for CL.</li>
</ul>
<p>v18.03 Public maintenance release</p><ul>
<li>Various bug fixes.</li>
<li>Fixed bug in <a class="el" href="classarm__compute_1_1_n_e_activation_layer.xhtml">NEActivationLayer</a></li>
<li>Fix in <a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml">CLTuner</a> when using batches.</li>
<li>Updated recommended NDK version to r16b (And fixed warnings).</li>
<li>Fixed bug in validation code.</li>
<li>Added Inception v4 graph example.</li>
<li>Renamed NEWinogradLayer.cpp to <a class="el" href="classarm__compute_1_1_n_e_winograd_convolution_layer.xhtml">NEWinogradConvolutionLayer</a></li>
</ul>
<p>v18.02 Public major release</p><ul>
<li>Various NEON / OpenCL / GLES optimisations.</li>
<li>Various bug fixes.</li>
<li>Changed default number of threads on big LITTLE systems.</li>
<li>Refactored examples and added:<ul>
<li>graph_mobilenet_qassym8</li>
<li>graph_resnet</li>
<li>graph_squeezenet_v1_1</li>
</ul>
</li>
<li>Renamed <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a> into <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_convolution_layer.xhtml">CLGEMMConvolutionLayer</a> and created a new <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a> to select the fastest convolution method.</li>
<li>Renamed <a class="el" href="classarm__compute_1_1_n_e_convolution_layer.xhtml">NEConvolutionLayer</a> into <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_convolution_layer.xhtml">NEGEMMConvolutionLayer</a> and created a new <a class="el" href="classarm__compute_1_1_n_e_convolution_layer.xhtml">NEConvolutionLayer</a> to select the fastest convolution method.</li>
<li>Added in place support to:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_activation_layer.xhtml">CLActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer.xhtml">CLBatchNormalizationLayer</a></li>
</ul>
</li>
<li>Added QASYMM8 support to:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_activation_layer.xhtml">CLActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer.xhtml">NEDepthwiseConvolutionLayer</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a4df2143ca0a3bdbbbc54b440a52541cd">NESoftmaxLayer</a></li>
</ul>
</li>
<li>Added FP16 support to:<ul>
<li>CLDepthwiseConvolutionLayer3x3</li>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a></li>
</ul>
</li>
<li>Added broadcasting support to <a class="el" href="classarm__compute_1_1_n_e_arithmetic_addition.xhtml">NEArithmeticAddition</a> / <a class="el" href="classarm__compute_1_1_c_l_arithmetic_addition.xhtml">CLArithmeticAddition</a> / <a class="el" href="classarm__compute_1_1_c_l_pixel_wise_multiplication.xhtml">CLPixelWiseMultiplication</a></li>
<li>Added fused batched normalization and activation to <a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer.xhtml">CLBatchNormalizationLayer</a> and <a class="el" href="classarm__compute_1_1_n_e_batch_normalization_layer.xhtml">NEBatchNormalizationLayer</a></li>
<li>Added support for non-square pooling to <a class="el" href="classarm__compute_1_1_n_e_pooling_layer.xhtml">NEPoolingLayer</a> and <a class="el" href="classarm__compute_1_1_c_l_pooling_layer.xhtml">CLPoolingLayer</a></li>
<li>New OpenCL kernels / functions:<ul>
<li>CLDirectConvolutionLayerOutputStageKernel</li>
</ul>
</li>
<li>New NEON kernels / functions<ul>
<li>Added <a class="el" href="_n_e_activation_layer_kernel_8cpp.xhtml#a8f8f80d37794cde9472343e4487ba3eb">name()</a> method to all kernels.</li>
<li>Added support for Winograd 5x5.</li>
<li><a class="el" href="classarm__compute_1_1_n_e_permute_kernel.xhtml">NEPermuteKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_permute.xhtml">NEPermute</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_layer_transform_input_kernel.xhtml">NEWinogradLayerTransformInputKernel</a> / NEWinogradLayer</li>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_layer_transform_output_kernel.xhtml">NEWinogradLayerTransformOutputKernel</a> / NEWinogradLayer</li>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_layer_transform_weights_kernel.xhtml">NEWinogradLayerTransformWeightsKernel</a> / NEWinogradLayer</li>
<li>Renamed NEWinogradLayerKernel into NEWinogradLayerBatchedGEMMKernel</li>
</ul>
</li>
<li>New GLES kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_g_c_tensor_shift_kernel.xhtml">GCTensorShiftKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_tensor_shift.xhtml">GCTensorShift</a></li>
</ul>
</li>
</ul>
<p>v18.01 Public maintenance release</p><ul>
<li>Various bug fixes</li>
<li>Added some of the missing <a class="el" href="namespacearm__compute.xhtml#a4feaaa70771629f4b5dcf3b219c8b647">validate()</a> methods</li>
<li>Added <a class="el" href="classarm__compute_1_1_c_l_deconvolution_layer_upsample_kernel.xhtml">CLDeconvolutionLayerUpsampleKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_deconvolution_layer.xhtml">CLDeconvolutionLayer</a> <a class="el" href="classarm__compute_1_1_c_l_deconvolution_layer_upsample.xhtml">CLDeconvolutionLayerUpsample</a></li>
<li>Added <a class="el" href="classarm__compute_1_1_c_l_permute_kernel.xhtml">CLPermuteKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_permute.xhtml">CLPermute</a></li>
<li>Added method to clean the programs cache in the CL <a class="el" href="classarm__compute_1_1_kernel.xhtml" title="Kernel class.">Kernel</a> library.</li>
<li>Added <a class="el" href="classarm__compute_1_1_g_c_arithmetic_addition_kernel.xhtml">GCArithmeticAdditionKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_arithmetic_addition.xhtml">GCArithmeticAddition</a></li>
<li>Added <a class="el" href="classarm__compute_1_1_g_c_depthwise_convolution_layer3x3_kernel.xhtml">GCDepthwiseConvolutionLayer3x3Kernel</a> / <a class="el" href="classarm__compute_1_1_g_c_depthwise_convolution_layer3x3.xhtml">GCDepthwiseConvolutionLayer3x3</a></li>
<li>Added <a class="el" href="classarm__compute_1_1_g_c_normalize_planar_y_u_v_layer_kernel.xhtml">GCNormalizePlanarYUVLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_normalize_planar_y_u_v_layer.xhtml">GCNormalizePlanarYUVLayer</a></li>
<li>Added <a class="el" href="classarm__compute_1_1_g_c_scale_kernel.xhtml">GCScaleKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_scale.xhtml">GCScale</a></li>
<li>Added <a class="el" href="classarm__compute_1_1_g_c_weights_reshape_kernel.xhtml">GCWeightsReshapeKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_convolution_layer.xhtml">GCConvolutionLayer</a></li>
<li>Added FP16 support to the following GLES compute kernels:<ul>
<li><a class="el" href="classarm__compute_1_1_g_c_col2_im_kernel.xhtml">GCCol2ImKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_interleave4x4_kernel.xhtml">GCGEMMInterleave4x4Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_transpose1x_w_kernel.xhtml">GCGEMMTranspose1xWKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_im2_col_kernel.xhtml">GCIm2ColKernel</a></li>
</ul>
</li>
<li>Refactored NEON Winograd (NEWinogradLayerKernel)</li>
<li>Added <a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer_output_stage_kernel.xhtml">NEDirectConvolutionLayerOutputStageKernel</a></li>
<li>Added QASYMM8 support to the following NEON kernels:<ul>
<li>NEDepthwiseConvolutionLayer3x3Kernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_fill_border_kernel.xhtml">NEFillBorderKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pooling_layer_kernel.xhtml">NEPoolingLayerKernel</a></li>
</ul>
</li>
<li>Added new examples:<ul>
<li>graph_cl_mobilenet_qasymm8.cpp</li>
<li><a class="el" href="graph__inception__v3_8cpp.xhtml">graph_inception_v3.cpp</a></li>
<li><a class="el" href="gc__dc_8cpp.xhtml">gc_dc.cpp</a></li>
</ul>
</li>
<li>More tests added to both validation and benchmarking suites.</li>
</ul>
<p>v17.12 Public major release</p><ul>
<li>Most machine learning functions on OpenCL support the new data type QASYMM8</li>
<li>Introduced logging interface</li>
<li>Introduced opencl timer</li>
<li>Reworked GEMMLowp interface</li>
<li>Added new NEON assembly kernels for GEMMLowp, SGEMM and HGEMM</li>
<li>Added validation method for most Machine Learning kernels / functions</li>
<li>Added new graph examples such as googlenet, mobilenet, squeezenet, vgg16 and vgg19</li>
<li>Added sgemm example for OpenCL</li>
<li>Added absolute difference example for GLES compute</li>
<li>Added new tests and benchmarks in validation and benchmark frameworks</li>
<li>Added new kernels / functions for GLES compute</li>
<li>New OpenGL ES kernels / functions<ul>
<li><a class="el" href="classarm__compute_1_1_g_c_absolute_difference_kernel.xhtml">GCAbsoluteDifferenceKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_absolute_difference.xhtml">GCAbsoluteDifference</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_activation_layer_kernel.xhtml">GCActivationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_activation_layer.xhtml">GCActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_batch_normalization_layer_kernel.xhtml">GCBatchNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_batch_normalization_layer.xhtml">GCBatchNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_col2_im_kernel.xhtml">GCCol2ImKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_depth_concatenate_layer_kernel.xhtml">GCDepthConcatenateLayerKernel</a> / GCDepthConcatenateLayer</li>
<li><a class="el" href="classarm__compute_1_1_g_c_direct_convolution_layer_kernel.xhtml">GCDirectConvolutionLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_direct_convolution_layer.xhtml">GCDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_dropout_layer_kernel.xhtml">GCDropoutLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_dropout_layer.xhtml">GCDropoutLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_fill_border_kernel.xhtml">GCFillBorderKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_fill_border.xhtml">GCFillBorder</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_interleave4x4_kernel.xhtml">GCGEMMInterleave4x4Kernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_interleave4x4.xhtml">GCGEMMInterleave4x4</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_matrix_accumulate_biases_kernel.xhtml">GCGEMMMatrixAccumulateBiasesKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_matrix_addition_kernel.xhtml">GCGEMMMatrixAdditionKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_matrix_multiply_kernel.xhtml">GCGEMMMatrixMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m.xhtml">GCGEMM</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_transpose1x_w_kernel.xhtml">GCGEMMTranspose1xWKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_transpose1x_w.xhtml">GCGEMMTranspose1xW</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_im2_col_kernel.xhtml">GCIm2ColKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_normalization_layer_kernel.xhtml">GCNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_normalization_layer.xhtml">GCNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_pixel_wise_multiplication_kernel.xhtml">GCPixelWiseMultiplicationKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_pixel_wise_multiplication.xhtml">GCPixelWiseMultiplication</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_pooling_layer_kernel.xhtml">GCPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_pooling_layer.xhtml">GCPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_logits1_d_max_kernel.xhtml">GCLogits1DMaxKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_logits1_d_shift_exp_sum_kernel.xhtml">GCLogits1DShiftExpSumKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_logits1_d_norm_kernel.xhtml">GCLogits1DNormKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_softmax_layer.xhtml">GCSoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_transpose_kernel.xhtml">GCTransposeKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_transpose.xhtml">GCTranspose</a></li>
</ul>
</li>
<li>New NEON kernels / functions<ul>
<li>arm_compute::NEGEMMLowpAArch64A53Kernel / arm_compute::NEGEMMLowpAArch64Kernel / arm_compute::NEGEMMLowpAArch64V8P4Kernel / arm_compute::NEGEMMInterleavedBlockedKernel / arm_compute::NEGEMMLowpAssemblyMatrixMultiplyCore</li>
<li>arm_compute::NEHGEMMAArch64FP16Kernel</li>
<li>NEDepthwiseConvolutionLayer3x3Kernel / NEDepthwiseIm2ColKernel / NEGEMMMatrixVectorMultiplyKernel / NEDepthwiseVectorToTensorKernel / <a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer.xhtml">NEDepthwiseConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_offset_contribution_kernel.xhtml">NEGEMMLowpOffsetContributionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_a_reduction_kernel.xhtml">NEGEMMLowpMatrixAReductionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_b_reduction_kernel.xhtml">NEGEMMLowpMatrixBReductionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_multiply_core.xhtml">NEGEMMLowpMatrixMultiplyCore</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_by_fixed_point_kernel.xhtml">NEGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPointKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_by_fixed_point.xhtml">NEGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPoint</a></li>
<li>NEWinogradLayer / NEWinogradLayerKernel</li>
</ul>
</li>
<li>New OpenCL kernels / functions<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_offset_contribution_kernel.xhtml">CLGEMMLowpOffsetContributionKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_a_reduction_kernel.xhtml">CLGEMMLowpMatrixAReductionKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_b_reduction_kernel.xhtml">CLGEMMLowpMatrixBReductionKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_core.xhtml">CLGEMMLowpMatrixMultiplyCore</a></li>
<li>CLGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPointKernel / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_by_fixed_point.xhtml">CLGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPoint</a></li>
</ul>
</li>
<li>New graph nodes for NEON and OpenCL<ul>
<li>graph::BranchLayer</li>
<li>graph::DepthConvertLayer</li>
<li>graph::DepthwiseConvolutionLayer</li>
<li>graph::DequantizationLayer</li>
<li>graph::FlattenLayer</li>
<li>graph::QuantizationLayer</li>
<li>graph::ReshapeLayer</li>
</ul>
</li>
</ul>
<p>v17.10 Public maintenance release</p><ul>
<li>Bug fixes:<ul>
<li>Check the maximum local workgroup size supported by OpenCL devices</li>
<li>Minor documentation updates (Fixed instructions to build the examples)</li>
<li>Introduced a <a class="el" href="classarm__compute_1_1graph_1_1_graph_context.xhtml" title="Graph context.">graph::GraphContext</a></li>
<li>Added a few new Graph nodes, support for branches and grouping.</li>
<li>Automatically enable cl_printf in debug builds</li>
<li>Fixed bare metal builds for armv7a</li>
<li>Added AlexNet and cartoon effect examples</li>
<li>Fixed library builds: libraries are no longer built as supersets of each other.(It means application using the Runtime part of the library now need to link against both libarm_compute_core and libarm_compute)</li>
</ul>
</li>
</ul>
<p>v17.09 Public major release</p><ul>
<li>Experimental Graph support: initial implementation of a simple stream API to easily chain machine learning layers.</li>
<li><a class="el" href="classarm__compute_1_1_memory.xhtml" title="CPU implementation of memory object.">Memory</a> Manager (<a class="el" href="classarm__compute_1_1_blob_lifetime_manager.xhtml">BlobLifetimeManager</a>, <a class="el" href="classarm__compute_1_1_blob_memory_pool.xhtml">BlobMemoryPool</a>, <a class="el" href="classarm__compute_1_1_i_lifetime_manager.xhtml">ILifetimeManager</a>, <a class="el" href="classarm__compute_1_1_i_memory_group.xhtml">IMemoryGroup</a>, <a class="el" href="classarm__compute_1_1_i_memory_manager.xhtml">IMemoryManager</a>, <a class="el" href="classarm__compute_1_1_i_memory_pool.xhtml">IMemoryPool</a>, <a class="el" href="classarm__compute_1_1_i_pool_manager.xhtml">IPoolManager</a>, <a class="el" href="classarm__compute_1_1_memory_manager_on_demand.xhtml">MemoryManagerOnDemand</a>, <a class="el" href="classarm__compute_1_1_pool_manager.xhtml">PoolManager</a>)</li>
<li>New validation and benchmark frameworks (Boost and Google frameworks replaced by homemade framework).</li>
<li>Most machine learning functions support both fixed point 8 and 16 bit (QS8, QS16) for both NEON and OpenCL.</li>
<li>New NEON kernels / functions:<ul>
<li>arm_compute::NEGEMMAssemblyBaseKernel arm_compute::NEGEMMAArch64Kernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_dequantization_layer_kernel.xhtml">NEDequantizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_dequantization_layer.xhtml">NEDequantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_floor_kernel.xhtml">NEFloorKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_floor.xhtml">NEFloor</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_l2_normalize_layer_kernel.xhtml">NEL2NormalizeLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_l2_normalize_layer.xhtml">NEL2NormalizeLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_quantization_layer_kernel.xhtml">NEQuantizationLayerKernel</a> <a class="el" href="classarm__compute_1_1_n_e_min_max_layer_kernel.xhtml">NEMinMaxLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_quantization_layer.xhtml">NEQuantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_r_o_i_pooling_layer_kernel.xhtml">NEROIPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_r_o_i_pooling_layer.xhtml">NEROIPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reduction_operation_kernel.xhtml">NEReductionOperationKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_reduction_operation.xhtml">NEReductionOperation</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reshape_layer_kernel.xhtml">NEReshapeLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_reshape_layer.xhtml">NEReshapeLayer</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3_n_c_h_w_kernel.xhtml">CLDepthwiseConvolutionLayer3x3NCHWKernel</a> <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3_n_h_w_c_kernel.xhtml">CLDepthwiseConvolutionLayer3x3NHWCKernel</a> CLDepthwiseIm2ColKernel CLDepthwiseVectorToTensorKernel CLDepthwiseWeightsReshapeKernel / CLDepthwiseConvolutionLayer3x3 <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">CLDepthwiseConvolutionLayer</a> CLDepthwiseSeparableConvolutionLayer</li>
<li><a class="el" href="classarm__compute_1_1_c_l_dequantization_layer_kernel.xhtml">CLDequantizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_dequantization_layer.xhtml">CLDequantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_direct_convolution_layer_kernel.xhtml">CLDirectConvolutionLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_direct_convolution_layer.xhtml">CLDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_flatten_layer.xhtml">CLFlattenLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_floor_kernel.xhtml">CLFloorKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_floor.xhtml">CLFloor</a></li>
<li>CLGEMMTranspose1xW</li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_vector_multiply_kernel.xhtml">CLGEMMMatrixVectorMultiplyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_l2_normalize_layer_kernel.xhtml">CLL2NormalizeLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_l2_normalize_layer.xhtml">CLL2NormalizeLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_quantization_layer_kernel.xhtml">CLQuantizationLayerKernel</a> <a class="el" href="classarm__compute_1_1_c_l_min_max_layer_kernel.xhtml">CLMinMaxLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_quantization_layer.xhtml">CLQuantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_r_o_i_pooling_layer_kernel.xhtml">CLROIPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_r_o_i_pooling_layer.xhtml">CLROIPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reduction_operation_kernel.xhtml">CLReductionOperationKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_reduction_operation.xhtml">CLReductionOperation</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reshape_layer_kernel.xhtml">CLReshapeLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_reshape_layer.xhtml">CLReshapeLayer</a></li>
</ul>
</li>
</ul>
<p>v17.06 Public major release</p><ul>
<li>Various bug fixes</li>
<li>Added support for fixed point 8 bit (QS8) to the various NEON machine learning kernels.</li>
<li>Added unit tests and benchmarks (AlexNet, LeNet)</li>
<li>Added support for sub tensors.</li>
<li>Added infrastructure to provide GPU specific optimisation for some OpenCL kernels.</li>
<li>Added <a class="el" href="classarm__compute_1_1_o_m_p_scheduler.xhtml">OMPScheduler</a> (OpenMP) scheduler for NEON</li>
<li>Added <a class="el" href="classarm__compute_1_1_single_thread_scheduler.xhtml">SingleThreadScheduler</a> scheduler for NEON (For bare metal)</li>
<li>User can specify his own scheduler by implementing the <a class="el" href="classarm__compute_1_1_i_scheduler.xhtml">IScheduler</a> interface.</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer_kernel.xhtml">CLBatchNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer.xhtml">CLBatchNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depth_concatenate_layer_kernel.xhtml">CLDepthConcatenateLayerKernel</a> / CLDepthConcatenateLayer</li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_orientation_binning_kernel.xhtml">CLHOGOrientationBinningKernel</a> <a class="el" href="classarm__compute_1_1_c_l_h_o_g_block_normalization_kernel.xhtml">CLHOGBlockNormalizationKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_h_o_g_detector_kernel.xhtml">CLHOGDetectorKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_h_o_g_descriptor.xhtml">CLHOGDescriptor</a> <a class="el" href="classarm__compute_1_1_c_l_h_o_g_detector.xhtml">CLHOGDetector</a> <a class="el" href="classarm__compute_1_1_c_l_h_o_g_gradient.xhtml">CLHOGGradient</a> <a class="el" href="classarm__compute_1_1_c_l_h_o_g_multi_detection.xhtml">CLHOGMultiDetection</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_locally_connected_matrix_multiply_kernel.xhtml">CLLocallyConnectedMatrixMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_locally_connected_layer.xhtml">CLLocallyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_weights_reshape_kernel.xhtml">CLWeightsReshapeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_convolution_layer_reshape_weights.xhtml">CLConvolutionLayerReshapeWeights</a></li>
</ul>
</li>
<li>New C++ kernels:<ul>
<li><a class="el" href="classarm__compute_1_1_c_p_p_detection_window_non_maxima_suppression_kernel.xhtml">CPPDetectionWindowNonMaximaSuppressionKernel</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_batch_normalization_layer_kernel.xhtml">NEBatchNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_batch_normalization_layer.xhtml">NEBatchNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depth_concatenate_layer_kernel.xhtml">NEDepthConcatenateLayerKernel</a> / NEDepthConcatenateLayer</li>
<li><a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer_kernel.xhtml">NEDirectConvolutionLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer.xhtml">NEDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_locally_connected_matrix_multiply_kernel.xhtml">NELocallyConnectedMatrixMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_locally_connected_layer.xhtml">NELocallyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_weights_reshape_kernel.xhtml">NEWeightsReshapeKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_convolution_layer_reshape_weights.xhtml">NEConvolutionLayerReshapeWeights</a></li>
</ul>
</li>
</ul>
<p>v17.05 Public bug fixes release</p><ul>
<li>Various bug fixes</li>
<li>Remaining of the functions ported to use accurate padding.</li>
<li>Library does not link against OpenCL anymore (It uses dlopen / dlsym at runtime instead to determine whether or not OpenCL is available).</li>
<li>Added "free" method to allocator.</li>
<li>Minimum version of g++ required for armv7 Linux changed from 4.8 to 4.9</li>
</ul>
<p>v17.04 Public bug fixes release</p>
<p>The following functions have been ported to use the new accurate padding:</p><ul>
<li><a class="el" href="classarm__compute_1_1_c_l_color_convert_kernel.xhtml">CLColorConvertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_edge_non_max_suppression_kernel.xhtml">CLEdgeNonMaxSuppressionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_edge_trace_kernel.xhtml">CLEdgeTraceKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_hor_kernel.xhtml">CLGaussianPyramidHorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_vert_kernel.xhtml">CLGaussianPyramidVertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gradient_kernel.xhtml">CLGradientKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_channel_combine_kernel.xhtml">NEChannelCombineKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_fill_array_kernel.xhtml">NEFillArrayKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid_hor_kernel.xhtml">NEGaussianPyramidHorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid_vert_kernel.xhtml">NEGaussianPyramidVertKernel</a></li>
<li>NEHarrisScoreFP16Kernel</li>
<li><a class="el" href="classarm__compute_1_1_n_e_harris_score_kernel.xhtml">NEHarrisScoreKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector_kernel.xhtml">NEHOGDetectorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_max_kernel.xhtml">NELogits1DMaxKernel</a></li>
<li>NELogits1DShiftExpSumKernel</li>
<li>NELogits1DNormKernel</li>
<li><a class="el" href="namespacearm__compute.xhtml#a38cad49e6beaef76bc1ec5064c9e9dba">NENonMaximaSuppression3x3FP16Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_maxima_suppression3x3_kernel.xhtml">NENonMaximaSuppression3x3Kernel</a></li>
</ul>
<p>v17.03.1 First Major public release of the sources</p><ul>
<li>Renamed the library to <a class="el" href="namespacearm__compute.xhtml" title="Copyright (c) 2017-2020 Arm Limited.">arm_compute</a></li>
<li>New CPP target introduced for C++ kernels shared between NEON and CL functions.</li>
<li>New padding calculation interface introduced and ported most kernels / functions to use it.</li>
<li>New OpenCL kernels / functions:<ul>
<li>CLGEMMLowpMatrixMultiplyKernel / CLGEMMLowp</li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_normalization_layer_kernel.xhtml">NENormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_normalization_layer.xhtml">NENormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_transpose_kernel.xhtml">NETransposeKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_transpose.xhtml">NETranspose</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_max_kernel.xhtml">NELogits1DMaxKernel</a>, NELogits1DShiftExpSumKernel, NELogits1DNormKernel / <a class="el" href="namespacearm__compute.xhtml#a4df2143ca0a3bdbbbc54b440a52541cd">NESoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_im2_col_kernel.xhtml">NEIm2ColKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_col2_im_kernel.xhtml">NECol2ImKernel</a>, NEConvolutionLayerWeightsReshapeKernel / <a class="el" href="classarm__compute_1_1_n_e_convolution_layer.xhtml">NEConvolutionLayer</a></li>
<li>NEGEMMMatrixAccumulateBiasesKernel / <a class="el" href="classarm__compute_1_1_n_e_fully_connected_layer.xhtml">NEFullyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_multiply_kernel.xhtml">NEGEMMLowpMatrixMultiplyKernel</a> / NEGEMMLowp</li>
</ul>
</li>
</ul>
<p>v17.03 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_gradient_kernel.xhtml">CLGradientKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_edge_non_max_suppression_kernel.xhtml">CLEdgeNonMaxSuppressionKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_edge_trace_kernel.xhtml">CLEdgeTraceKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_canny_edge.xhtml">CLCannyEdge</a></li>
<li>GEMM refactoring + FP16 support: CLGEMMInterleave4x4Kernel, CLGEMMTranspose1xWKernel, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_kernel.xhtml">CLGEMMMatrixMultiplyKernel</a>, CLGEMMMatrixAdditionKernel / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m.xhtml">CLGEMM</a></li>
<li>CLGEMMMatrixAccumulateBiasesKernel / <a class="el" href="classarm__compute_1_1_c_l_fully_connected_layer.xhtml">CLFullyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_transpose_kernel.xhtml">CLTransposeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_transpose.xhtml">CLTranspose</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_init_kernel.xhtml">CLLKTrackerInitKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_stage0_kernel.xhtml">CLLKTrackerStage0Kernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_stage1_kernel.xhtml">CLLKTrackerStage1Kernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_finalize_kernel.xhtml">CLLKTrackerFinalizeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_optical_flow.xhtml">CLOpticalFlow</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_normalization_layer_kernel.xhtml">CLNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_normalization_layer.xhtml">CLNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_laplacian_pyramid.xhtml">CLLaplacianPyramid</a>, <a class="el" href="classarm__compute_1_1_c_l_laplacian_reconstruct.xhtml">CLLaplacianReconstruct</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_activation_layer_kernel.xhtml">NEActivationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_activation_layer.xhtml">NEActivationLayer</a></li>
<li>GEMM refactoring + FP16 support (Requires armv8.2 CPU): <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_interleave4x4_kernel.xhtml">NEGEMMInterleave4x4Kernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_transpose1x_w_kernel.xhtml">NEGEMMTranspose1xWKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_multiply_kernel.xhtml">NEGEMMMatrixMultiplyKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_addition_kernel.xhtml">NEGEMMMatrixAdditionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m.xhtml">NEGEMM</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pooling_layer_kernel.xhtml">NEPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_pooling_layer.xhtml">NEPoolingLayer</a></li>
</ul>
</li>
</ul>
<p>v17.02.1 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li>CLLogits1DMaxKernel, CLLogits1DShiftExpSumKernel, <a class="el" href="classarm__compute_1_1_c_l_logits1_d_norm_kernel.xhtml">CLLogits1DNormKernel</a> / <a class="el" href="namespacearm__compute.xhtml#a30ce3b40394b4f2d1e4cc31db7183425">CLSoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_pooling_layer_kernel.xhtml">CLPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_pooling_layer.xhtml">CLPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_im2_col_kernel.xhtml">CLIm2ColKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_col2_im_kernel.xhtml">CLCol2ImKernel</a>, CLConvolutionLayerWeightsReshapeKernel / <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_remap_kernel.xhtml">CLRemapKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_remap.xhtml">CLRemap</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_hor_kernel.xhtml">CLGaussianPyramidHorKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_vert_kernel.xhtml">CLGaussianPyramidVertKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid.xhtml">CLGaussianPyramid</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_half.xhtml">CLGaussianPyramidHalf</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_orb.xhtml">CLGaussianPyramidOrb</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_min_max_kernel.xhtml">CLMinMaxKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_min_max_location_kernel.xhtml">CLMinMaxLocationKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_min_max_location.xhtml">CLMinMaxLocation</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_non_linear_filter_kernel.xhtml">CLNonLinearFilterKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_non_linear_filter.xhtml">CLNonLinearFilter</a></li>
</ul>
</li>
<li>New NEON FP16 kernels (Requires armv8.2 CPU)<ul>
<li><a class="el" href="namespacearm__compute.xhtml#aff99c045b07329b332b1cb97a2dd1518">NEAccumulateWeightedFP16Kernel</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a96f7f6f98dc47e0dc3b928bf87397ebf">NEBox3x3FP16Kernel</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a38cad49e6beaef76bc1ec5064c9e9dba">NENonMaximaSuppression3x3FP16Kernel</a></li>
</ul>
</li>
</ul>
<p>v17.02 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_activation_layer_kernel.xhtml">CLActivationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_activation_layer.xhtml">CLActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_combine_kernel.xhtml">CLChannelCombineKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_channel_combine.xhtml">CLChannelCombine</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_derivative_kernel.xhtml">CLDerivativeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_channel_extract.xhtml">CLChannelExtract</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_fast_corners_kernel.xhtml">CLFastCornersKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_fast_corners.xhtml">CLFastCorners</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_mean_std_dev_kernel.xhtml">CLMeanStdDevKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_mean_std_dev.xhtml">CLMeanStdDev</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_h_o_g.xhtml" title="CPU implementation of HOG data-object.">HOG</a> / SVM: <a class="el" href="classarm__compute_1_1_n_e_h_o_g_orientation_binning_kernel.xhtml">NEHOGOrientationBinningKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_block_normalization_kernel.xhtml">NEHOGBlockNormalizationKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector_kernel.xhtml">NEHOGDetectorKernel</a>, NEHOGNonMaximaSuppressionKernel / <a class="el" href="classarm__compute_1_1_n_e_h_o_g_descriptor.xhtml">NEHOGDescriptor</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector.xhtml">NEHOGDetector</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_gradient.xhtml">NEHOGGradient</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_multi_detection.xhtml">NEHOGMultiDetection</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_linear_filter_kernel.xhtml">NENonLinearFilterKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_non_linear_filter.xhtml">NENonLinearFilter</a></li>
</ul>
</li>
<li>Introduced a <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml" title="Provides global access to a CL context and command queue.">CLScheduler</a> to manage the default context and command queue used by the runtime library and create synchronisation events.</li>
<li>Switched all the kernels / functions to use tensors instead of images.</li>
<li>Updated documentation to include instructions to build the library from sources.</li>
</ul>
<p>v16.12 Binary preview release</p><ul>
<li>Original release</li>
</ul>
<h1><a class="anchor" id="S3_how_to_build"></a>
How to build the library and the examples</h1>
<h2><a class="anchor" id="S3_1_build_options"></a>
Build options</h2>
<p>scons 2.3 or above is required to build the library. To see the build options available simply run <code>scons -h</code>: </p><pre class="fragment">debug: Debug (yes|no)
    default: False
    actual: False

asserts: Enable asserts (this flag is forced to 1 for debug=1) (yes|no)
    default: False
    actual: False

arch: Target Architecture (armv7a|arm64-v8a|arm64-v8.2-a|x86_32|x86_64)
    default: armv7a
    actual: armv7a

os: Target OS (linux|android|bare_metal)
    default: linux
    actual: linux

build: Build type (native|cross_compile|embed_only)
    default: cross_compile
    actual: cross_compile

examples: Build example programs (yes|no)
    default: True
    actual: True

Werror: Enable/disable the -Werror compilation flag (yes|no)
    default: True
    actual: True

opencl: Enable OpenCL support (yes|no)
    default: True
    actual: True

neon: Enable Neon support (yes|no)
    default: False
    actual: False

gles_compute: Enable OpenGL ES Compute Shader support (yes|no)
    default: False
    actual: False

embed_kernels: Embed OpenCL kernels and OpenGL ES compute shader in library binary (yes|no)
    default: True
    actual: True

set_soname: Set the library's soname and shlibversion (requires SCons 2.4 or above) (yes|no)
    default: False
    actual: False

openmp: Enable OpenMP backend (yes|no)
    default: False
    actual: False

cppthreads: Enable C++11 threads backend (yes|no)
    default: True
    actual: True

build_dir: Specify sub-folder for the build ( /path/to/build_dir )
    default: .
    actual: .

extra_cxx_flags: Extra CXX flags to be appended to the build command
    default:
    actual:

pmu: Enable PMU counters (yes|no)
    default: False
    actual: False

mali: Enable Mali hardware counters (yes|no)
    default: False
    actual: False

validation_tests: Build validation test programs (yes|no)
    default: False
    actual: False

benchmark_tests: Build benchmark test programs (yes|no)
    default: False
    actual: False
</pre><p><b>debug</b> / <b>asserts:</b> </p><ul>
<li>With debug=1 asserts are enabled, and the library is built with symbols and no optimisations enabled.</li>
<li>With debug=0 and asserts=1: Optimisations are enabled and symbols are removed, however all the asserts are still present (This is about 20% slower than the release build)</li>
<li>With debug=0 and asserts=0: All optimisations are enable and no validation is performed, if the application misuses the library it is likely to result in a crash. (Only use this mode once you are sure your application is working as expected).</li>
</ul>
<p><b>arch:</b> The x86_32 and x86_64 targets can only be used with neon=0 and opencl=1.</p>
<p><b>os:</b> Choose the operating system you are targeting: Linux, Android or bare metal. </p><dl class="section note"><dt>Note</dt><dd>bare metal can only be used for NEON (not OpenCL), only static libraries get built and NEON's multi-threading support is disabled.</dd></dl>
<p><b>build:</b> you can either build directly on your device (native) or cross compile from your desktop machine (cross-compile). In both cases make sure the compiler is available in your path.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to natively compile for 32bit on a 64bit ARM device running a 64bit OS then you will have to use cross-compile too.</dd></dl>
<p>There is also an 'embed_only' option which will generate all the .embed files for the OpenCL kernels and / or OpenGLES compute shaders. This might be useful if using a different build system to compile the library.</p>
<p><b>Werror:</b> If you are compiling using the same toolchains as the ones used in this guide then there shouldn't be any warning and therefore you should be able to keep Werror=1. If with a different compiler version the library fails to build because of warnings interpreted as errors then, if you are sure the warnings are not important, you might want to try to build with Werror=0 (But please do report the issue either on Github or by an email to <a href="#" onclick="location.href='mai'+'lto:'+'dev'+'el'+'ope'+'r@'+'arm'+'.c'+'om'; return false;">devel<span style="display: none;">.nosp@m.</span>oper<span style="display: none;">.nosp@m.</span>@arm.<span style="display: none;">.nosp@m.</span>com</a> so that the issue can be addressed).</p>
<p><b>opencl</b> / <b>neon</b> / <b>gles_compute:</b> Choose which SIMD technology you want to target. (NEON for ARM Cortex-A CPUs or OpenCL / GLES_COMPUTE for ARM Mali GPUs)</p>
<p><b>embed_kernels:</b> For OpenCL / GLES_COMPUTE only: set embed_kernels=1 if you want the OpenCL / GLES_COMPUTE kernels to be built in the library's binaries instead of being read from separate ".cl" / ".cs" files. If embed_kernels is set to 0 then the application can set the path to the folder containing the OpenCL / GLES_COMPUTE kernel files by calling <a class="el" href="classarm__compute_1_1_c_l_kernel_library.xhtml#a9f976367edcd9ab787375373e050b94b" title="Initialises the kernel library.">CLKernelLibrary::init()</a> / <a class="el" href="classarm__compute_1_1_g_c_kernel_library.xhtml#abe24625d55f2fb35da7e293e5e28d483" title="Initialises the kernel library.">GCKernelLibrary::init()</a>. By default the path is set to "./cl_kernels" / "./cs_shaders".</p>
<p><b>set_soname:</b> Do you want to build the versioned version of the library ?</p>
<p>If enabled the library will contain a SONAME and SHLIBVERSION and some symlinks will automatically be created between the objects. Example: libarm_compute_core.so -&gt; libarm_compute_core.so.1.0.0 libarm_compute_core.so.1 -&gt; libarm_compute_core.so.1.0.0 libarm_compute_core.so.1.0.0</p>
<dl class="section note"><dt>Note</dt><dd>This options is disabled by default as it requires SCons version 2.4 or above.</dd></dl>
<p><b>extra_cxx_flags:</b> Custom CXX flags which will be appended to the end of the build command.</p>
<p><b>build_dir:</b> Build the library in a subfolder of the "build" folder. (Allows to build several configurations in parallel).</p>
<p><b>examples:</b> Build or not the examples</p>
<p><b>validation_tests:</b> Enable the build of the validation suite.</p>
<p><b>benchmark_tests:</b> Enable the build of the benchmark tests</p>
<p><b>pmu:</b> Enable the PMU cycle counter to measure execution time in benchmark tests. (Your device needs to support it)</p>
<p><b>mali:</b> Enable the collection of Mali hardware counters to measure execution time in benchmark tests. (Your device needs to have a Mali driver that supports it)</p>
<p><b>openmp</b> Build in the OpenMP scheduler for NEON.</p>
<dl class="section note"><dt>Note</dt><dd>Only works when building with g++ not clang++</dd></dl>
<p><b>cppthreads</b> Build in the C++11 scheduler for NEON.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classarm__compute_1_1_scheduler.xhtml#ad2fc671b2772dd9e28b81cf0e2514e85" title="Sets the user defined scheduler and makes it the active scheduler.">Scheduler::set</a></dd></dl>
<h2><a class="anchor" id="S3_2_linux"></a>
Building for Linux</h2>
<h3><a class="anchor" id="S3_2_1_library"></a>
How to build the library ?</h3>
<p>For Linux, the library was successfully built and tested using the following Linaro GCC toolchain:</p>
<ul>
<li>gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf</li>
<li>gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu</li>
</ul>
<p>To cross-compile the library in debug mode, with NEON only support, for Linux 32bit: </p><pre class="fragment">scons Werror=1 -j8 debug=1 neon=1 opencl=0 os=linux arch=armv7a
</pre><p>To cross-compile the library in asserts mode, with OpenCL only support, for Linux 64bit: </p><pre class="fragment">scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=1 embed_kernels=1 os=linux arch=arm64-v8a
</pre><p>To cross-compile the library in asserts mode, with GLES_COMPUTE only support, for Linux 64bit: </p><pre class="fragment">scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=0 gles_compute=1 embed_kernels=1 os=linux arch=arm64-v8a
</pre><p>You can also compile the library natively on an ARM device by using <b>build=native</b>: </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=arm64-v8a build=native
scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a build=native
</pre><dl class="section note"><dt>Note</dt><dd>g++ for ARM is mono-arch, therefore if you want to compile for Linux 32bit on a Linux 64bit platform you will have to use a cross compiler.</dd></dl>
<p>For example on a 64bit Debian based system you would have to install <b>g++-arm-linux-gnueabihf</b> </p><pre class="fragment">apt-get install g++-arm-linux-gnueabihf
</pre><p>Then run </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a build=cross_compile
</pre><p>or simply remove the build parameter as build=cross_compile is the default value: </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a
</pre><h3><a class="anchor" id="S3_2_2_examples"></a>
How to manually build the examples ?</h3>
<p>The examples get automatically built by scons as part of the build process of the library described above. This section just describes how you can build and link your own application against our library.</p>
<dl class="section note"><dt>Note</dt><dd>The following command lines assume the <a class="el" href="namespacearm__compute.xhtml" title="Copyright (c) 2017-2020 Arm Limited.">arm_compute</a> libraries are present in the current directory or in the system library path. If this is not the case you can specify the location of the pre-built libraries with the compiler option -L. When building the OpenCL example the commands below assume that the CL headers are located in the include folder where the command is executed.</dd></dl>
<p>To cross compile a NEON example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute -larm_compute_core -o neon_convolution
</pre><p>To cross compile a NEON example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -L. -larm_compute -larm_compute_core -o neon_convolution
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option and the compiler's name is different)</p>
<p>To cross compile an OpenCL example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute -larm_compute_core -o cl_convolution -DARM_COMPUTE_CL
</pre><p>To cross compile an OpenCL example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -L. -larm_compute -larm_compute_core -o cl_convolution -DARM_COMPUTE_CL
</pre><p>To cross compile a GLES example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/gc_absdiff.cpp utils/Utils.cpp -I. -Iinclude/ -L. -larm_compute -larm_compute_core -std=c++11 -mfpu=neon -DARM_COMPUTE_GC -Iinclude/linux/ -o gc_absdiff
</pre><p>To cross compile a GLES example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/gc_absdiff.cpp utils/Utils.cpp -I. -Iinclude/ -L. -larm_compute -larm_compute_core -std=c++11 -DARM_COMPUTE_GC -Iinclude/linux/ -o gc_absdiff
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option and the compiler's name is different)</p>
<p>To cross compile the examples with the Graph API, such as <a class="el" href="graph__lenet_8cpp.xhtml">graph_lenet.cpp</a>, you need to link the examples against arm_compute_graph.so too.</p>
<p>i.e. to cross compile the "graph_lenet" example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp utils/CommonGraphOptions.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute_graph -larm_compute -larm_compute_core -Wl,--allow-shlib-undefined -o graph_lenet
</pre><p>i.e. to cross compile the "graph_lenet" example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp utils/CommonGraphOptions.cpp -I. -Iinclude -std=c++11 -L. -larm_compute_graph -larm_compute -larm_compute_core -Wl,--allow-shlib-undefined -o graph_lenet
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option and the compiler's name is different)</p>
<dl class="section note"><dt>Note</dt><dd>If compiling using static libraries, this order must be followed when linking: arm_compute_graph_static, <a class="el" href="namespacearm__compute.xhtml" title="Copyright (c) 2017-2020 Arm Limited.">arm_compute</a>, arm_compute_core</dd></dl>
<p>To compile natively (i.e directly on an ARM device) for NEON for Linux 32bit: </p><pre class="fragment">g++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -larm_compute -larm_compute_core -o neon_convolution
</pre><p>To compile natively (i.e directly on an ARM device) for NEON for Linux 64bit: </p><pre class="fragment">g++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute -larm_compute_core -o neon_convolution
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option)</p>
<p>To compile natively (i.e directly on an ARM device) for OpenCL for Linux 32bit or Linux 64bit: </p><pre class="fragment">g++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute -larm_compute_core -o cl_convolution -DARM_COMPUTE_CL
</pre><p>To compile natively (i.e directly on an ARM device) for GLES for Linux 32bit or Linux 64bit: </p><pre class="fragment">g++ examples/gc_absdiff.cpp utils/Utils.cpp -I. -Iinclude/ -L. -larm_compute -larm_compute_core -std=c++11 -DARM_COMPUTE_GC -Iinclude/linux/ -o gc_absdiff
</pre><p>To compile natively the examples with the Graph API, such as <a class="el" href="graph__lenet_8cpp.xhtml">graph_lenet.cpp</a>, you need to link the examples against arm_compute_graph.so too.</p>
<p>i.e. to natively compile the "graph_lenet" example for Linux 32bit: </p><pre class="fragment">g++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp utils/CommonGraphOptions.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute_graph -larm_compute -larm_compute_core -Wl,--allow-shlib-undefined -o graph_lenet
</pre><p>i.e. to natively compile the "graph_lenet" example for Linux 64bit: </p><pre class="fragment">g++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp utils/CommonGraphOptions.cpp -I. -Iinclude -std=c++11 -L. -larm_compute_graph -larm_compute -larm_compute_core -Wl,--allow-shlib-undefined -o graph_lenet
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option)</p>
<dl class="section note"><dt>Note</dt><dd>If compiling using static libraries, this order must be followed when linking: arm_compute_graph_static, <a class="el" href="namespacearm__compute.xhtml" title="Copyright (c) 2017-2020 Arm Limited.">arm_compute</a>, arm_compute_core</dd>
<dd>
These two commands assume libarm_compute.so is available in your library path, if not add the path to it using -L (e.g. -Llib/linux-arm64-v8a-neon-cl-asserts/) </dd>
<dd>
You might need to export the path to OpenCL library as well in your LD_LIBRARY_PATH if Compute Library was built with OpenCL enabled.</dd></dl>
<p>To run the built executable simply run: </p><pre class="fragment">LD_LIBRARY_PATH=build ./neon_convolution
</pre><p>or </p><pre class="fragment">LD_LIBRARY_PATH=build ./cl_convolution
</pre><dl class="section note"><dt>Note</dt><dd>Examples accept different types of arguments, to find out what they are run the example with <em>&ndash;help</em> as an argument. If no arguments are specified then random values will be used to execute the graph.</dd></dl>
<p>For example: </p><pre class="fragment">LD_LIBRARY_PATH=. ./graph_lenet --help
</pre><p>Below is a list of the common parameters among the graph examples : </p><div class="fragment"><div class="line"><span class="comment">/* Common graph parameters</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * --help             : Print the example&#39;s help message.</span></div><div class="line"><span class="comment"> * --threads          : The number of threads to be used by the example during execution.</span></div><div class="line"><span class="comment"> * --target           : Execution target to be used by the examples. Supported target options: NEON, CL, GC.</span></div><div class="line"><span class="comment"> * --type             : Data type to be used by the examples. Supported data type options: QASYMM8, F16, F32.</span></div><div class="line"><span class="comment"> * --layout           : Data layout to be used by the examples. Supported data layout options : NCHW, NHWC.</span></div><div class="line"><span class="comment"> * --enable-tuner     : Toggle option to enable the OpenCL dynamic tuner.</span></div><div class="line"><span class="comment"> * --enable-cl-cache  : Toggle option to load the prebuilt opencl kernels from a cache file.</span></div><div class="line"><span class="comment"> * --fast-math        : Toggle option to enable the fast math option.</span></div><div class="line"><span class="comment"> * --data             : Path that contains the trainable parameter files of graph layers.</span></div><div class="line"><span class="comment"> * --image            : Image to load and operate on. Image types supported: PPM, JPEG, NPY.</span></div><div class="line"><span class="comment"> * --labels           : File that contains the labels that classify upon.</span></div><div class="line"><span class="comment"> * --validation-file  : File that contains a list of image names with their corresponding label id (e.g. image0.jpg 5).</span></div><div class="line"><span class="comment"> *                      This is used to run the graph over a number of images and report top-1 and top-5 metrics.</span></div><div class="line"><span class="comment"> * --validation-path  : The path where the validation images specified in the validation file reside.</span></div><div class="line"><span class="comment"> * --validation-range : The range of the images to validate from the validation file (e.g 0,9).</span></div><div class="line"><span class="comment"> *                      If not specified all the images will be validated.</span></div><div class="line"><span class="comment"> * --tuner-file       : The file to store the OpenCL dynamic tuner tuned parameters.</span></div><div class="line"><span class="comment"> * --tuner-mode       : Select tuner mode. Supported modes: Exhaustive,Normal,Rapid</span></div><div class="line"><span class="comment"> *                      * Exhaustive: slowest but produces the most performant LWS configuration.</span></div><div class="line"><span class="comment"> *                      * Normal: slow but produces the LWS configurations on par with Exhaustive most of the time.</span></div><div class="line"><span class="comment"> *                      * Rapid: fast but produces less performant LWS configurations</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Note that data, image and labels options should be provided to perform an inference run on an image.</span></div><div class="line"><span class="comment"> * Note that validation-file and validation-path should be provided to perform a graph accuracy estimation.</span></div><div class="line"><span class="comment"> * Note GLES target is not supported for most of the networks.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Example execution commands:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Execute a single inference given an image and a file containing the correspondence between label ids and human readable labels:</span></div><div class="line"><span class="comment"> * ./graph_vgg16 --data=data/ --target=cl --layout=nhwc --image=kart.jpeg --labels=imagenet1000_clsid_to_human.txt</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Perform a graph validation on a list of images:</span></div><div class="line"><span class="comment"> * ./graph_vgg16 --data=data/ --target=neon --threads=4 --layout=nchw --validation-file=val.txt --validation-path=ilsvrc_test_images/</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * File formats:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Validation file should be a plain file containing the names of the images followed by the correct label id.</span></div><div class="line"><span class="comment"> * For example:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * image0.jpeg 882</span></div><div class="line"><span class="comment"> * image1.jpeg 34</span></div><div class="line"><span class="comment"> * image2.jpeg 354</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Labels file should be a plain file where each line is the respective human readable label (counting starts from 0).</span></div><div class="line"><span class="comment"> * For example:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 0: label0_name            label0_name</span></div><div class="line"><span class="comment"> * 1: label1_name     or     label1_name</span></div><div class="line"><span class="comment"> * 2: label2_name            label2_name</span></div><div class="line"><span class="comment"> */</span></div></div><!-- fragment --> <h2><a class="anchor" id="S3_3_android"></a>
Building for Android</h2>
<p>For Android, the library was successfully built and tested using Google's standalone toolchains:</p><ul>
<li>clang++ from NDK r18b for armv7a</li>
<li>clang++ from NDK r18b for arm64-v8a</li>
<li>clang++ from NDK r18b for arm64-v8.2-a with FP16 support</li>
</ul>
<p>Here is a guide to <a href="https://developer.android.com/ndk/guides/standalone_toolchain.html">create your Android standalone toolchains from the NDK</a></p>
<ul>
<li>Download the NDK r18b from here: <a href="https://developer.android.com/ndk/downloads/index.html">https://developer.android.com/ndk/downloads/index.html</a> to directory $NDK</li>
<li>Make sure you have Python 2.7 installed on your machine.</li>
<li>Generate the 32 and/or 64 toolchains by running the following commands to your toolchain dirctory $MY_TOOLCHAINS:</li>
</ul>
<pre class="fragment">$NDK/build/tools/make_standalone_toolchain.py --arch arm64 --install-dir $MY_TOOLCHAINS/aarch64-linux-android-ndk-r18b --stl libc++ --api 21
$NDK/build/tools/make_standalone_toolchain.py --arch arm --install-dir $MY_TOOLCHAINS/arm-linux-android-ndk-r18b --stl libc++ --api 21
</pre><dl class="section attention"><dt>Attention</dt><dd>We used to use gnustl but as of NDK r17 it is deprecated so we switched to libc++</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Make sure to add the toolchains to your PATH: <pre class="fragment">export PATH=$PATH:$MY_TOOLCHAINS/aarch64-linux-android-ndk-r18b/bin:$MY_TOOLCHAINS/arm-linux-android-ndk-r18b/bin
</pre></dd></dl>
<h3><a class="anchor" id="S3_3_1_library"></a>
How to build the library ?</h3>
<p>To cross-compile the library in debug mode, with NEON only support, for Android 32bit: </p><pre class="fragment">CXX=clang++ CC=clang scons Werror=1 -j8 debug=1 neon=1 opencl=0 os=android arch=armv7a
</pre><p>To cross-compile the library in asserts mode, with OpenCL only support, for Android 64bit: </p><pre class="fragment">CXX=clang++ CC=clang scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=1 embed_kernels=1 os=android arch=arm64-v8a
</pre><p>To cross-compile the library in asserts mode, with GLES_COMPUTE only support, for Android 64bit: </p><pre class="fragment">CXX=clang++ CC=clang scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=0 gles_compute=1 embed_kernels=1 os=android arch=arm64-v8a
</pre><h3><a class="anchor" id="S3_3_2_examples"></a>
How to manually build the examples ?</h3>
<p>The examples get automatically built by scons as part of the build process of the library described above. This section just describes how you can build and link your own application against our library.</p>
<dl class="section note"><dt>Note</dt><dd>The following command lines assume the <a class="el" href="namespacearm__compute.xhtml" title="Copyright (c) 2017-2020 Arm Limited.">arm_compute</a> libraries are present in the current directory or in the system library path. If this is not the case you can specify the location of the pre-built libraries with the compiler option -L. When building the OpenCL example the commands below assume that the CL headers are located in the include folder where the command is executed.</dd></dl>
<p>Once you've got your Android standalone toolchain built and added to your path you can do the following:</p>
<p>To cross compile a NEON example: </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o neon_convolution_arm -static-libstdc++ -pie
#64 bit:
aarch64-linux-android-clang++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o neon_convolution_aarch64 -static-libstdc++ -pie
</pre><p>To cross compile an OpenCL example: </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o cl_convolution_arm -static-libstdc++ -pie -DARM_COMPUTE_CL
#64 bit:
aarch64-linux-android-clang++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o cl_convolution_aarch64 -static-libstdc++ -pie -DARM_COMPUTE_CL
</pre><p>To cross compile a GLES example: </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/gc_absdiff.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o gc_absdiff_arm -static-libstdc++ -pie -DARM_COMPUTE_GC
#64 bit:
aarch64-linux-android-clang++ examples/gc_absdiff.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o gc_absdiff_aarch64 -static-libstdc++ -pie -DARM_COMPUTE_GC
</pre><p>To cross compile the examples with the Graph API, such as <a class="el" href="graph__lenet_8cpp.xhtml">graph_lenet.cpp</a>, you need to link the library arm_compute_graph also. </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp utils/CommonGraphOptions.cpp -I. -Iinclude -std=c++11 -Wl,--whole-archive -larm_compute_graph-static -Wl,--no-whole-archive -larm_compute-static -larm_compute_core-static -L. -o graph_lenet_arm -static-libstdc++ -pie -DARM_COMPUTE_CL
#64 bit:
aarch64-linux-android-clang++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp utils/CommonGraphOptions.cpp -I. -Iinclude -std=c++11 -Wl,--whole-archive -larm_compute_graph-static -Wl,--no-whole-archive -larm_compute-static -larm_compute_core-static -L. -o graph_lenet_aarch64 -static-libstdc++ -pie -DARM_COMPUTE_CL
</pre><dl class="section note"><dt>Note</dt><dd>Due to some issues in older versions of the Mali OpenCL DDK (&lt;= r13p0), we recommend to link <a class="el" href="namespacearm__compute.xhtml" title="Copyright (c) 2017-2020 Arm Limited.">arm_compute</a> statically on Android. </dd>
<dd>
When linked statically the arm_compute_graph library currently needs the &ndash;whole-archive linker flag in order to work properly</dd></dl>
<p>Then you need to do is upload the executable and the shared library to the device using ADB: </p><pre class="fragment">adb push neon_convolution_arm /data/local/tmp/
adb push cl_convolution_arm /data/local/tmp/
adb push gc_absdiff_arm /data/local/tmp/
adb shell chmod 777 -R /data/local/tmp/
</pre><p>And finally to run the example: </p><pre class="fragment">adb shell /data/local/tmp/neon_convolution_arm
adb shell /data/local/tmp/cl_convolution_arm
adb shell /data/local/tmp/gc_absdiff_arm
</pre><p>For 64bit: </p><pre class="fragment">adb push neon_convolution_aarch64 /data/local/tmp/
adb push cl_convolution_aarch64 /data/local/tmp/
adb push gc_absdiff_aarch64 /data/local/tmp/
adb shell chmod 777 -R /data/local/tmp/
</pre><p>And finally to run the example: </p><pre class="fragment">adb shell /data/local/tmp/neon_convolution_aarch64
adb shell /data/local/tmp/cl_convolution_aarch64
adb shell /data/local/tmp/gc_absdiff_aarch64
</pre><dl class="section note"><dt>Note</dt><dd>Examples accept different types of arguments, to find out what they are run the example with <em>&ndash;help</em> as an argument. If no arguments are specified then random values will be used to execute the graph.</dd></dl>
<p>For example: adb shell /data/local/tmp/graph_lenet &ndash;help</p>
<p>In this case the first argument of LeNet (like all the graph examples) is the target (i.e 0 to run on NEON, 1 to run on OpenCL if available, 2 to run on OpenCL using the <a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml" title="Basic implementation of the OpenCL tuner interface.">CLTuner</a>), the second argument is the path to the folder containing the npy files for the weights and finally the third argument is the number of batches to run.</p>
<h2><a class="anchor" id="S3_4_bare_metal"></a>
Building for bare metal</h2>
<p>For bare metal, the library was successfully built using linaro's latest (gcc-linaro-6.3.1-2017.05) bare metal toolchains:</p><ul>
<li>arm-eabi for armv7a</li>
<li>aarch64-elf for arm64-v8a</li>
</ul>
<p>Download linaro for <a href="https://releases.linaro.org/components/toolchain/binaries/6.3-2017.05/arm-eabi/">armv7a</a> and <a href="https://releases.linaro.org/components/toolchain/binaries/6.3-2017.05/aarch64-elf/">arm64-v8a</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Make sure to add the toolchains to your PATH: export PATH=$PATH:$MY_TOOLCHAINS/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-elf/bin:$MY_TOOLCHAINS/gcc-linaro-6.3.1-2017.05-x86_64_arm-eabi/bin</dd></dl>
<h3><a class="anchor" id="S3_4_1_library"></a>
How to build the library ?</h3>
<p>To cross-compile the library with NEON support for baremetal arm64-v8a: </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=bare_metal arch=arm64-v8a build=cross_compile cppthreads=0 openmp=0 standalone=1
</pre><h3><a class="anchor" id="S3_4_2_examples"></a>
How to manually build the examples ?</h3>
<p>Examples are disabled when building for bare metal. If you want to build the examples you need to provide a custom bootcode depending on the target architecture and link against the compute library. More information about bare metal bootcode can be found <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0527a/index.html">here</a>.</p>
<h2><a class="anchor" id="S3_5_windows_host"></a>
Building on a Windows host system</h2>
<p>Using <code>scons</code> directly from the Windows command line is known to cause problems. The reason seems to be that if <code>scons</code> is setup for cross-compilation it gets confused about Windows style paths (using backslashes). Thus it is recommended to follow one of the options outlined below.</p>
<h3><a class="anchor" id="S3_5_1_ubuntu_on_windows"></a>
Bash on Ubuntu on Windows</h3>
<p>The best and easiest option is to use <a href="https://msdn.microsoft.com/en-gb/commandline/wsl/about">Ubuntu on Windows</a>. This feature is still marked as <em>beta</em> and thus might not be available. However, if it is building the library is as simple as opening a <em>Bash on Ubuntu on Windows</em> shell and following the general guidelines given above.</p>
<h3><a class="anchor" id="S3_5_2_cygwin"></a>
Cygwin</h3>
<p>If the Windows subsystem for Linux is not available <a href="https://www.cygwin.com/">Cygwin</a> can be used to install and run <code>scons</code>, the minimum Cygwin version must be 3.0.7 or later. In addition to the default packages installed by Cygwin <code>scons</code> has to be selected in the installer. (<code>git</code> might also be useful but is not strictly required if you already have got the source code of the library.) Linaro provides pre-built versions of <a href="http://releases.linaro.org/components/toolchain/binaries/">GCC cross-compilers</a> that can be used from the Cygwin terminal. When building for Android the compiler is included in the Android standalone toolchain. After everything has been set up in the Cygwin terminal the general guide on building the library can be followed.</p>
<h2><a class="anchor" id="S3_6_cl_requirements"></a>
OpenCL DDK Requirements</h2>
<h3><a class="anchor" id="S3_6_1_cl_hard_requirements"></a>
Hard Requirements</h3>
<p>Compute Library requires OpenCL 1.1 and above with support of non uniform workgroup sizes, which is officially supported in the Mali OpenCL DDK r8p0 and above as an extension (respective extension flag is <em>-cl-arm-non-uniform-work-group-size</em>).</p>
<p>Enabling 16-bit floating point calculations require <em>cl_khr_fp16</em> extension to be supported. All Mali GPUs with compute capabilities have native support for half precision floating points.</p>
<p>Use of <a class="el" href="classarm__compute_1_1_c_l_mean_std_dev.xhtml">CLMeanStdDev</a> function requires 64-bit atomics support, thus <em>cl_khr_int64_base_atomics</em> should be supported in order to use.</p>
<h3><a class="anchor" id="S3_6_2_cl_performance_requirements"></a>
Performance improvements</h3>
<p>Integer dot product built-in function extensions (and therefore optimized kernels) are available with Mali OpenCL DDK r22p0 and above for the following GPUs : G71, G76. The relevant extensions are <em>cl_arm_integer_dot_product_int8</em>, <em>cl_arm_integer_dot_product_accumulate_int8</em> and <em>cl_arm_integer_dot_product_accumulate_int16</em>.</p>
<p>OpenCL kernel level debugging can be simplified with the use of printf, this requires the <em>cl_arm_printf</em> extension to be supported.</p>
<p>SVM allocations are supported for all the underlying allocations in Compute Library. To enable this OpenCL 2.0 and above is a requirement.</p>
<h2><a class="anchor" id="S3_7_cl_tuner"></a>
OpenCL Tuner</h2>
<p>The OpenCL tuner, a.k.a. <a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml" title="Basic implementation of the OpenCL tuner interface.">CLTuner</a>, is a module of Arm Compute Library that can improve the performance of the OpenCL kernels tuning the Local-Workgroup-Size (LWS). The optimal LWS for each unique OpenCL kernel configuration is stored in a table. This table can be either imported or exported from/to a file. The OpenCL tuner runs the same OpenCL kernel for a range of local workgroup sizes and keeps the local workgroup size of the fastest run to use in subsequent calls to the kernel. It supports three modes of tuning with different trade-offs between the time taken to tune and the kernel execution time achieved using the best LWS found. In the Exhaustive mode, it searches all the supported values of LWS. This mode takes the longest time to tune and is the most likely to find the optimal LWS. Normal mode searches a subset of LWS values to yield a good approximation of the optimal LWS. It takes less time to tune than Exhaustive mode. Rapid mode takes the shortest time to tune and finds an LWS value that is at least as good or better than the default LWS value. The mode affects only the search for the optimal LWS and has no effect when the LWS value is imported from a file. In order for the performance numbers to be meaningful you must disable the GPU power management and set it to a fixed frequency for the entire duration of the tuning phase.</p>
<p>If you wish to know more about LWS and the important role on improving the GPU cache utilization, we suggest having a look at the presentation "Even Faster CNNs: Exploring the New Class of Winograd Algorithms available at the following link:</p>
<p><a href="https://www.embedded-vision.com/platinum-members/arm/embedded-vision-training/videos/pages/may-2018-embedded-vision-summit-iodice">https://www.embedded-vision.com/platinum-members/arm/embedded-vision-training/videos/pages/may-2018-embedded-vision-summit-iodice</a></p>
<p>Tuning a network from scratch can be long and affect considerably the execution time for the first run of your network. It is recommended for this reason to store the <a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml" title="Basic implementation of the OpenCL tuner interface.">CLTuner</a>'s result in a file to amortize this time when you either re-use the same network or the functions with the same configurations. The tuning is performed only once for each OpenCL kernel.</p>
<p><a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml" title="Basic implementation of the OpenCL tuner interface.">CLTuner</a> looks for the optimal LWS for each unique OpenCL kernel configuration. Since a function (i.e. Convolution Layer, Pooling Layer, Fully Connected Layer ...) can be called multiple times but with different parameters, we associate an "id" (called "config_id") to each kernel to distinguish the unique configurations. </p><pre class="fragment">#Example: 2 unique Matrix Multiply configurations
</pre> <div class="fragment"><div class="line">TensorShape a0 = TensorShape(32,32);</div><div class="line">TensorShape b0 = TensorShape(32,32);</div><div class="line">TensorShape c0 = TensorShape(32,32);</div><div class="line">TensorShape a1 = TensorShape(64,64);</div><div class="line">TensorShape b1 = TensorShape(64,64);</div><div class="line">TensorShape c1 = TensorShape(64,64);</div><div class="line"></div><div class="line">Tensor a0_tensor;</div><div class="line">Tensor b0_tensor;</div><div class="line">Tensor c0_tensor;</div><div class="line">Tensor a1_tensor;</div><div class="line">Tensor b1_tensor;</div><div class="line">Tensor c1_tensor;</div><div class="line"></div><div class="line">a0_tensor.allocator()-&gt;init(TensorInfo(a0, 1, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>));</div><div class="line">b0_tensor.allocator()-&gt;init(TensorInfo(b0, 1, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>));</div><div class="line">c0_tensor.allocator()-&gt;init(TensorInfo(c0, 1, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>));</div><div class="line">a1_tensor.allocator()-&gt;init(TensorInfo(a1, 1, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>));</div><div class="line">b1_tensor.allocator()-&gt;init(TensorInfo(b1, 1, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>));</div><div class="line">c1_tensor.allocator()-&gt;init(TensorInfo(c1 1, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>));</div><div class="line"></div><div class="line">CLGEMM gemm0;</div><div class="line">CLGEMM gemm1;</div><div class="line"></div><div class="line"><span class="comment">// Configuration 0</span></div><div class="line">gemm0.configure(&amp;a0, &amp;b0, <span class="keyword">nullptr</span>, &amp;c0, 1.0f, 0.0f);</div><div class="line"></div><div class="line"><span class="comment">// Configuration 1</span></div><div class="line">gemm1.configure(&amp;a1, &amp;b1, <span class="keyword">nullptr</span>, &amp;c1, 1.0f, 0.0f);</div></div><!-- fragment --><h3><a class="anchor" id="S3_7_1_cl_tuner_how_to"></a>
How to use it</h3>
<p>All the graph examples in the Compute Library's folder "examples" and the arm_compute_benchmark accept an argument to enable the OpenCL tuner and an argument to export/import the LWS values to/from a file </p><pre class="fragment">#Enable CL tuner
./graph_mobilenet --enable-tuner -target=CL
./arm_compute_benchmark --enable-tuner

#Export/Import to/from a file
./graph_mobilenet --enable-tuner --target=CL --tuner-file=acl_tuner.csv
./arm_compute_benchmark --enable-tuner --tuner-file=acl_tuner.csv
</pre><p>If you are importing the <a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml" title="Basic implementation of the OpenCL tuner interface.">CLTuner</a>'results from a file, the new tuned LWS values will be appended to it.</p>
<p>Either you are benchmarking the graph examples or the test cases in the arm_compute_benchmark remember to: </p><pre class="fragment">-# Disable the power management
-# Keep the GPU frequency constant
-# Run multiple times the network (i.e. 10).
</pre><p>If you are not using the graph API or the benchmark infrastructure you will need to manually pass a <a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml" title="Basic implementation of the OpenCL tuner interface.">CLTuner</a> object to <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml" title="Provides global access to a CL context and command queue.">CLScheduler</a> before configuring any function.</p>
<div class="fragment"><div class="line">CLTuner tuner;</div><div class="line"></div><div class="line"><span class="comment">// Setup Scheduler</span></div><div class="line"><a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a9b58d0eb9a2af8e6d7908695e1557d6c">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a46ecf9ef0fe80ba2ed35acfc29856b7d">default_init</a>(&amp;tuner);</div></div><!-- fragment --><p>After the first run, the <a class="el" href="classarm__compute_1_1_c_l_tuner.xhtml" title="Basic implementation of the OpenCL tuner interface.">CLTuner</a>'s results can be exported to a file using the method "save_to_file()".</p><ul>
<li>tuner.save_to_file("results.csv");</li>
</ul>
<p>This file can be also imported using the method "load_from_file("results.csv")".</p><ul>
<li>tuner.load_from_file("results.csv"); </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Nov 27 2020 13:51:01 for Compute Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
