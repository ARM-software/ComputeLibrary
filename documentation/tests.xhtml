<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="robots" content="NOINDEX, NOFOLLOW" /> <!-- Prevent indexing by search engines -->
<title>Compute Library: Validation and benchmarks tests</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Compute Library
   &#160;<span id="projectnumber">17.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.xhtml"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tests.xhtml','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Validation and benchmarks tests </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tests_overview">Overview</a><ul><li class="level2"><a href="#tests_overview_structure">Directory structure</a></li>
<li class="level2"><a href="#tests_overview_fixtures">Fixtures</a><ul><li class="level3"><a href="#tests_overview_fixtures_fixture">Fixture</a></li>
<li class="level3"><a href="#tests_overview_fixtures_data_fixture">Data fixture</a></li>
</ul>
</li>
<li class="level2"><a href="#tests_overview_test_cases">Test cases</a><ul><li class="level3"><a href="#tests_overview_test_cases_test_case">Test case</a></li>
<li class="level3"><a href="#tests_overview_test_cases_fixture_fixture_test_case">Fixture test case</a></li>
<li class="level3"><a href="#tests_overview_test_cases_fixture_register_fixture_test_case">Registering a fixture as test case</a></li>
<li class="level3"><a href="#tests_overview_test_cases_data_test_case">Data test case</a></li>
<li class="level3"><a href="#tests_overview_test_cases_fixture_data_test_case">Fixture data test case</a></li>
<li class="level3"><a href="#tests_overview_test_cases_register_fixture_data_test_case">Registering a fixture as data test case</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#writing_tests">Writing validation tests</a></li>
<li class="level1"><a href="#tests_running_tests">Running tests</a><ul><li class="level2"><a href="#tests_running_tests_benchmarking">Benchmarking</a><ul><li class="level3"><a href="#tests_running_tests_benchmarking_filter">Filter tests</a></li>
<li class="level3"><a href="#tests_running_tests_benchmarking_runtime">Runtime</a></li>
<li class="level3"><a href="#tests_running_tests_benchmarking_output">Output</a></li>
<li class="level3"><a href="#tests_running_tests_benchmarking_mode">Mode</a></li>
<li class="level3"><a href="#tests_running_tests_benchmarking_instruments">Instruments</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tests_overview"></a>
Overview</h1>
<p>Benchmark and validation tests are based on the same framework to setup and run the tests. In addition to running simple, self-contained test functions the framework supports fixtures and data test cases. The former allows to share common setup routines between various backends thus reducing the amount of duplicated code. The latter can be used to parameterize tests or fixtures with different inputs, e.g. different tensor shapes. One limitation is that tests/fixtures cannot be parameterized based on the data type if static type information is needed within the test (e.g. to validate the results).</p>
<h2><a class="anchor" id="tests_overview_structure"></a>
Directory structure</h2>
<pre class="fragment">.
`-- tests &lt;- Top level test directory. All files in here are shared among validation and benchmark.
    |-- framework &lt;- Underlying test framework.
    |-- CL   \
    |-- NEON -&gt; Backend specific files with helper functions etc.
    |-- benchmark &lt;- Top level directory for the benchmarking files.
    |   |-- fixtures &lt;- Fixtures for benchmark tests.
    |   |-- CL &lt;- OpenCL backend test cases on a function level.
    |   |   `-- SYSTEM &lt;- OpenCL system tests, e.g. whole networks
    |   `-- NEON &lt;- Same for NEON
    |       `-- SYSTEM
    |-- datasets &lt;- Datasets for benchmark and validation tests.
    |-- main.cpp &lt;- Main entry point for the tests. Currently shared between validation and benchmarking.
    |-- networks &lt;- Network classes for system level tests.
    `-- validation -&gt; Top level directory for validation files.
        |-- CPP -&gt; C++ reference code
        |-- CL   \
        |-- NEON -&gt; Backend specific test cases
        `-- fixtures -&gt; Fixtures shared among all backends. Used to setup target function and tensors.
</pre><h2><a class="anchor" id="tests_overview_fixtures"></a>
Fixtures</h2>
<p>Fixtures can be used to share common setup, teardown or even run tasks among multiple test cases. For that purpose a fixture can define a <code>setup</code>, <code>teardown</code> and <code>run</code> method. Additionally the constructor and destructor might also be customized.</p>
<p>An instance of the fixture is created immediately before the actual test is executed. After construction the <a class="el" href="classarm__compute_1_1test_1_1framework_1_1_fixture.xhtml#a4fc01d736fe50cf5b977f755b675f11d">framework::Fixture::setup</a> method is called. Then the test function or the fixtures <code>run</code> method is invoked. After test execution the <a class="el" href="classarm__compute_1_1test_1_1framework_1_1_fixture.xhtml#a4adab6322a0276f34a7d656d49fc865c">framework::Fixture::teardown</a> method is called and lastly the fixture is destructed.</p>
<h3><a class="anchor" id="tests_overview_fixtures_fixture"></a>
Fixture</h3>
<p>Fixtures for non-parameterized test are straightforward. The custom fixture class has to inherit from <a class="el" href="classarm__compute_1_1test_1_1framework_1_1_fixture.xhtml">framework::Fixture</a> and choose to implement any of the <code>setup</code>, <code>teardown</code> or <code>run</code> methods. None of the methods takes any arguments or returns anything. </p><pre class="fragment">class CustomFixture : public framework::Fixture
{
    void setup()
    {
        _ptr = malloc(4000);
    }

    void run()
    {
        ARM_COMPUTE_ASSERT(_ptr != nullptr);
    }

    void teardown()
    {
        free(_ptr);
    }

    void *_ptr;
};
</pre><h3><a class="anchor" id="tests_overview_fixtures_data_fixture"></a>
Data fixture</h3>
<p>The advantage of a parameterized fixture is that arguments can be passed to the setup method at runtime. To make this possible the setup method has to be a template with a type parameter for every argument (though the template parameter doesn't have to be used). All other methods remain the same. </p><pre class="fragment">class CustomFixture : public framework::Fixture
{
#ifdef ALTERNATIVE_DECLARATION
    template &lt;typename ...&gt;
    void setup(size_t size)
    {
        _ptr = malloc(size);
    }
#else
    template &lt;typename T&gt;
    void setup(T size)
    {
        _ptr = malloc(size);
    }
#endif

    void run()
    {
        ARM_COMPUTE_ASSERT(_ptr != nullptr);
    }

    void teardown()
    {
        free(_ptr);
    }

    void *_ptr;
};
</pre><h2><a class="anchor" id="tests_overview_test_cases"></a>
Test cases</h2>
<p>All following commands can be optionally prefixed with <code>EXPECTED_FAILURE_</code> or <code>DISABLED_</code>.</p>
<h3><a class="anchor" id="tests_overview_test_cases_test_case"></a>
Test case</h3>
<p>A simple test case function taking no inputs and having no (shared) state.</p>
<ul>
<li>First argument is the name of the test case (has to be unique within the enclosing test suite).</li>
<li>Second argument is the dataset mode in which the test will be active.</li>
</ul>
<pre class="fragment">TEST_CASE(TestCaseName, DatasetMode::PRECOMMIT)
{
    ARM_COMPUTE_ASSERT_EQUAL(1 + 1, 2);
}
</pre><h3><a class="anchor" id="tests_overview_test_cases_fixture_fixture_test_case"></a>
Fixture test case</h3>
<p>A simple test case function taking no inputs that inherits from a fixture. The test case will have access to all public and protected members of the fixture. Only the setup and teardown methods of the fixture will be used. The body of this function will be used as test function.</p>
<ul>
<li>First argument is the name of the test case (has to be unique within the enclosing test suite).</li>
<li>Second argument is the class name of the fixture.</li>
<li>Third argument is the dataset mode in which the test will be active.</li>
</ul>
<pre class="fragment">class FixtureName : public framework::Fixture
{
    public:
        void setup() override
        {
            _one = 1;
        }

    protected:
        int _one;
};

FIXTURE_TEST_CASE(TestCaseName, FixtureName, DatasetMode::PRECOMMIT)
{
    ARM_COMPUTE_ASSERT_EQUAL(_one + 1, 2);
}
</pre><h3><a class="anchor" id="tests_overview_test_cases_fixture_register_fixture_test_case"></a>
Registering a fixture as test case</h3>
<p>Allows to use a fixture directly as test case. Instead of defining a new test function the run method of the fixture will be executed.</p>
<ul>
<li>First argument is the name of the test case (has to be unique within the enclosing test suite).</li>
<li>Second argument is the class name of the fixture.</li>
<li>Third argument is the dataset mode in which the test will be active.</li>
</ul>
<pre class="fragment">class FixtureName : public framework::Fixture
{
    public:
        void setup() override
        {
            _one = 1;
        }

        void run() override
        {
            ARM_COMPUTE_ASSERT_EQUAL(_one + 1, 2);
        }

    protected:
        int _one;
};

REGISTER_FIXTURE_TEST_CASE(TestCaseName, FixtureName, DatasetMode::PRECOMMIT);
</pre><h3><a class="anchor" id="tests_overview_test_cases_data_test_case"></a>
Data test case</h3>
<p>A parameterized test case function that has no (shared) state. The dataset will be used to generate versions of the test case with different inputs.</p>
<ul>
<li>First argument is the name of the test case (has to be unique within the enclosing test suite).</li>
<li>Second argument is the dataset mode in which the test will be active.</li>
<li>Third argument is the dataset.</li>
<li>Further arguments specify names of the arguments to the test function. The number must match the arity of the dataset.</li>
</ul>
<pre class="fragment">DATA_TEST_CASE(TestCaseName, DatasetMode::PRECOMMIT, framework::make("Numbers", {1, 2, 3}), num)
{
    ARM_COMPUTE_ASSERT(num &lt; 4);
}
</pre><h3><a class="anchor" id="tests_overview_test_cases_fixture_data_test_case"></a>
Fixture data test case</h3>
<p>A parameterized test case that inherits from a fixture. The test case will have access to all public and protected members of the fixture. Only the setup and teardown methods of the fixture will be used. The setup method of the fixture needs to be a template and has to accept inputs from the dataset as arguments. The body of this function will be used as test function. The dataset will be used to generate versions of the test case with different inputs.</p>
<ul>
<li>First argument is the name of the test case (has to be unique within the enclosing test suite).</li>
<li>Second argument is the class name of the fixture.</li>
<li>Third argument is the dataset mode in which the test will be active.</li>
<li>Fourth argument is the dataset.</li>
</ul>
<pre class="fragment">class FixtureName : public framework::Fixture
{
    public:
        template &lt;typename T&gt;
        void setup(T num)
        {
            _num = num;
        }

    protected:
        int _num;
};

FIXTURE_DATA_TEST_CASE(TestCaseName, FixtureName, DatasetMode::PRECOMMIT, framework::make("Numbers", {1, 2, 3}))
{
    ARM_COMPUTE_ASSERT(_num &lt; 4);
}
</pre><h3><a class="anchor" id="tests_overview_test_cases_register_fixture_data_test_case"></a>
Registering a fixture as data test case</h3>
<p>Allows to use a fixture directly as parameterized test case. Instead of defining a new test function the run method of the fixture will be executed. The setup method of the fixture needs to be a template and has to accept inputs from the dataset as arguments. The dataset will be used to generate versions of the test case with different inputs.</p>
<ul>
<li>First argument is the name of the test case (has to be unique within the enclosing test suite).</li>
<li>Second argument is the class name of the fixture.</li>
<li>Third argument is the dataset mode in which the test will be active.</li>
<li>Fourth argument is the dataset.</li>
</ul>
<pre class="fragment">class FixtureName : public framework::Fixture
{
    public:
        template &lt;typename T&gt;
        void setup(T num)
        {
            _num = num;
        }

        void run() override
        {
            ARM_COMPUTE_ASSERT(_num &lt; 4);
        }

    protected:
        int _num;
};

REGISTER_FIXTURE_DATA_TEST_CASE(TestCaseName, FixtureName, DatasetMode::PRECOMMIT, framework::make("Numbers", {1, 2, 3}));
</pre><h1><a class="anchor" id="writing_tests"></a>
Writing validation tests</h1>
<p>Before starting a new test case have a look at the existing ones. They should provide a good overview how test cases are structured.</p>
<ul>
<li>The C++ reference needs to be added to <code>tests/validation/CPP/</code>. The reference function is typically a template parameterized by the underlying value type of the <code><a class="el" href="classarm__compute_1_1test_1_1_simple_tensor.xhtml" title="Simple tensor object that stores elements in a consecutive chunk of memory. ">SimpleTensor</a></code>. This makes it easy to specialise for different data types.</li>
<li>If all backends have a common interface it makes sense to share the setup code. This can be done by adding a fixture in <code>tests/validation/fixtures/</code>. Inside of the <code>setup</code> method of a fixture the tensors can be created and initialised and the function can be configured and run. The actual test will only have to validate the results. To be shared among multiple backends the fixture class is usually a template that accepts the specific types (data, tensor class, function class etc.) as parameters.</li>
<li>The actual test cases need to be added for each backend individually. Typically the will be multiple tests for different data types and for different execution modes, e.g. precommit and nightly.</li>
</ul>
<h1><a class="anchor" id="tests_running_tests"></a>
Running tests</h1>
<h2><a class="anchor" id="tests_running_tests_benchmarking"></a>
Benchmarking</h2>
<h3><a class="anchor" id="tests_running_tests_benchmarking_filter"></a>
Filter tests</h3>
<p>All tests can be run by invoking </p><pre class="fragment">./arm_compute_benchmark ./data
</pre><p>where <code>./data</code> contains the assets needed by the tests.</p>
<p>If only a subset of the tests has to be executed the <code>--filter</code> option takes a regular expression to select matching tests. </p><pre class="fragment">./arm_compute_benchmark --filter='NEON/.*AlexNet' ./data
</pre><p>Additionally each test has a test id which can be used as a filter, too. However, the test id is not guaranteed to be stable when new tests are added. Only for a specific build the same the test will keep its id. </p><pre class="fragment">./arm_compute_benchmark --filter-id=10 ./data
</pre><p>All available tests can be displayed with the <code>--list-tests</code> switch. </p><pre class="fragment">./arm_compute_benchmark --list-tests
</pre><p>More options can be found in the <code>--help</code> message.</p>
<h3><a class="anchor" id="tests_running_tests_benchmarking_runtime"></a>
Runtime</h3>
<p>By default every test is run once on a single thread. The number of iterations can be controlled via the <code>--iterations</code> option and the number of threads via <code>--threads</code>.</p>
<h3><a class="anchor" id="tests_running_tests_benchmarking_output"></a>
Output</h3>
<p>By default the benchmarking results are printed in a human readable format on the command line. The colored output can be disabled via <code>--no-color-output</code>. As an alternative output format JSON is supported and can be selected via <code>--log-format=json</code>. To write the output to a file instead of stdout the <code>--log-file</code> option can be used.</p>
<h3><a class="anchor" id="tests_running_tests_benchmarking_mode"></a>
Mode</h3>
<p>Tests contain different datasets of different sizes, some of which will take several hours to run. You can select which datasets to use by using the <code>--mode</code> option, we recommed you use <code>--mode=precommit</code> to start with.</p>
<h3><a class="anchor" id="tests_running_tests_benchmarking_instruments"></a>
Instruments</h3>
<p>You can use the <code>--instruments</code> option to select one or more instruments to measure the execution time of the benchmark tests.</p>
<p><code>PMU</code> will try to read the CPU PMU events from the kernel (They need to be enabled on your platform)</p>
<p><code>MALI</code> will try to collect Mali hardware performance counters. (You need to have a recent enough Mali driver)</p>
<p><code>WALL_CLOCK</code> will measure time using <code>gettimeofday</code>: this should work on all platforms.</p>
<p>You can pass a combinations of these instruments: <code>--instruments=PMU,MALI,WALL_CLOCK</code></p>
<dl class="section note"><dt>Note</dt><dd>You need to make sure the instruments have been selected at compile time using the <code>pmu=1</code> or <code>mali=1</code> scons options. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 14 2017 23:48:34 for Compute Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
