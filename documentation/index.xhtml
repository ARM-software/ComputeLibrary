<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="robots" content="NOINDEX, NOFOLLOW" /> <!-- Prevent indexing by search engines -->
<title>Compute Library: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Compute Library
   &#160;<span id="projectnumber">17.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.xhtml"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.xhtml','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#S0_1_contact">Contact / Support</a></li>
<li class="level1"><a href="#S0_2_prebuilt_binaries">Pre-built binaries</a></li>
<li class="level1"><a href="#S1_file_organisation">File organisation</a></li>
<li class="level1"><a href="#S2_versions_changelog">Release versions and changelog</a><ul><li class="level2"><a href="#S2_1_versions">Release versions</a></li>
<li class="level2"><a href="#S2_2_changelog">Changelog</a></li>
</ul>
</li>
<li class="level1"><a href="#S3_how_to_build">How to build the library and the examples</a><ul><li class="level2"><a href="#S3_1_build_options">Build options</a></li>
<li class="level2"><a href="#S3_2_linux">Building for Linux</a><ul><li class="level3"><a href="#S3_2_1_library">How to build the library ?</a></li>
<li class="level3"><a href="#S3_2_2_examples">How to manually build the examples ?</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_3_android">Building for Android</a><ul><li class="level3"><a href="#S3_3_1_library">How to build the library ?</a></li>
<li class="level3"><a href="#S3_3_2_examples">How to manually build the examples ?</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_4_bare_metal">Building for bare metal</a><ul><li class="level3"><a href="#S3_4_1_library">How to build the library ?</a></li>
<li class="level3"><a href="#S3_4_2_examples">How to manually build the examples ?</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_5_windows_host">Building on a Windows host system</a><ul><li class="level3"><a href="#S3_5_1_ubuntu_on_windows">Bash on Ubuntu on Windows</a></li>
<li class="level3"><a href="#S3_5_2_cygwin">Cygwin</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_6_cl_stub_library">The OpenCL stub library</a></li>
<li class="level2"><a href="#S3_7_gles_stub_library">The Linux OpenGLES and EGL stub libraries</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The Computer Vision and Machine Learning library is a set of functions optimised for both ARM CPUs and GPUs using SIMD technologies.Several builds of the library are available using various configurations:</p><ul>
<li>OS: Linux, Android or bare metal.</li>
<li>Architecture: armv7a (32bit) or arm64-v8a (64bit)</li>
<li>Technology: NEON / OpenCL / GLES_COMPUTE / NEON and OpenCL and GLES_COMPUTE</li>
<li>Debug / Asserts / Release: Use a build with asserts enabled to debug your application and enable extra validation. Once you are sure your application works as expected you can switch to a release build of the library for maximum performance.</li>
</ul>
<h1><a class="anchor" id="S0_1_contact"></a>
Contact / Support</h1>
<p>Please email <a href="#" onclick="location.href='mai'+'lto:'+'dev'+'el'+'ope'+'r@'+'arm'+'.c'+'om'; return false;">devel<span style="display: none;">.nosp@m.</span>oper<span style="display: none;">.nosp@m.</span>@arm.<span style="display: none;">.nosp@m.</span>com</a></p>
<p>In order to facilitate the work of the support team please provide the build information of the library you are using. To get the version of the library you are using simply run: </p><pre class="fragment">$ strings android-armv7a-cl-asserts/libarm_compute.so | grep arm_compute_version
arm_compute_version=v16.12 Build options: {'embed_kernels': '1', 'opencl': '1', 'arch': 'armv7a', 'neon': '0', 'asserts': '1', 'debug': '0', 'os': 'android', 'Werror': '1'} Git hash=f51a545d4ea12a9059fe4e598a092f1fd06dc858
</pre><h1><a class="anchor" id="S0_2_prebuilt_binaries"></a>
Pre-built binaries</h1>
<p>For each release we provide some pre-built binaries of the library <a href="https://github.com/ARM-software/ComputeLibrary/releases">here</a></p>
<p>These binaries have been built using the following toolchains:</p><ul>
<li>Linux armv7a: gcc-linaro-arm-linux-gnueabihf-4.9-2014.07_linux</li>
<li>Linux arm64-v8a: gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu</li>
<li>Android armv7a: clang++ / gnustl NDK r14</li>
<li>Android am64-v8a: clang++ / gnustl NDK r14</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Make sure to use a compatible toolchain to build your application or you will get some std::bad_alloc errors at runtime.</dd></dl>
<h1><a class="anchor" id="S1_file_organisation"></a>
File organisation</h1>
<p>This archive contains:</p><ul>
<li>The <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a> header and source files</li>
<li>The latest Khronos OpenCL 1.2 C headers from the <a href="https://www.khronos.org/registry/cl/">Khronos OpenCL registry</a></li>
<li>The latest Khronos cl2.hpp from the <a href="https://www.khronos.org/registry/cl/">Khronos OpenCL registry</a> (API version 2.1 when this document was written)</li>
<li>The latest Khronos OpenGL ES 3.1 C headers from the <a href="https://www.khronos.org/registry/gles/">Khronos OpenGL ES registry</a></li>
<li>The latest Khronos EGL 1.5 C headers from the <a href="https://www.khronos.org/registry/gles/">Khronos EGL registry</a></li>
<li>The sources for a stub version of libOpenCL.so, libGLESv1_CM.so, libGLESv2.so and libEGL.so to help you build your application.</li>
<li>An examples folder containing a few examples to compile and link against the library.</li>
<li>A <a class="el" href="dir_cbdb8362360e11eafe2fa3bc74cf0ffd.xhtml">utils</a> folder containing headers with some boiler plate code used by the examples.</li>
<li>This documentation.</li>
</ul>
<p>You should have the following file organisation: </p><pre class="fragment">.
├── arm_compute --&gt; All the arm_compute headers
│   ├── core
│   │   ├── CL
│   │   │   ├── CLKernelLibrary.h --&gt; Manages all the OpenCL kernels compilation and caching, provides accessors for the OpenCL Context.
│   │   │   ├── CLKernels.h --&gt; Includes all the OpenCL kernels at once
│   │   │   ├── CL specialisation of all the generic objects interfaces (ICLTensor, ICLImage, etc.)
│   │   │   ├── kernels --&gt; Folder containing all the OpenCL kernels
│   │   │   │   └── CL*Kernel.h
│   │   │   └── OpenCL.h --&gt; Wrapper to configure the Khronos OpenCL C++ header
│   │   ├── CPP
│   │   │   ├── CPPKernels.h --&gt; Includes all the CPP kernels at once
│   │   │   └── kernels --&gt; Folder containing all the CPP kernels
│   │   │       └── CPP*Kernel.h
│   │   ├── GLES_COMPUTE
│   │   │   ├── GCKernelLibrary.h --&gt; Manages all the GLES kernels compilation and caching, provides accessors for the GLES Context.
│   │   │   ├── GCKernels.h --&gt; Includes all the GLES kernels at once
│   │   │   ├── GLES specialisation of all the generic objects interfaces (IGCTensor, IGCImage, etc.)
│   │   │   ├── kernels --&gt; Folder containing all the GLES kernels
│   │   │   │   └── GC*Kernel.h
│   │   │   └── OpenGLES.h --&gt; Wrapper to configure the Khronos EGL and OpenGL ES C header
│   │   ├── NEON
│   │   │   ├── kernels --&gt; Folder containing all the NEON kernels
│   │   │   │   ├── arm64 --&gt; Folder containing the interfaces for the assembly arm64 NEON kernels
│   │   │   │   ├── arm32 --&gt; Folder containing the interfaces for the assembly arm32 NEON kernels
│   │   │   │   ├── assembly --&gt; Folder containing the NEON assembly routines.
│   │   │   │   └── NE*Kernel.h
│   │   │   └── NEKernels.h --&gt; Includes all the NEON kernels at once
│   │   ├── All common basic types (Types.h, Window, Coordinates, Iterator, etc.)
│   │   ├── All generic objects interfaces (ITensor, IImage, etc.)
│   │   └── Objects metadata classes (ImageInfo, TensorInfo, MultiImageInfo)
│   ├── graph
│   │   ├── CL --&gt; OpenCL specific operations
│   │   │   └── CLMap.h / CLUnmap.h
│   │   ├── nodes
│   │   │   └── The various nodes supported by the graph API
│   │   ├── Nodes.h --&gt; Includes all the Graph nodes at once.
│   │   └── Graph objects ( INode, ITensorAccessor, Graph, etc.)
│   └── runtime
│       ├── CL
│       │   ├── CL objects &amp; allocators (CLArray, CLImage, CLTensor, etc.)
│       │   ├── functions --&gt; Folder containing all the OpenCL functions
│       │   │   └── CL*.h
│       │   ├── CLScheduler.h --&gt; Interface to enqueue OpenCL kernels and get/set the OpenCL CommandQueue and ICLTuner.
│       │   └── CLFunctions.h --&gt; Includes all the OpenCL functions at once
│       ├── CPP
│       │   ├── CPPKernels.h --&gt; Includes all the CPP functions at once.
│       │   └── CPPScheduler.h --&gt; Basic pool of threads to execute CPP/NEON code on several cores in parallel
│       ├── GLES_COMPUTE
│       │   ├── GLES objects &amp; allocators (GCArray, GCImage, GCTensor, etc.)
│       │   ├── functions --&gt; Folder containing all the GLES functions
│       │   │   └── GC*.h
│       │   ├── GCScheduler.h --&gt; Interface to enqueue GLES kernels and get/set the GLES CommandQueue.
│       │   └── GCFunctions.h --&gt; Includes all the GLES functions at once
│       ├── NEON
│       │   ├── functions --&gt; Folder containing all the NEON functions
│       │   │   └── NE*.h
│       │   └── NEFunctions.h --&gt; Includes all the NEON functions at once
│       ├── OMP
│       │   └── OMPScheduler.h --&gt; OpenMP scheduler (Alternative to the CPPScheduler)
│       ├── Memory manager files (LifetimeManager, PoolManager, etc.)
│       └── Basic implementations of the generic object interfaces (Array, Image, Tensor, etc.)
├── documentation
│   ├── index.xhtml
│   └── ...
├── documentation.xhtml -&gt; documentation/index.xhtml
├── examples
│   ├── cl_*.cpp --&gt; OpenCL examples
│   ├── gc_*.cpp --&gt; GLES compute shaders examples
│   ├── graph_*.cpp --&gt; Graph examples
│   ├── neoncl_*.cpp --&gt; NEON / OpenCL interoperability examples
│   └── neon_*.cpp --&gt; NEON examples
├── include
│   ├── CL
│   │   └── Khronos OpenCL C headers and C++ wrapper
│   ├── half --&gt; FP16 library available from http://half.sourceforge.net
│   ├── libnpy --&gt; Library to load / write npy buffers, available from https://github.com/llohse/libnpy
│   └── linux --&gt; Headers only needed for Linux builds
│       └── Khronos EGL and OpenGLES headers
├── opencl-1.2-stubs
│   └── opencl_stubs.c --&gt; OpenCL stubs implementation
├── opengles-3.1-stubs
│   ├── EGL.c --&gt; EGL stubs implementation
│   └── GLESv2.c --&gt; GLESv2 stubs implementation
├── scripts
│   ├── caffe_data_extractor.py --&gt; Basic script to export weights from Caffe to npy files
│   └── tensorflow_data_extractor.py --&gt; Basic script to export weights from Tensor Flow to npy files
├── src
│   ├── core
│   │   └── ... (Same structure as headers)
│   │       ├── CL
│   │       │   └── cl_kernels --&gt; All the OpenCL kernels
│   │       └── GLES_COMPUTE
│   │           └── cs_shaders --&gt; All the OpenGL ES Compute Shaders
│   ├── graph
│   │   └── ... (Same structure as headers)
│   └── runtime
│       └── ... (Same structure as headers)
├── support
│   └── Various headers to work around toolchains / platform issues.
├── tests
│   ├── All test related files shared between validation and benchmark
│   ├── CL --&gt; OpenCL accessors
│   ├── GLES_COMPUTE --&gt; GLES accessors
│   ├── NEON --&gt; NEON accessors
│   ├── benchmark --&gt; Sources for benchmarking
│   │   ├── Benchmark specific files
│   │   ├── CL --&gt; OpenCL benchmarking tests
│   │   ├── GLES_COMPUTE --&gt; GLES benchmarking tests
│   │   └── NEON --&gt; NEON benchmarking tests
│   ├── datasets
│   │   └── Datasets for all the validation / benchmark tests, layer configurations for various networks, etc.
│   ├── framework
│   │   └── Boiler plate code for both validation and benchmark test suites (Command line parsers, instruments, output loggers, etc.)
│   ├── networks
│   │   └── Examples of how to instantiate networks.
│   ├── validation --&gt; Sources for validation
│   │   ├── Validation specific files
│   │   ├── CL --&gt; OpenCL validation tests
│   │   ├── GLES_COMPUTE --&gt; GLES validation tests
│   │   ├── CPP --&gt; C++ reference implementations
│   │   ├── fixtures
│   │   │   └── Fixtures to initialise and run the runtime Functions.
│   │   └── NEON --&gt; NEON validation tests
│   └── dataset --&gt; Datasets defining common sets of input parameters
└── utils --&gt; Boiler plate code used by examples
    └── Various utilities to print types, load / store assets, etc.
</pre><h1><a class="anchor" id="S2_versions_changelog"></a>
Release versions and changelog</h1>
<h2><a class="anchor" id="S2_1_versions"></a>
Release versions</h2>
<p>All releases are numbered vYY.MM Where YY are the last two digits of the year, and MM the month number. If there is more than one release in a month then an extra sequential number is appended at the end: </p><pre class="fragment">v17.03 (First release of March 2017)
v17.03.1 (Second release of March 2017)
v17.04 (First release of April 2017)
</pre><dl class="section note"><dt>Note</dt><dd>We're aiming at releasing one major public release with new features per quarter. All releases in between will only contain bug fixes.</dd></dl>
<h2><a class="anchor" id="S2_2_changelog"></a>
Changelog</h2>
<p>v17.12 Public major release</p><ul>
<li>Most machine learning functions on OpenCL support the new data type QASYMM8</li>
<li>Introduced logging interface</li>
<li>Introduced opencl timer</li>
<li>Reworked GEMMLowp interface</li>
<li>Added new NEON assembly kernels for GEMMLowp, SGEMM and HGEMM</li>
<li>Added validation method for most Machine Learning kernels / functions</li>
<li>Added new graph examples such as googlenet, mobilenet, squeezenet, vgg16 and vgg19</li>
<li>Added sgemm example for OpenCL</li>
<li>Added absolute difference example for GLES compute</li>
<li>Added new tests and benchmarks in validation and benchmark frameworks</li>
<li>Added new kernels / functions for GLES compute</li>
<li>New OpenGL ES kernels / functions<ul>
<li><a class="el" href="classarm__compute_1_1_g_c_absolute_difference_kernel.xhtml">arm_compute::GCAbsoluteDifferenceKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_absolute_difference.xhtml">arm_compute::GCAbsoluteDifference</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_activation_layer_kernel.xhtml">arm_compute::GCActivationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_activation_layer.xhtml">arm_compute::GCActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_batch_normalization_layer_kernel.xhtml">arm_compute::GCBatchNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_batch_normalization_layer.xhtml">arm_compute::GCBatchNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_col2_im_kernel.xhtml">arm_compute::GCCol2ImKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_depth_concatenate_layer_kernel.xhtml">arm_compute::GCDepthConcatenateLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_depth_concatenate_layer.xhtml">arm_compute::GCDepthConcatenateLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_direct_convolution_layer_kernel.xhtml">arm_compute::GCDirectConvolutionLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_direct_convolution_layer.xhtml">arm_compute::GCDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_dropout_layer_kernel.xhtml">arm_compute::GCDropoutLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_dropout_layer.xhtml">arm_compute::GCDropoutLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_fill_border_kernel.xhtml">arm_compute::GCFillBorderKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_fill_border.xhtml">arm_compute::GCFillBorder</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_interleave4x4_kernel.xhtml">arm_compute::GCGEMMInterleave4x4Kernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_interleave4x4.xhtml">arm_compute::GCGEMMInterleave4x4</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_matrix_accumulate_biases_kernel.xhtml">arm_compute::GCGEMMMatrixAccumulateBiasesKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_matrix_addition_kernel.xhtml">arm_compute::GCGEMMMatrixAdditionKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_matrix_multiply_kernel.xhtml">arm_compute::GCGEMMMatrixMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m.xhtml">arm_compute::GCGEMM</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_transpose1x_w_kernel.xhtml">arm_compute::GCGEMMTranspose1xWKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_g_e_m_m_transpose1x_w.xhtml">arm_compute::GCGEMMTranspose1xW</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_im2_col_kernel.xhtml">arm_compute::GCIm2ColKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_normalization_layer_kernel.xhtml">arm_compute::GCNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_normalization_layer.xhtml">arm_compute::GCNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_pixel_wise_multiplication_kernel.xhtml">arm_compute::GCPixelWiseMultiplicationKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_pixel_wise_multiplication.xhtml">arm_compute::GCPixelWiseMultiplication</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_pooling_layer_kernel.xhtml">arm_compute::GCPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_pooling_layer.xhtml">arm_compute::GCPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_logits1_d_max_kernel.xhtml">arm_compute::GCLogits1DMaxKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_logits1_d_shift_exp_sum_kernel.xhtml">arm_compute::GCLogits1DShiftExpSumKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_logits1_d_norm_kernel.xhtml">arm_compute::GCLogits1DNormKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_softmax_layer.xhtml">arm_compute::GCSoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_g_c_transpose_kernel.xhtml">arm_compute::GCTransposeKernel</a> / <a class="el" href="classarm__compute_1_1_g_c_transpose.xhtml">arm_compute::GCTranspose</a></li>
</ul>
</li>
<li>New NEON kernels / functions<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_a_arch64_a53_kernel.xhtml">arm_compute::NEGEMMLowpAArch64A53Kernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_a_arch64_kernel.xhtml">arm_compute::NEGEMMLowpAArch64Kernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_a_arch64_v8_p4_kernel.xhtml">arm_compute::NEGEMMLowpAArch64V8P4Kernel</a> / arm_compute::NEGEMMInterleavedBlockedKernel / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_assembly_matrix_multiply_core.xhtml">arm_compute::NEGEMMLowpAssemblyMatrixMultiplyCore</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_g_e_m_m_a_arch64_f_p16_kernel.xhtml">arm_compute::NEHGEMMAArch64FP16Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer3x3_kernel.xhtml">arm_compute::NEDepthwiseConvolutionLayer3x3Kernel</a> / <a class="el" href="classarm__compute_1_1_n_e_depthwise_im2_col_kernel.xhtml">arm_compute::NEDepthwiseIm2ColKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_vector_multiply_kernel.xhtml">arm_compute::NEGEMMMatrixVectorMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_depthwise_vector_to_tensor_kernel.xhtml">arm_compute::NEDepthwiseVectorToTensorKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_depthwise_convolution_layer.xhtml">arm_compute::NEDepthwiseConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_offset_contribution_kernel.xhtml">arm_compute::NEGEMMLowpOffsetContributionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_a_reduction_kernel.xhtml">arm_compute::NEGEMMLowpMatrixAReductionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_b_reduction_kernel.xhtml">arm_compute::NEGEMMLowpMatrixBReductionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_multiply_core.xhtml">arm_compute::NEGEMMLowpMatrixMultiplyCore</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_by_fixed_point_kernel.xhtml">arm_compute::NEGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPointKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_by_fixed_point.xhtml">arm_compute::NEGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPoint</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_kernel.xhtml">arm_compute::NEGEMMLowpQuantizeDownInt32ToUint8ScaleKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale.xhtml">arm_compute::NEGEMMLowpQuantizeDownInt32ToUint8Scale</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_winograd_layer_kernel.xhtml">arm_compute::NEWinogradLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_winograd_layer.xhtml">arm_compute::NEWinogradLayer</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_offset_contribution_kernel.xhtml">arm_compute::CLGEMMLowpOffsetContributionKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_a_reduction_kernel.xhtml">arm_compute::CLGEMMLowpMatrixAReductionKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_b_reduction_kernel.xhtml">arm_compute::CLGEMMLowpMatrixBReductionKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_core.xhtml">arm_compute::CLGEMMLowpMatrixMultiplyCore</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_by_fixed_point_kernel.xhtml">arm_compute::CLGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPointKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_by_fixed_point.xhtml">arm_compute::CLGEMMLowpQuantizeDownInt32ToUint8ScaleByFixedPoint</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale_kernel.xhtml">arm_compute::CLGEMMLowpQuantizeDownInt32ToUint8ScaleKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_quantize_down_int32_to_uint8_scale.xhtml">arm_compute::CLGEMMLowpQuantizeDownInt32ToUint8Scale</a></li>
</ul>
</li>
<li>New graph nodes for NEON and OpenCL<ul>
<li><a class="el" href="classarm__compute_1_1graph_1_1_branch_layer.xhtml">arm_compute::graph::BranchLayer</a></li>
<li><a class="el" href="classarm__compute_1_1graph_1_1_depth_convert_layer.xhtml">arm_compute::graph::DepthConvertLayer</a></li>
<li><a class="el" href="classarm__compute_1_1graph_1_1_depthwise_convolution_layer.xhtml">arm_compute::graph::DepthwiseConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1graph_1_1_dequantization_layer.xhtml">arm_compute::graph::DequantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1graph_1_1_flatten_layer.xhtml">arm_compute::graph::FlattenLayer</a></li>
<li><a class="el" href="classarm__compute_1_1graph_1_1_quantization_layer.xhtml">arm_compute::graph::QuantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1graph_1_1_reshape_layer.xhtml">arm_compute::graph::ReshapeLayer</a></li>
</ul>
</li>
</ul>
<p>v17.10 Public maintenance release</p><ul>
<li>Bug fixes:<ul>
<li>Check the maximum local workgroup size supported by OpenCL devices</li>
<li>Minor documentation updates (Fixed instructions to build the examples)</li>
<li>Introduced a <a class="el" href="classarm__compute_1_1graph_1_1_graph_context.xhtml" title="Graph context. ">arm_compute::graph::GraphContext</a></li>
<li>Added a few new Graph nodes, support for branches and grouping.</li>
<li>Automatically enable cl_printf in debug builds</li>
<li>Fixed bare metal builds for armv7a</li>
<li>Added AlexNet and cartoon effect examples</li>
<li>Fixed library builds: libraries are no longer built as supersets of each other.(It means application using the Runtime part of the library now need to link against both libarm_compute_core and libarm_compute)</li>
</ul>
</li>
</ul>
<p>v17.09 Public major release</p><ul>
<li>Experimental Graph support: initial implementation of a simple stream API to easily chain machine learning layers.</li>
<li>Memory Manager (<a class="el" href="classarm__compute_1_1_blob_lifetime_manager.xhtml">arm_compute::BlobLifetimeManager</a>, <a class="el" href="classarm__compute_1_1_blob_memory_pool.xhtml">arm_compute::BlobMemoryPool</a>, <a class="el" href="classarm__compute_1_1_i_lifetime_manager.xhtml">arm_compute::ILifetimeManager</a>, <a class="el" href="classarm__compute_1_1_i_memory_group.xhtml">arm_compute::IMemoryGroup</a>, <a class="el" href="classarm__compute_1_1_i_memory_manager.xhtml">arm_compute::IMemoryManager</a>, <a class="el" href="classarm__compute_1_1_i_memory_pool.xhtml">arm_compute::IMemoryPool</a>, <a class="el" href="classarm__compute_1_1_i_pool_manager.xhtml">arm_compute::IPoolManager</a>, <a class="el" href="classarm__compute_1_1_memory_manager_on_demand.xhtml">arm_compute::MemoryManagerOnDemand</a>, <a class="el" href="classarm__compute_1_1_pool_manager.xhtml">arm_compute::PoolManager</a>)</li>
<li>New validation and benchmark frameworks (Boost and Google frameworks replaced by homemade framework).</li>
<li>Most machine learning functions support both fixed point 8 and 16 bit (QS8, QS16) for both NEON and OpenCL.</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_assembly_base_kernel.xhtml">arm_compute::NEGEMMAssemblyBaseKernel</a> <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_a_arch64_kernel.xhtml">arm_compute::NEGEMMAArch64Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_dequantization_layer_kernel.xhtml">arm_compute::NEDequantizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_dequantization_layer.xhtml">arm_compute::NEDequantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_floor_kernel.xhtml">arm_compute::NEFloorKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_floor.xhtml">arm_compute::NEFloor</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_l2_normalize_layer_kernel.xhtml">arm_compute::NEL2NormalizeLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_l2_normalize_layer.xhtml">arm_compute::NEL2NormalizeLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_quantization_layer_kernel.xhtml">arm_compute::NEQuantizationLayerKernel</a> <a class="el" href="classarm__compute_1_1_n_e_min_max_layer_kernel.xhtml">arm_compute::NEMinMaxLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_quantization_layer.xhtml">arm_compute::NEQuantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_r_o_i_pooling_layer_kernel.xhtml">arm_compute::NEROIPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_r_o_i_pooling_layer.xhtml">arm_compute::NEROIPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reduction_operation_kernel.xhtml">arm_compute::NEReductionOperationKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_reduction_operation.xhtml">arm_compute::NEReductionOperation</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_reshape_layer_kernel.xhtml">arm_compute::NEReshapeLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_reshape_layer.xhtml">arm_compute::NEReshapeLayer</a></li>
</ul>
</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3_kernel.xhtml">arm_compute::CLDepthwiseConvolutionLayer3x3Kernel</a> <a class="el" href="classarm__compute_1_1_c_l_depthwise_im2_col_kernel.xhtml">arm_compute::CLDepthwiseIm2ColKernel</a> <a class="el" href="classarm__compute_1_1_c_l_depthwise_vector_to_tensor_kernel.xhtml">arm_compute::CLDepthwiseVectorToTensorKernel</a> <a class="el" href="classarm__compute_1_1_c_l_depthwise_weights_reshape_kernel.xhtml">arm_compute::CLDepthwiseWeightsReshapeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer3x3.xhtml">arm_compute::CLDepthwiseConvolutionLayer3x3</a> <a class="el" href="classarm__compute_1_1_c_l_depthwise_convolution_layer.xhtml">arm_compute::CLDepthwiseConvolutionLayer</a> <a class="el" href="classarm__compute_1_1_c_l_depthwise_separable_convolution_layer.xhtml">arm_compute::CLDepthwiseSeparableConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_dequantization_layer_kernel.xhtml">arm_compute::CLDequantizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_dequantization_layer.xhtml">arm_compute::CLDequantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_direct_convolution_layer_kernel.xhtml">arm_compute::CLDirectConvolutionLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_direct_convolution_layer.xhtml">arm_compute::CLDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_flatten_layer.xhtml">arm_compute::CLFlattenLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_floor_kernel.xhtml">arm_compute::CLFloorKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_floor.xhtml">arm_compute::CLFloor</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_transpose1x_w.xhtml">arm_compute::CLGEMMTranspose1xW</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_vector_multiply_kernel.xhtml">arm_compute::CLGEMMMatrixVectorMultiplyKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_l2_normalize_layer_kernel.xhtml">arm_compute::CLL2NormalizeLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_l2_normalize_layer.xhtml">arm_compute::CLL2NormalizeLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_quantization_layer_kernel.xhtml">arm_compute::CLQuantizationLayerKernel</a> <a class="el" href="classarm__compute_1_1_c_l_min_max_layer_kernel.xhtml">arm_compute::CLMinMaxLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_quantization_layer.xhtml">arm_compute::CLQuantizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_r_o_i_pooling_layer_kernel.xhtml">arm_compute::CLROIPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_r_o_i_pooling_layer.xhtml">arm_compute::CLROIPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reduction_operation_kernel.xhtml">arm_compute::CLReductionOperationKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_reduction_operation.xhtml">arm_compute::CLReductionOperation</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_reshape_layer_kernel.xhtml">arm_compute::CLReshapeLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_reshape_layer.xhtml">arm_compute::CLReshapeLayer</a></li>
</ul>
</li>
</ul>
<p>v17.06 Public major release</p><ul>
<li>Various bug fixes</li>
<li>Added support for fixed point 8 bit (QS8) to the various NEON machine learning kernels.</li>
<li>Added unit tests and benchmarks (AlexNet, LeNet)</li>
<li>Added support for sub tensors.</li>
<li>Added infrastructure to provide GPU specific optimisation for some OpenCL kernels.</li>
<li>Added <a class="el" href="classarm__compute_1_1_o_m_p_scheduler.xhtml">arm_compute::OMPScheduler</a> (OpenMP) scheduler for NEON</li>
<li>Added <a class="el" href="classarm__compute_1_1_single_thread_scheduler.xhtml">arm_compute::SingleThreadScheduler</a> scheduler for NEON (For bare metal)</li>
<li>User can specify his own scheduler by implementing the <a class="el" href="classarm__compute_1_1_i_scheduler.xhtml">arm_compute::IScheduler</a> interface.</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer_kernel.xhtml">arm_compute::CLBatchNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_batch_normalization_layer.xhtml">arm_compute::CLBatchNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_depth_concatenate_layer_kernel.xhtml">arm_compute::CLDepthConcatenateLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_depth_concatenate_layer.xhtml">arm_compute::CLDepthConcatenateLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_h_o_g_orientation_binning_kernel.xhtml">arm_compute::CLHOGOrientationBinningKernel</a> <a class="el" href="classarm__compute_1_1_c_l_h_o_g_block_normalization_kernel.xhtml">arm_compute::CLHOGBlockNormalizationKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_h_o_g_detector_kernel.xhtml">arm_compute::CLHOGDetectorKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_h_o_g_descriptor.xhtml">arm_compute::CLHOGDescriptor</a> <a class="el" href="classarm__compute_1_1_c_l_h_o_g_detector.xhtml">arm_compute::CLHOGDetector</a> <a class="el" href="classarm__compute_1_1_c_l_h_o_g_gradient.xhtml">arm_compute::CLHOGGradient</a> <a class="el" href="classarm__compute_1_1_c_l_h_o_g_multi_detection.xhtml">arm_compute::CLHOGMultiDetection</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_locally_connected_matrix_multiply_kernel.xhtml">arm_compute::CLLocallyConnectedMatrixMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_locally_connected_layer.xhtml">arm_compute::CLLocallyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_weights_reshape_kernel.xhtml">arm_compute::CLWeightsReshapeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_convolution_layer_reshape_weights.xhtml">arm_compute::CLConvolutionLayerReshapeWeights</a></li>
</ul>
</li>
<li>New C++ kernels:<ul>
<li><a class="el" href="classarm__compute_1_1_c_p_p_detection_window_non_maxima_suppression_kernel.xhtml">arm_compute::CPPDetectionWindowNonMaximaSuppressionKernel</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_batch_normalization_layer_kernel.xhtml">arm_compute::NEBatchNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_batch_normalization_layer.xhtml">arm_compute::NEBatchNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_depth_concatenate_layer_kernel.xhtml">arm_compute::NEDepthConcatenateLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_depth_concatenate_layer.xhtml">arm_compute::NEDepthConcatenateLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer_kernel.xhtml">arm_compute::NEDirectConvolutionLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_direct_convolution_layer.xhtml">arm_compute::NEDirectConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_locally_connected_matrix_multiply_kernel.xhtml">arm_compute::NELocallyConnectedMatrixMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_locally_connected_layer.xhtml">arm_compute::NELocallyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_weights_reshape_kernel.xhtml">arm_compute::NEWeightsReshapeKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_convolution_layer_reshape_weights.xhtml">arm_compute::NEConvolutionLayerReshapeWeights</a></li>
</ul>
</li>
</ul>
<p>v17.05 Public bug fixes release</p><ul>
<li>Various bug fixes</li>
<li>Remaining of the functions ported to use accurate padding.</li>
<li>Library does not link against OpenCL anymore (It uses dlopen / dlsym at runtime instead to determine whether or not OpenCL is available).</li>
<li>Added "free" method to allocator.</li>
<li>Minimum version of g++ required for armv7 Linux changed from 4.8 to 4.9</li>
</ul>
<p>v17.04 Public bug fixes release</p>
<p>The following functions have been ported to use the new accurate padding:</p><ul>
<li><a class="el" href="classarm__compute_1_1_c_l_color_convert_kernel.xhtml">arm_compute::CLColorConvertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_edge_non_max_suppression_kernel.xhtml">arm_compute::CLEdgeNonMaxSuppressionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_edge_trace_kernel.xhtml">arm_compute::CLEdgeTraceKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_hor_kernel.xhtml">arm_compute::CLGaussianPyramidHorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_vert_kernel.xhtml">arm_compute::CLGaussianPyramidVertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gradient_kernel.xhtml">arm_compute::CLGradientKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_channel_combine_kernel.xhtml">arm_compute::NEChannelCombineKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_fill_array_kernel.xhtml">arm_compute::NEFillArrayKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid_hor_kernel.xhtml">arm_compute::NEGaussianPyramidHorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid_vert_kernel.xhtml">arm_compute::NEGaussianPyramidVertKernel</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a0b6679b5d5c7f7dc527258181b04cf35">arm_compute::NEHarrisScoreFP16Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_harris_score_kernel.xhtml">arm_compute::NEHarrisScoreKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector_kernel.xhtml">arm_compute::NEHOGDetectorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_max_kernel.xhtml">arm_compute::NELogits1DMaxKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_shift_exp_sum_kernel.xhtml">arm_compute::NELogits1DShiftExpSumKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_norm_kernel.xhtml">arm_compute::NELogits1DNormKernel</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a38cad49e6beaef76bc1ec5064c9e9dba">arm_compute::NENonMaximaSuppression3x3FP16Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_maxima_suppression3x3_kernel.xhtml">arm_compute::NENonMaximaSuppression3x3Kernel</a></li>
</ul>
<p>v17.03.1 First Major public release of the sources</p><ul>
<li>Renamed the library to <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a></li>
<li>New CPP target introduced for C++ kernels shared between NEON and CL functions.</li>
<li>New padding calculation interface introduced and ported most kernels / functions to use it.</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_kernel.xhtml">arm_compute::CLGEMMLowpMatrixMultiplyKernel</a> / arm_compute::CLGEMMLowp</li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_normalization_layer_kernel.xhtml">arm_compute::NENormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_normalization_layer.xhtml">arm_compute::NENormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_transpose_kernel.xhtml">arm_compute::NETransposeKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_transpose.xhtml">arm_compute::NETranspose</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_max_kernel.xhtml">arm_compute::NELogits1DMaxKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_logits1_d_shift_exp_sum_kernel.xhtml">arm_compute::NELogits1DShiftExpSumKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_logits1_d_norm_kernel.xhtml">arm_compute::NELogits1DNormKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_softmax_layer.xhtml">arm_compute::NESoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_im2_col_kernel.xhtml">arm_compute::NEIm2ColKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_col2_im_kernel.xhtml">arm_compute::NECol2ImKernel</a>, arm_compute::NEConvolutionLayerWeightsReshapeKernel / <a class="el" href="classarm__compute_1_1_n_e_convolution_layer.xhtml">arm_compute::NEConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_accumulate_biases_kernel.xhtml">arm_compute::NEGEMMMatrixAccumulateBiasesKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_fully_connected_layer.xhtml">arm_compute::NEFullyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_multiply_kernel.xhtml">arm_compute::NEGEMMLowpMatrixMultiplyKernel</a> / arm_compute::NEGEMMLowp</li>
</ul>
</li>
</ul>
<p>v17.03 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_gradient_kernel.xhtml">arm_compute::CLGradientKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_edge_non_max_suppression_kernel.xhtml">arm_compute::CLEdgeNonMaxSuppressionKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_edge_trace_kernel.xhtml">arm_compute::CLEdgeTraceKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_canny_edge.xhtml">arm_compute::CLCannyEdge</a></li>
<li>GEMM refactoring + FP16 support: <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_interleave4x4_kernel.xhtml">arm_compute::CLGEMMInterleave4x4Kernel</a>, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_transpose1x_w_kernel.xhtml">arm_compute::CLGEMMTranspose1xWKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_kernel.xhtml">arm_compute::CLGEMMMatrixMultiplyKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_addition_kernel.xhtml">arm_compute::CLGEMMMatrixAdditionKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m.xhtml">arm_compute::CLGEMM</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_accumulate_biases_kernel.xhtml">arm_compute::CLGEMMMatrixAccumulateBiasesKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_fully_connected_layer.xhtml">arm_compute::CLFullyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_transpose_kernel.xhtml">arm_compute::CLTransposeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_transpose.xhtml">arm_compute::CLTranspose</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_init_kernel.xhtml">arm_compute::CLLKTrackerInitKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_stage0_kernel.xhtml">arm_compute::CLLKTrackerStage0Kernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_stage1_kernel.xhtml">arm_compute::CLLKTrackerStage1Kernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_finalize_kernel.xhtml">arm_compute::CLLKTrackerFinalizeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_optical_flow.xhtml">arm_compute::CLOpticalFlow</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_normalization_layer_kernel.xhtml">arm_compute::CLNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_normalization_layer.xhtml">arm_compute::CLNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_laplacian_pyramid.xhtml">arm_compute::CLLaplacianPyramid</a>, <a class="el" href="classarm__compute_1_1_c_l_laplacian_reconstruct.xhtml">arm_compute::CLLaplacianReconstruct</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_activation_layer_kernel.xhtml">arm_compute::NEActivationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_activation_layer.xhtml">arm_compute::NEActivationLayer</a></li>
<li>GEMM refactoring + FP16 support (Requires armv8.2 CPU): <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_interleave4x4_kernel.xhtml">arm_compute::NEGEMMInterleave4x4Kernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_transpose1x_w_kernel.xhtml">arm_compute::NEGEMMTranspose1xWKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_multiply_kernel.xhtml">arm_compute::NEGEMMMatrixMultiplyKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_addition_kernel.xhtml">arm_compute::NEGEMMMatrixAdditionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m.xhtml">arm_compute::NEGEMM</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pooling_layer_kernel.xhtml">arm_compute::NEPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_pooling_layer.xhtml">arm_compute::NEPoolingLayer</a></li>
</ul>
</li>
</ul>
<p>v17.02.1 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_logits1_d_max_kernel.xhtml">arm_compute::CLLogits1DMaxKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_logits1_d_shift_exp_sum_kernel.xhtml">arm_compute::CLLogits1DShiftExpSumKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_logits1_d_norm_kernel.xhtml">arm_compute::CLLogits1DNormKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_softmax_layer.xhtml">arm_compute::CLSoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_pooling_layer_kernel.xhtml">arm_compute::CLPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_pooling_layer.xhtml">arm_compute::CLPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_im2_col_kernel.xhtml">arm_compute::CLIm2ColKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_col2_im_kernel.xhtml">arm_compute::CLCol2ImKernel</a>, arm_compute::CLConvolutionLayerWeightsReshapeKernel / <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">arm_compute::CLConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_remap_kernel.xhtml">arm_compute::CLRemapKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_remap.xhtml">arm_compute::CLRemap</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_hor_kernel.xhtml">arm_compute::CLGaussianPyramidHorKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_vert_kernel.xhtml">arm_compute::CLGaussianPyramidVertKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid.xhtml">arm_compute::CLGaussianPyramid</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_half.xhtml">arm_compute::CLGaussianPyramidHalf</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_orb.xhtml">arm_compute::CLGaussianPyramidOrb</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_min_max_kernel.xhtml">arm_compute::CLMinMaxKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_min_max_location_kernel.xhtml">arm_compute::CLMinMaxLocationKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_min_max_location.xhtml">arm_compute::CLMinMaxLocation</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_non_linear_filter_kernel.xhtml">arm_compute::CLNonLinearFilterKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_non_linear_filter.xhtml">arm_compute::CLNonLinearFilter</a></li>
</ul>
</li>
<li>New NEON FP16 kernels (Requires armv8.2 CPU)<ul>
<li><a class="el" href="namespacearm__compute.xhtml#aff99c045b07329b332b1cb97a2dd1518">arm_compute::NEAccumulateWeightedFP16Kernel</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a96f7f6f98dc47e0dc3b928bf87397ebf">arm_compute::NEBox3x3FP16Kernel</a></li>
<li><a class="el" href="namespacearm__compute.xhtml#a38cad49e6beaef76bc1ec5064c9e9dba">arm_compute::NENonMaximaSuppression3x3FP16Kernel</a></li>
</ul>
</li>
</ul>
<p>v17.02 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_activation_layer_kernel.xhtml">arm_compute::CLActivationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_activation_layer.xhtml">arm_compute::CLActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_combine_kernel.xhtml">arm_compute::CLChannelCombineKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_channel_combine.xhtml">arm_compute::CLChannelCombine</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_derivative_kernel.xhtml">arm_compute::CLDerivativeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_channel_extract.xhtml">arm_compute::CLChannelExtract</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_fast_corners_kernel.xhtml">arm_compute::CLFastCornersKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_fast_corners.xhtml">arm_compute::CLFastCorners</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_mean_std_dev_kernel.xhtml">arm_compute::CLMeanStdDevKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_mean_std_dev.xhtml">arm_compute::CLMeanStdDev</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li>HOG / SVM: <a class="el" href="classarm__compute_1_1_n_e_h_o_g_orientation_binning_kernel.xhtml">arm_compute::NEHOGOrientationBinningKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_block_normalization_kernel.xhtml">arm_compute::NEHOGBlockNormalizationKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector_kernel.xhtml">arm_compute::NEHOGDetectorKernel</a>, arm_compute::NEHOGNonMaximaSuppressionKernel / <a class="el" href="classarm__compute_1_1_n_e_h_o_g_descriptor.xhtml">arm_compute::NEHOGDescriptor</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector.xhtml">arm_compute::NEHOGDetector</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_gradient.xhtml">arm_compute::NEHOGGradient</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_multi_detection.xhtml">arm_compute::NEHOGMultiDetection</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_linear_filter_kernel.xhtml">arm_compute::NENonLinearFilterKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_non_linear_filter.xhtml">arm_compute::NENonLinearFilter</a></li>
</ul>
</li>
<li>Introduced a CLScheduler to manage the default context and command queue used by the runtime library and create synchronisation events.</li>
<li>Switched all the kernels / functions to use tensors instead of images.</li>
<li>Updated documentation to include instructions to build the library from sources.</li>
</ul>
<p>v16.12 Binary preview release</p><ul>
<li>Original release</li>
</ul>
<h1><a class="anchor" id="S3_how_to_build"></a>
How to build the library and the examples</h1>
<h2><a class="anchor" id="S3_1_build_options"></a>
Build options</h2>
<p>scons 2.3 or above is required to build the library. To see the build options available simply run <code>scons -h</code>: </p><pre class="fragment">debug: Debug (yes|no)
    default: False
    actual: False

asserts: Enable asserts (this flag is forced to 1 for debug=1) (yes|no)
    default: False
    actual: False

arch: Target Architecture (armv7a|arm64-v8a|arm64-v8.2-a|x86_32|x86_64)
    default: armv7a
    actual: armv7a

os: Target OS (linux|android|bare_metal)
    default: linux
    actual: linux

build: Build type (native|cross_compile)
    default: cross_compile
    actual: cross_compile

examples: Build example programs (yes|no)
    default: True
    actual: True

Werror: Enable/disable the -Werror compilation flag (yes|no)
    default: True
    actual: True

opencl: Enable OpenCL support (yes|no)
    default: True
    actual: True

neon: Enable Neon support (yes|no)
    default: False
    actual: False

gles_compute: Enable OpenGL ES Compute Shader support (yes|no)
    default: False
    actual: False

embed_kernels: Embed OpenCL kernels and OpenGL ES compute shader in library binary (yes|no)
    default: False
    actual: False

set_soname: Set the library's soname and shlibversion (requires SCons 2.4 or above) (yes|no)
    default: False
    actual: False

openmp: Enable OpenMP backend (yes|no)
    default: False
    actual: False

cppthreads: Enable C++11 threads backend (yes|no)
    default: True
    actual: True

build_dir: Specify sub-folder for the build ( /path/to/build_dir )
    default: .
    actual: .

extra_cxx_flags: Extra CXX flags to be appended to the build command
    default:
    actual:

pmu: Enable PMU counters (yes|no)
    default: False
    actual: False

mali: Enable Mali hardware counters (yes|no)
    default: False
    actual: False

validation_tests: Build validation test programs (yes|no)
    default: False
    actual: False

benchmark_tests: Build benchmark test programs (yes|no)
    default: False
    actual: False
</pre><p><b>debug</b> / <b>asserts:</b> </p><ul>
<li>With debug=1 asserts are enabled, and the library is built with symbols and no optimisations enabled.</li>
<li>With debug=0 and asserts=1: Optimisations are enabled and symbols are removed, however all the asserts are still present (This is about 20% slower than the release build)</li>
<li>With debug=0 and asserts=0: All optimisations are enable and no validation is performed, if the application misuses the library it is likely to result in a crash. (Only use this mode once you are sure your application is working as expected).</li>
</ul>
<p><b>arch:</b> The x86_32 and x86_64 targets can only be used with neon=0 and opencl=1.</p>
<p><b>os:</b> Choose the operating system you are targeting: Linux, Android or bare metal. </p><dl class="section note"><dt>Note</dt><dd>bare metal can only be used for NEON (not OpenCL), only static libraries get built and NEON's multi-threading support is disabled.</dd></dl>
<p><b>build:</b> you can either build directly on your device (native) or cross compile from your desktop machine (cross-compile). In both cases make sure the compiler is available in your path.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to natively compile for 32bit on a 64bit ARM device running a 64bit OS then you will have to use cross-compile too.</dd></dl>
<p><b>Werror:</b> If you are compiling using the same toolchains as the ones used in this guide then there shouldn't be any warning and therefore you should be able to keep Werror=1. If with a different compiler version the library fails to build because of warnings interpreted as errors then, if you are sure the warnings are not important, you might want to try to build with Werror=0 (But please do report the issue either on Github or by an email to <a href="#" onclick="location.href='mai'+'lto:'+'dev'+'el'+'ope'+'r@'+'arm'+'.c'+'om'; return false;">devel<span style="display: none;">.nosp@m.</span>oper<span style="display: none;">.nosp@m.</span>@arm.<span style="display: none;">.nosp@m.</span>com</a> so that the issue can be addressed).</p>
<p><b>opencl</b> / <b>neon</b> / <b>gles_compute:</b> Choose which SIMD technology you want to target. (NEON for ARM Cortex-A CPUs or OpenCL / GLES_COMPUTE for ARM Mali GPUs)</p>
<p><b>embed_kernels:</b> For OpenCL / GLES_COMPUTE only: set embed_kernels=1 if you want the OpenCL / GLES_COMPUTE kernels to be built in the library's binaries instead of being read from separate ".cl" / ".cs" files. If embed_kernels is set to 0 then the application can set the path to the folder containing the OpenCL / GLES_COMPUTE kernel files by calling CLKernelLibrary::init() / GCKernelLibrary::init(). By default the path is set to "./cl_kernels" / "./cs_shaders".</p>
<p><b>set_soname:</b> Do you want to build the versioned version of the library ?</p>
<p>If enabled the library will contain a SONAME and SHLIBVERSION and some symlinks will automatically be created between the objects. Example: libarm_compute_core.so -&gt; libarm_compute_core.so.1.0.0 libarm_compute_core.so.1 -&gt; libarm_compute_core.so.1.0.0 libarm_compute_core.so.1.0.0</p>
<dl class="section note"><dt>Note</dt><dd>This options is disabled by default as it requires SCons version 2.4 or above.</dd></dl>
<p><b>extra_cxx_flags:</b> Custom CXX flags which will be appended to the end of the build command.</p>
<p><b>build_dir:</b> Build the library in a subfolder of the "build" folder. (Allows to build several configurations in parallel).</p>
<p><b>examples:</b> Build or not the examples</p>
<p><b>validation_tests:</b> Enable the build of the validation suite.</p>
<p><b>benchmark_tests:</b> Enable the build of the benchmark tests</p>
<p><b>pmu:</b> Enable the PMU cycle counter to measure execution time in benchmark tests. (Your device needs to support it)</p>
<p><b>mali:</b> Enable the collection of Mali hardware counters to measure execution time in benchmark tests. (Your device needs to have a Mali driver that supports it)</p>
<p><b>openmp</b> Build in the OpenMP scheduler for NEON.</p>
<dl class="section note"><dt>Note</dt><dd>Only works when building with g++ not clang++</dd></dl>
<p><b>cppthreads</b> Build in the C++11 scheduler for NEON.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classarm__compute_1_1_scheduler.xhtml#aa35fa7aa123444c798c28d4ac8fe7546" title="Sets the user defined scheduler and makes it the active scheduler. ">arm_compute::Scheduler::set</a></dd></dl>
<h2><a class="anchor" id="S3_2_linux"></a>
Building for Linux</h2>
<h3><a class="anchor" id="S3_2_1_library"></a>
How to build the library ?</h3>
<p>For Linux, the library was successfully built and tested using the following Linaro GCC toolchain:</p>
<ul>
<li>gcc-linaro-arm-linux-gnueabihf-4.9-2014.07_linux</li>
<li>gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu</li>
<li>gcc-linaro-6.3.1-2017.02-i686_aarch64-linux-gnu</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If you are building with opencl=1 then scons will expect to find libOpenCL.so either in the current directory or in "build" (See the section below if you need a stub OpenCL library to link against) </dd>
<dd>
If you are building with gles_compute=1 then scons will expect to find libEGL.so / libGLESv1_CM.so / libGLESv2.so either in the current directory or in "build" (See the section below if you need a stub OpenCL library to link against)</dd></dl>
<p>To cross-compile the library in debug mode, with NEON only support, for Linux 32bit: </p><pre class="fragment">scons Werror=1 -j8 debug=1 neon=1 opencl=0 os=linux arch=armv7a
</pre><p>To cross-compile the library in asserts mode, with OpenCL only support, for Linux 64bit: </p><pre class="fragment">scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=1 embed_kernels=1 os=linux arch=arm64-v8a
</pre><p>To cross-compile the library in asserts mode, with GLES_COMPUTE only support, for Linux 64bit: </p><pre class="fragment">scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=0 gles_compute=1 embed_kernels=1 os=linux arch=arm64-v8a
</pre><p>You can also compile the library natively on an ARM device by using <b>build=native</b>: </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=arm64-v8a build=native
scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a build=native
</pre><dl class="section note"><dt>Note</dt><dd>g++ for ARM is mono-arch, therefore if you want to compile for Linux 32bit on a Linux 64bit platform you will have to use a cross compiler.</dd></dl>
<p>For example on a 64bit Debian based system you would have to install <b>g++-arm-linux-gnueabihf</b> </p><pre class="fragment">apt-get install g++-arm-linux-gnueabihf
</pre><p>Then run </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a build=cross_compile
</pre><p>or simply remove the build parameter as build=cross_compile is the default value: </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a
</pre><dl class="section attention"><dt>Attention</dt><dd>To cross compile with opencl=1 you need to make sure to have a version of libOpenCL matching your target architecture.</dd></dl>
<h3><a class="anchor" id="S3_2_2_examples"></a>
How to manually build the examples ?</h3>
<p>The examples get automatically built by scons as part of the build process of the library described above. This section just describes how you can build and link your own application against our library.</p>
<dl class="section note"><dt>Note</dt><dd>The following command lines assume the <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a> and libOpenCL binaries are present in the current directory or in the system library path. If this is not the case you can specify the location of the pre-built library with the compiler option -L. When building the OpenCL example the commands below assume that the CL headers are located in the include folder where the command is executed.</dd></dl>
<p>To cross compile a NEON example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute -larm_compute_core -o neon_convolution
</pre><p>To cross compile a NEON example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -L. -larm_compute -larm_compute_core -o neon_convolution
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option and the compiler's name is different)</p>
<p>To cross compile an OpenCL example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute -larm_compute_core -lOpenCL -o cl_convolution -DARM_COMPUTE_CL
</pre><p>To cross compile an OpenCL example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -L. -larm_compute -larm_compute_core -lOpenCL -o cl_convolution -DARM_COMPUTE_CL
</pre><p>To cross compile a GLES example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/gc_absdiff.cpp utils/Utils.cpp -I. -Iinclude/ -L. -larm_compute -larm_compute_core -std=c++11 -mfpu=neon -DARM_COMPUTE_GC -Iinclude/linux/ -o gc_absdiff
</pre><p>To cross compile a GLES example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/gc_absdiff.cpp utils/Utils.cpp -I. -Iinclude/ -L. -larm_compute -larm_compute_core -std=c++11 -DARM_COMPUTE_GC -Iinclude/linux/ -o gc_absdiff
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option and the compiler's name is different)</p>
<p>To cross compile the examples with the Graph API, such as <a class="el" href="graph__lenet_8cpp.xhtml">graph_lenet.cpp</a>, you need to link the examples against arm_compute_graph.so too.</p>
<dl class="section note"><dt>Note</dt><dd>The compute library must currently be built with both neon and opencl enabled - neon=1 and opencl=1</dd></dl>
<p>i.e. to cross compile the "graph_lenet" example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute_graph -larm_compute -larm_compute_core -Wl,--allow-shlib-undefined -o graph_lenet
</pre><p>i.e. to cross compile the "graph_lenet" example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp -I. -Iinclude -std=c++11 -L. -larm_compute_graph -larm_compute -larm_compute_core -Wl,--allow-shlib-undefined -o graph_lenet
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option and the compiler's name is different)</p>
<dl class="section note"><dt>Note</dt><dd>If compiling using static libraries, this order must be followed when linking: arm_compute_graph_static, <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a>, arm_compute_core</dd></dl>
<p>To compile natively (i.e directly on an ARM device) for NEON for Linux 32bit: </p><pre class="fragment">g++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -larm_compute -larm_compute_core -o neon_convolution
</pre><p>To compile natively (i.e directly on an ARM device) for NEON for Linux 64bit: </p><pre class="fragment">g++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute -larm_compute_core -o neon_convolution
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option)</p>
<p>To compile natively (i.e directly on an ARM device) for OpenCL for Linux 32bit or Linux 64bit: </p><pre class="fragment">g++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute -larm_compute_core -lOpenCL -o cl_convolution -DARM_COMPUTE_CL
</pre><p>To compile natively (i.e directly on an ARM device) for GLES for Linux 32bit or Linux 64bit: </p><pre class="fragment">g++ examples/gc_absdiff.cpp utils/Utils.cpp -I. -Iinclude/ -L. -larm_compute -larm_compute_core -std=c++11 -DARM_COMPUTE_GC -Iinclude/linux/ -o gc_absdiff
</pre><p>To compile natively the examples with the Graph API, such as <a class="el" href="graph__lenet_8cpp.xhtml">graph_lenet.cpp</a>, you need to link the examples against arm_compute_graph.so too. </p><dl class="section note"><dt>Note</dt><dd>The compute library must currently be built with both neon and opencl enabled - neon=1 and opencl=1</dd></dl>
<p>i.e. to natively compile the "graph_lenet" example for Linux 32bit: </p><pre class="fragment">g++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute_graph -larm_compute -larm_compute_core -Wl,--allow-shlib-undefined -o graph_lenet
</pre><p>i.e. to natively compile the "graph_lenet" example for Linux 64bit: </p><pre class="fragment">g++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp -I. -Iinclude -std=c++11 L. -larm_compute_graph -larm_compute -larm_compute_core -Wl,--allow-shlib-undefined -o graph_lenet
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option)</p>
<dl class="section note"><dt>Note</dt><dd>If compiling using static libraries, this order must be followed when linking: arm_compute_graph_static, <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a>, arm_compute_core</dd>
<dd>
These two commands assume libarm_compute.so is available in your library path, if not add the path to it using -L</dd></dl>
<p>To run the built executable simply run: </p><pre class="fragment">LD_LIBRARY_PATH=build ./neon_convolution
</pre><p>or </p><pre class="fragment">LD_LIBRARY_PATH=build ./cl_convolution
</pre><h2><a class="anchor" id="S3_3_android"></a>
Building for Android</h2>
<p>For Android, the library was successfully built and tested using Google's standalone toolchains:</p><ul>
<li>NDK r14 arm-linux-androideabi-4.9 for armv7a (clang++)</li>
<li>NDK r14 aarch64-linux-android-4.9 for arm64-v8a (clang++)</li>
</ul>
<p>Here is a guide to <a href="https://developer.android.com/ndk/guides/standalone_toolchain.html">create your Android standalone toolchains from the NDK</a></p>
<ul>
<li>Download the NDK r14 from here: <a href="https://developer.android.com/ndk/downloads/index.html">https://developer.android.com/ndk/downloads/index.html</a></li>
<li>Make sure you have Python 2 installed on your machine.</li>
<li>Generate the 32 and/or 64 toolchains by running the following commands:</li>
</ul>
<pre class="fragment">$NDK/build/tools/make_standalone_toolchain.py --arch arm64 --install-dir $MY_TOOLCHAINS/aarch64-linux-android-4.9 --stl gnustl --api 21
$NDK/build/tools/make_standalone_toolchain.py --arch arm --install-dir $MY_TOOLCHAINS/arm-linux-androideabi-4.9 --stl gnustl --api 21
</pre><dl class="section attention"><dt>Attention</dt><dd>Due to some NDK issues make sure you use clang++ &amp; gnustl</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Make sure to add the toolchains to your PATH: export PATH=$PATH:$MY_TOOLCHAINS/aarch64-linux-android-4.9/bin:$MY_TOOLCHAINS/arm-linux-androideabi-4.9/bin</dd></dl>
<h3><a class="anchor" id="S3_3_1_library"></a>
How to build the library ?</h3>
<dl class="section note"><dt>Note</dt><dd>If you are building with opencl=1 then scons will expect to find libOpenCL.so either in the current directory or in "build" (See the section below if you need a stub OpenCL library to link against)</dd></dl>
<p>To cross-compile the library in debug mode, with NEON only support, for Android 32bit: </p><pre class="fragment">CXX=clang++ CC=clang scons Werror=1 -j8 debug=1 neon=1 opencl=0 os=android arch=armv7a
</pre><p>To cross-compile the library in asserts mode, with OpenCL only support, for Android 64bit: </p><pre class="fragment">CXX=clang++ CC=clang scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=1 embed_kernels=1 os=android arch=arm64-v8a
</pre><p>To cross-compile the library in asserts mode, with GLES_COMPUTE only support, for Android 64bit: </p><pre class="fragment">CXX=clang++ CC=clang scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=0 gles_compute=1 embed_kernels=1 os=android arch=arm64-v8a
</pre><h3><a class="anchor" id="S3_3_2_examples"></a>
How to manually build the examples ?</h3>
<p>The examples get automatically built by scons as part of the build process of the library described above. This section just describes how you can build and link your own application against our library.</p>
<dl class="section note"><dt>Note</dt><dd>The following command lines assume the <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a> and libOpenCL binaries are present in the current directory or in the system library path. If this is not the case you can specify the location of the pre-built library with the compiler option -L. When building the OpenCL example the commands below assume that the CL headers are located in the include folder where the command is executed.</dd></dl>
<p>Once you've got your Android standalone toolchain built and added to your path you can do the following:</p>
<p>To cross compile a NEON example: </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o neon_convolution_arm -static-libstdc++ -pie
#64 bit:
aarch64-linux-android-clang++ examples/neon_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o neon_convolution_aarch64 -static-libstdc++ -pie
</pre><p>To cross compile an OpenCL example: </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o cl_convolution_arm -static-libstdc++ -pie -lOpenCL -DARM_COMPUTE_CL
#64 bit:
aarch64-linux-android-clang++ examples/cl_convolution.cpp utils/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o cl_convolution_aarch64 -static-libstdc++ -pie -lOpenCL -DARM_COMPUTE_CL
</pre><p>To cross compile a GLES example: #32 bit: arm-linux-androideabi-clang++ <a class="el" href="gc__absdiff_8cpp.xhtml">examples/gc_absdiff.cpp</a> <a class="el" href="utils_2_utils_8cpp.xhtml">utils/Utils.cpp</a> -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o gc_absdiff_arm -static-libstdc++ -pie -DARM_COMPUTE_GC #64 bit: aarch64-linux-android-clang++ <a class="el" href="gc__absdiff_8cpp.xhtml">examples/gc_absdiff.cpp</a> <a class="el" href="utils_2_utils_8cpp.xhtml">utils/Utils.cpp</a> -I. -Iinclude -std=c++11 -larm_compute-static -larm_compute_core-static -L. -o gc_absdiff_aarch64 -static-libstdc++ -pie -DARM_COMPUTE_GC</p>
<p>To cross compile the examples with the Graph API, such as <a class="el" href="graph__lenet_8cpp.xhtml">graph_lenet.cpp</a>, you need to link the library arm_compute_graph also. (notice the compute library has to be built with both neon and opencl enabled - neon=1 and opencl=1) </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp -I. -Iinclude -std=c++11 -Wl,--whole-archive -larm_compute_graph-static -Wl,--no-whole-archive -larm_compute-static -larm_compute_core-static -L. -o graph_lenet_arm -static-libstdc++ -pie -lOpenCL -DARM_COMPUTE_CL
#64 bit:
aarch64-linux-android-clang++ examples/graph_lenet.cpp utils/Utils.cpp utils/GraphUtils.cpp -I. -Iinclude -std=c++11 -Wl,--whole-archive -larm_compute_graph-static -Wl,--no-whole-archive -larm_compute-static -larm_compute_core-static -L. -o graph_lenet_aarch64 -static-libstdc++ -pie -lOpenCL -DARM_COMPUTE_CL
</pre><dl class="section note"><dt>Note</dt><dd>Due to some issues in older versions of the Mali OpenCL DDK (&lt;= r13p0), we recommend to link <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a> statically on Android. </dd>
<dd>
When linked statically the arm_compute_graph library currently needs the &ndash;whole-archive linker flag in order to work properly</dd></dl>
<p>Then you need to do is upload the executable and the shared library to the device using ADB: </p><pre class="fragment">adb push neon_convolution_arm /data/local/tmp/
adb push cl_convolution_arm /data/local/tmp/
adb push gc_absdiff_arm /data/local/tmp/
adb shell chmod 777 -R /data/local/tmp/
</pre><p>And finally to run the example: </p><pre class="fragment">adb shell /data/local/tmp/neon_convolution_arm
adb shell /data/local/tmp/cl_convolution_arm
adb shell /data/local/tmp/gc_absdiff_arm
</pre><p>For 64bit: </p><pre class="fragment">adb push neon_convolution_aarch64 /data/local/tmp/
adb push cl_convolution_aarch64 /data/local/tmp/
adb push gc_absdiff_aarch64 /data/local/tmp/
adb shell chmod 777 -R /data/local/tmp/
</pre><p>And finally to run the example: </p><pre class="fragment">adb shell /data/local/tmp/neon_convolution_aarch64
adb shell /data/local/tmp/cl_convolution_aarch64
adb shell /data/local/tmp/gc_absdiff_aarch64
</pre><h2><a class="anchor" id="S3_4_bare_metal"></a>
Building for bare metal</h2>
<p>For bare metal, the library was successfully built using linaros's latest (gcc-linaro-6.3.1-2017.05) bare metal toolchains:</p><ul>
<li>arm-eabi for armv7a</li>
<li>aarch64-elf for arm64-v8a</li>
</ul>
<p>Download linaro for <a href="https://releases.linaro.org/components/toolchain/binaries/6.3-2017.05/arm-eabi/">armv7a</a> and <a href="https://releases.linaro.org/components/toolchain/binaries/6.3-2017.05/aarch64-elf/">arm64-v8a</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Make sure to add the toolchains to your PATH: export PATH=$PATH:$MY_TOOLCHAINS/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-elf/bin:$MY_TOOLCHAINS/gcc-linaro-6.3.1-2017.05-x86_64_arm-eabi/bin</dd></dl>
<h3><a class="anchor" id="S3_4_1_library"></a>
How to build the library ?</h3>
<p>To cross-compile the library with NEON support for baremetal arm64-v8a: </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=bare_metal arch=arm64-v8a build=cross_compile cppthreads=0 openmp=0 standalone=1
</pre><h3><a class="anchor" id="S3_4_2_examples"></a>
How to manually build the examples ?</h3>
<p>Examples are disabled when building for bare metal. If you want to build the examples you need to provide a custom bootcode depending on the target architecture and link against the compute library. More information about bare metal bootcode can be found <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0527a/index.html">here</a>.</p>
<h2><a class="anchor" id="S3_5_windows_host"></a>
Building on a Windows host system</h2>
<p>Using <code>scons</code> directly from the Windows command line is known to cause problems. The reason seems to be that if <code>scons</code> is setup for cross-compilation it gets confused about Windows style paths (using backslashes). Thus it is recommended to follow one of the options outlined below.</p>
<h3><a class="anchor" id="S3_5_1_ubuntu_on_windows"></a>
Bash on Ubuntu on Windows</h3>
<p>The best and easiest option is to use <a href="https://msdn.microsoft.com/en-gb/commandline/wsl/about">Ubuntu on Windows</a>. This feature is still marked as <em>beta</em> and thus might not be available. However, if it is building the library is as simple as opening a <em>Bash on Ubuntu on Windows</em> shell and following the general guidelines given above.</p>
<h3><a class="anchor" id="S3_5_2_cygwin"></a>
Cygwin</h3>
<p>If the Windows subsystem for Linux is not available <a href="https://www.cygwin.com/">Cygwin</a> can be used to install and run <code>scons</code>. In addition to the default packages installed by Cygwin <code>scons</code> has to be selected in the installer. (<code>git</code> might also be useful but is not strictly required if you already have got the source code of the library.) Linaro provides pre-built versions of <a href="http://releases.linaro.org/components/toolchain/binaries/">GCC cross-compilers</a> that can be used from the Cygwin terminal. When building for Android the compiler is included in the Android standalone toolchain. After everything has been set up in the Cygwin terminal the general guide on building the library can be followed.</p>
<h2><a class="anchor" id="S3_6_cl_stub_library"></a>
The OpenCL stub library</h2>
<p>In the opencl-1.2-stubs folder you will find the sources to build a stub OpenCL library which then can be used to link your application or <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a> against.</p>
<p>If you preferred you could retrieve the OpenCL library from your device and link against this one but often this library will have dependencies on a range of system libraries forcing you to link your application against those too even though it is not using them.</p>
<dl class="section warning"><dt>Warning</dt><dd>This OpenCL library provided is a stub and <em>not</em> a real implementation. You can use it to resolve OpenCL's symbols in <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a> while building the example but you must make sure the real libOpenCL.so is in your PATH when running the example or it will not work.</dd></dl>
<p>To cross-compile the stub OpenCL library simply run: </p><pre class="fragment">&lt;target-prefix&gt;-gcc -o libOpenCL.so -Iinclude opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
</pre><p>For example: </p><pre class="fragment">#Linux 32bit
arm-linux-gnueabihf-gcc -o libOpenCL.so -Iinclude opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
#Linux 64bit
aarch64-linux-gnu-gcc -o libOpenCL.so -Iinclude -shared opencl-1.2-stubs/opencl_stubs.c -fPIC
#Android 32bit
arm-linux-androideabi-clang -o libOpenCL.so -Iinclude -shared opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
#Android 64bit
aarch64-linux-android-clang -o libOpenCL.so -Iinclude -shared opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
</pre><h2><a class="anchor" id="S3_7_gles_stub_library"></a>
The Linux OpenGLES and EGL stub libraries</h2>
<p>In the opengles-3.1-stubs folder you will find the sources to build stub EGL and OpenGLES libraries which then can be used to link your Linux application of <a class="el" href="namespacearm__compute.xhtml" title="This file contains all available output stages for GEMMLowp on OpenCL. ">arm_compute</a> against.</p>
<dl class="section note"><dt>Note</dt><dd>The stub libraries are only needed on Linux. For Android, the NDK toolchains already provide the meta-EGL and meta-GLES libraries.</dd></dl>
<p>To cross-compile the stub OpenGLES and EGL libraries simply run: </p><pre class="fragment">&lt;target-prefix&gt;-gcc -o libEGL.so -Iinclude/linux opengles-3.1-stubs/EGL.c -fPIC -shared
&lt;target-prefix&gt;-gcc -o libGLESv2.so -Iinclude/linux opengles-3.1-stubs/GLESv2.c -fPIC -shared

#Linux 32bit
arm-linux-gnueabihf-gcc -o libEGL.so -Iinclude/linux opengles-3.1-stubs/EGL.c -fPIC -shared
arm-linux-gnueabihf-gcc -o libGLESv2.so -Iinclude/linux opengles-3.1-stubs/GLESv2.c -fPIC -shared

#Linux 64bit
aarch64-linux-gnu-gcc -o libEGL.so -Iinclude/linux opengles-3.1-stubs/EGL.c -fPIC -shared
aarch64-linux-gnu-gcc -o libGLESv2.so -Iinclude/linux opengles-3.1-stubs/GLESv2.c -fPIC -shared</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 14 2017 23:48:39 for Compute Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
